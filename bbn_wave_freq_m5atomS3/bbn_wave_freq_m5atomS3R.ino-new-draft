/*
  Copyright 2024-2025, Mikhail Grushinskiy

  Estimate vessel heave (vertical displacement) in ocean waves using IMU on esp32 (m5atomS3R)

  See: https://github.com/bareboat-necessities/bbn-wave-period-esp32

  This version uses SeaStateFusionFilter (Kalman3D_Wave + online tuner + internal
  frequency tracker + KalmanWaveDirection).

  Ref:

  1. Alexey A. Bobtsov, Nikolay A. Nikolaev, Olga V. Slita, Alexander S. Borgul,
     Stanislav V. Aranovskiy
     "The New Algorithm of Sinusoidal Signal Frequency Estimation."
     11th IFAC International Workshop on Adaptation and Learning in Control and
     Signal Processing July 3-5, 2013. Caen, France

  2. R. Ali, T. van Waterschoot
     "A frequency tracker based on a Kalman filter update of a single parameter
      adaptive notch filter. KalmANF"
     Proceedings of the 26th International Conference on Digital Audio Effects
     (DAFx23), Copenhagen, Denmark, September 2023
*/

#include <M5Unified.h>
#include <Arduino.h>

#include <stdint.h>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
  #define EIGEN_STACK_ALLOCATION_LIMIT 0   // force Eigen's big temporaries to heap
#endif
#include <ArduinoEigenDense.h> // Eigen is used by Kalman3D_Wave / SeaStateFusionFilter

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Local constants

// Standard gravity
constexpr float g_std = 9.80665f;        // m/s^2

// Spike filter parameters (signal is in "g" units here)
constexpr int   ACCEL_SPIKE_FILTER_SIZE      = 8;
constexpr float ACCEL_SPIKE_FILTER_THRESHOLD = 0.4f;  // g
constexpr float ACCEL_CLAMP                  = 2.0f;  // max |a| in g

// Frequency guess used when tracker is not yet valid
constexpr float FREQ_GUESS = 0.3f;        // Hz

// Frequency validity band + relative gating coefficient
constexpr float FREQ_LOWER = 0.1f;        // Hz
constexpr float FREQ_UPPER = 5.0f;        // Hz
constexpr float FREQ_COEF  = 0.25f;       // dimensionless

// Window for min/max wave-height estimate: N periods
constexpr float HEIGHT_WINDOW_PERIODS = 3.0f;

enum class TrackerType { ARANOVSKIY = 0, KALMANF = 1, ZEROCROSS = 2 };

#define ZERO_CROSSINGS_SCALE          1.0f
#define ZERO_CROSSINGS_DEBOUNCE_TIME  0.12f
#define ZERO_CROSSINGS_STEEPNESS_TIME 0.21f

// Magnetometer cadence (BMM150-style ODR, same pattern as desktop runner)
constexpr float MAG_ODR_HZ = 100.0f;          // desired mag ODR (Hz)
constexpr float MAG_DT     = 1.0f / MAG_ODR_HZ;
static float   mag_phase_s = 0.0f;           // accumulates IMU dt until MAG_DT

// Clamp helper
template<typename T>
inline T clamp_val(T x, T lo, T hi) {
  if (x < lo) return lo;
  if (x > hi) return hi;
  return x;
}

// Min/max Lemire window length in microseconds from period
inline uint32_t getWindowMicros(double period_sec) {
  if (!(period_sec > 0.0)) return 0;
  double win_sec = HEIGHT_WINDOW_PERIODS * period_sec;
  double us = win_sec * 1e6;
  if (us < 0.0) us = 0.0;
  if (us > static_cast<double>(UINT32_MAX)) us = static_cast<double>(UINT32_MAX);
  return static_cast<uint32_t>(us);
}

#include "AngleAveraging.h"
#include "MinMaxLemire.h"
#include "TimeAwareSpikeFilter.h"
#include "NmeaXDR.h"
#include "M5_Calibr.h"
#include "SeaStateFusionFilter.h"

// Global flags / state
unsigned long now = 0UL, last_refresh = 0UL, start_time = 0UL, last_update = 0UL;
unsigned long got_samples = 0;

// Basic filters
TimeAwareSpikeFilter spikeFilter(ACCEL_SPIKE_FILTER_SIZE, ACCEL_SPIKE_FILTER_THRESHOLD);

// Sliding min/max for wave height estimation
MinMaxLemire min_max_h;

// Wave direction (Kalman)
#define WRONG_ANGLE_MARKER -360.0f
AngleAverager angle_averager(0.004f);
float wave_angle_deg = WRONG_ANGLE_MARKER;
AngleEstimate wave_angle_estimate;

const char* imu_name = "unknown";

bool produce_serial_data = true;
bool report_nmea = false;

float t = 0.0f;
float heave_avg = 0.0f;

// Unified fusion wrapper: SeaStateFusion (MEKF + tuner + freq tracker + KalmanWaveDirection)
// Underlying filter is SeaStateFusionFilter (same as desktop runner)
using Fusion = SeaStateFusion<TrackerType::KALMANF>;
Fusion fusion;                      // wrapper (handles updates + mag gating, etc.)
auto& fusion_filter = fusion.raw(); // underlying SeaStateFusionFilter
bool fusion_initialized = false;

// Main IMU processing
void read_and_processIMU_data() {
  auto data = M5.Imu.getImuData();

  float tempC = NAN;
  M5.Imu.getTemp(&tempC);

  now = micros();
  got_samples++;

  m5::imu_3d_t accel = data.accel;
  m5::imu_3d_t gyro  = data.gyro;
  m5::imu_3d_t mag   = data.mag;

  drawCalibrGraph(rect_graph_area, data);

  float delta_t = (now - last_update) / 1000000.0f;  // sec
  delta_t = clamp_val(delta_t, 0.001f, 0.1f);
  last_update = now;

  // Map M5 IMU to BODY NED, convert accel to m/s^2, gyro to rad/s (M5Stack AtomS3R with BMI270 screen face up)
  Eigen::Vector3f acc_meas_ned(  
       accel.y * g_std,
       accel.x * g_std,
      -accel.z * g_std
  );
  Eigen::Vector3f gyr_meas_ned(  
       gyro.y * DEG_TO_RAD,
       gyro.x * DEG_TO_RAD,
      -gyro.z * DEG_TO_RAD
  );
  Eigen::Vector3f mag_meas_ned(
       mag.y / 10.0f,
       mag.x / 10.0f,
      -mag.z / 10.0f
  );

  // First-time attitude init from accelerometer + mag
  if (!fusion_initialized) {
    fusion_filter.mekf().initialize_from_acc_mag(acc_meas_ned, mag_meas_ned);
    fusion_initialized = true;
  }

  // One fusion step: MEKF time update + accel update + tracker + tuner + dir
  // (through SeaStateFusion wrapper, as in desktop runner)
  fusion.update(delta_t, gyr_meas_ned, acc_meas_ned, tempC);

  // Magnetometer update with explicit ODR (MAG_ODR_HZ) like the desktop runner
  mag_phase_s += delta_t;
  bool mag_tick = false;
  if (mag_phase_s >= MAG_DT) {
    while (mag_phase_s >= MAG_DT) {
      mag_phase_s -= MAG_DT;
    }
    mag_tick = true;
  }
  if (mag_tick) {
    fusion.updateMag(mag_meas_ned);
  }

  // Attitude (nautical, degrees)
  Eigen::Vector3f eul_deg = fusion_filter.getEulerNautical();  // roll, pitch, yaw [deg]
  float roll  = eul_deg.x();
  float pitch = eul_deg.y();
  float yaw   = eul_deg.z();

  // Heave and vertical acceleration from MEKF state (world NED)
  Eigen::Vector3f disp_ned       = fusion_filter.mekf().get_position();
  Eigen::Vector3f vel_ned        = fusion_filter.mekf().get_velocity();
  Eigen::Vector3f acc_world_ned  = fusion_filter.mekf().get_world_accel(); // inertial, g removed

  // NED -> Z-up for vertical components: z_ned is down, so heave is -z
  float heave     = -disp_ned.z();      // m, up
  float heave_vel = -vel_ned.z();       // m/s, up
  float heave_acc = -acc_world_ned.z(); // m/s^2, up

  (void)heave_vel;  // not used in NMEA, but available

  // Vertical inertial accel in g (for spike filter and compatibility)
  float a_noisy = heave_acc / g_std;       // in g
  float a_band_passed = a_noisy;           // add band-pass here if desired
  float a_no_spikes = spikeFilter.filterWithDelta(a_band_passed, delta_t);
  a_no_spikes = clamp_val(a_no_spikes, -ACCEL_CLAMP, ACCEL_CLAMP);
  float a = a_no_spikes;
  (void)a; // currently unused, but kept for future diagnostics

  // Wave frequency from fusion filter (already smoothed inside)
  double freq_adj = fusion_filter.getFreqHz();
  double freq     = freq_adj;

  if (!(freq_adj > 0.0 && isfinite(freq_adj))) {
    // Tracker/tuner still warming up or data is bad; fall back to FREQ_GUESS
    freq_adj = FREQ_GUESS;
    freq     = FREQ_GUESS;
  }

  // Period
  double period = (freq_adj > 0.0) ? (1.0 / freq_adj) : 0.0;

  // Sliding min/max for wave height from MEKF heave
  uint32_t windowMicros = getWindowMicros(period);
  SampleType sample = { .value = heave, .timeMicroSec = now };
  min_max_lemire_update(&min_max_h, sample, windowMicros);

  float wave_height = min_max_h.max.value - min_max_h.min.value;
  heave_avg = 0.5f * (min_max_h.max.value + min_max_h.min.value);

  // Wave direction from built-in KalmanWaveDirection in fusion_filter
  const auto& dir_filter = fusion_filter.dir();

  // Direction in [0, 180) degrees (wave propagation axis)
  float wave_deg = dir_filter.getDirectionDegrees();

  // Optional extra smoothing using AngleAverager
  wave_angle_estimate = angle_averager.average180(wave_deg);
  wave_angle_deg = wave_angle_estimate.angle;

  // NMEA / Serial output
  const int serial_report_period_micros = 125000;
  if (now - last_refresh >= (produce_serial_data ? serial_report_period_micros : 1000000)) {
    if (produce_serial_data) {
      if (report_nmea) {
        // do not report data for which filters clearly didn't converge
        if (wave_height < 30.0f) {
          gen_nmea0183_xdr("$BBXDR,D,%.5f,M,DRG1", wave_height);
        }
        if (fabsf(heave) < 15.0f) {
          // DRT1: heave (main heave estimate)
          gen_nmea0183_xdr("$BBXDR,D,%.5f,M,DRT1", heave);
        }
        gen_nmea0183_xdr("$BBXDR,D,%.5f,M,DAV1", heave_avg);

        // Gating for FAV1 and DRT2 (freq vs freq_adj).
        // Here freq and freq_adj are the same smoothed value,
        // so the |freq - freq_adj| test always passes when freq_adj > 0.
        if (fabs(freq - freq_adj) < FREQ_COEF * freq_adj) {
          gen_nmea0183_xdr("$BBXDR,F,%.5f,H,FAV1", freq_adj);
        }

        // Raw tracker frequency FRT1 only when within valid band
        if (freq >= FREQ_LOWER && freq <= FREQ_UPPER) {
          gen_nmea0183_xdr("$BBXDR,F,%.5f,H,FRT1", freq);
        }

        // Sample rate
        gen_nmea0183_xdr("$BBXDR,F,%.5f,H,SRT1", got_samples / ((now - last_refresh) / 1000000.0f));

        // Accel bias estimate: use MEKF Z-bias (convert to % g)
        Eigen::Vector3f acc_bias_est = fusion_filter.mekf().get_acc_bias();
        gen_nmea0183_xdr("$BBXDR,N,%.5f,P,ABI1", acc_bias_est.z() * 100.0f / g_std);

        gen_nmea0183_xdr("$BBXDR,G,%.5f,,AP_WAVE_PERIOD", period);
        gen_nmea0183_xdr("$BBXDR,A,%.1f,D,AP_WAVE_ANGLE", wave_angle_deg);

        // Uses discrete wave_dir
        gen_nmea0183_xdr("$BBXDR,G,%1d,,AP_WAVE_DIR", (int) 0 ); // TODO:
      } else {
        // report for Arduino Serial Plotter
        Serial.printf(",delta_t:%.6f", delta_t);
        Serial.printf(",heave_alt_cm:%.4f", heave * 100.0f);
        Serial.printf(",tau:%.4f", fusion_filter.getTauApplied());
        Serial.printf(",R_S:%.4f", fusion_filter.getRSApplied());
        Serial.printf(",sigma:%.6f", fusion_filter.getSigmaApplied());        
        Serial.printf(",fakeHs:%.6f", fusion_filter.getDisplacementScale());
        Serial.printf(",accel_vert:%.6f", fusion_filter.getAccelVertical());
        //Serial.printf(",amp_accel:%.6f", g_std * sqrtf(accel.x*accel.x + accel.y*accel.y + accel.z*accel.z));
        //Serial.printf(",accel.x:%.6f", accel.x);
        //Serial.printf(",accel.y:%.6f", accel.y);
        //Serial.printf(",accel.z:%.6f", accel.z);
        //Serial.printf(",gyro.x:%.6f", gyro.x);
        //Serial.printf(",gyro.y:%.6f", gyro.y);
        //Serial.printf(",gyro.z:%.6f", gyro.z);
        Serial.printf(",roll_deg:%.2f",  roll);
        Serial.printf(",pitch_deg:%.2f", pitch);
        Serial.printf(",yaw_deg:%.2f",   yaw);
        //Serial.printf(",freqRaw:%.3f",     fusion_filter.getFreqRawHz());
        //Serial.printf(",freq:%.3f",        freq);
        //Serial.printf(",accel.z:%.3f",   accel.z);        
        //Serial.printf(",ap_wave_dir_P:%.2f", wave_dir_detector.getFilteredP());
        Serial.println();
      }
    }
    last_refresh = now;
    got_samples = 0;
  }
  t = (now - start_time) / 1000000.0f;  // time since start sec
}

// Main loop
void repeatMe() {
  bool pressed = M5.BtnA.wasPressed();
  // Calibration is initiated when screen is clicked. Screen on atomS3 is a button.
  if (pressed) {
    startCalibration();
  } else {
    auto imu_update = M5.Imu.update();
    if (imu_update) {
      read_and_processIMU_data();
    }
  }
  makeCalibrStep();
}

// setup / loop
void setup(void) {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);

  auto imu_type = M5.Imu.getType();
  switch (imu_type) {
    case m5::imu_none:        imu_name = "not found";   break;
    case m5::imu_sh200q:      imu_name = "sh200q";      break;
    case m5::imu_mpu6050:     imu_name = "mpu6050";     break;
    case m5::imu_mpu6886:     imu_name = "mpu6886";     break;
    case m5::imu_mpu9250:     imu_name = "mpu9250";     break;
    case m5::imu_bmi270:      imu_name = "bmi270";      break;
    default:                  imu_name = "unknown";     break;
  };
  disp.fillRect(0, 0, rect_text_area.w, rect_text_area.h, TFT_BLACK);

  if (imu_type == m5::imu_none) {
    for (;;) {
      delay(1);
    }
  }

  initCalibrDisplay();

  // Read calibration values from NVS.
  if (!M5.Imu.loadOffsetFromNVS()) {
    // startCalibration();   // uncomment for auto-calibration on boot
  }
  M5.Imu.setCalibration(0, 0, 64); // keep mag auto calibrate

  // BMI270-like noise (per-axis), “normal mode” order
  // White noise (per-sample RMS, per axis)
  const float acc_sigma = 1.51e-3f * g_std;  // 1.51 mg-rms -> ~0.0148 m/s^2
  const float gyr_sigma = 0.00157f;         // 0.09 dps-rms -> ~0.00157 rad/s

  // BMM150-like magnetometer behavior (AtomS3R)
  // MAG_ODR_HZ, MAG_DT, mag_phase_s are globals (shared with update loop)
  const float mag_sigma_uT = (MAG_ODR_HZ <= 20.0f) ? 0.30f : 0.60f;  // datasheet RMS noise

  // Initialize unified fusion wrapper (SeaStateFusion) like desktop runner
  {
    const Vector3f sigma_a_init(2.0f * acc_sigma, 2.0f * acc_sigma, 2.0f * acc_sigma);
    const Vector3f sigma_g(2.0f * gyr_sigma, 2.0f * gyr_sigma, 2.0f * gyr_sigma);    
    const float sigma_m_uT = 1.2f * mag_sigma_uT;   // a bit conservative
    const Vector3f sigma_m(sigma_m_uT, sigma_m_uT, sigma_m_uT);

    Fusion::Config fcfg;
    fcfg.with_mag = true;               // M5AtomS3R has magnetometer
    fcfg.sigma_a  = sigma_a_init;
    fcfg.sigma_g  = sigma_g;
    fcfg.sigma_m  = sigma_m;

    // mag ref / warmup policy (mirroring desktop runner’s pattern)
    fcfg.mag_delay_sec              = 5.0f;   // wait a few seconds before using mag
    fcfg.use_fixed_mag_world_ref    = false;  // learn mag world ref online
    fcfg.freeze_acc_bias_until_live = true;
    fcfg.Racc_warmup                = 0.5f;

    fusion.begin(fcfg);

 /*
    auto &mekf = fusion_filter.mekf();
    //fusion_filter.enableLinearBlock(false);

    // Start with a *looser* prior on accel bias
    // 0.3 m/s² ≈ 3% of g  → we admit we don't know bias very well
    mekf.set_initial_acc_bias_std(0.03f);
  
    // Start bias at 0 (M5 calibration should already remove most)
    mekf.set_initial_acc_bias(Eigen::Vector3f::Zero());
  
    // Let bias *wander* more: random-walk σ per sqrt(second)
    // 0.003–0.005 m/s²/√s; tune by looking at heave drift.
    mekf.set_Q_bacc_rw(Eigen::Vector3f::Constant(4e-3f));
  
    // Temperature model
    // Rough magnitude from datasheet, sign guessed as positive
    Eigen::Vector3f k_a(0.0075f, 0.0075f, 0.0075f);  // m/s^2 per °C
    mekf.set_accel_bias_temp_coeff(k_a);
  
    // OU parameters: moderate correlation & variance
    const float tau_init   = 0.15f;    // seconds
    const float sigma_init = 0.25f;    // m/s^2 (typical vertical sea accel)
    mekf.set_aw_time_constant(tau_init);
    mekf.set_aw_stationary_std(Eigen::Vector3f::Constant(sigma_init));

    // Strong integral pseudo-measure on S to clamp low-f drift
    // This is *std* of S pseudo-meas; smaller = stronger drift suppression.
    // Start pretty aggressive.
    Eigen::Vector3f RS_std(0.25f, 0.25f, 0.25f);  // units: m·s
    mekf.set_RS_noise(RS_std);

    // Enable/disable online τ / σₐ / Rₛ adaptation
    fusion_filter.enableTuner(true);
    fusion_filter.enableClamp(true);
    fusion_filter.enableHeaveRSGating(false);
    fusion_filter.enableExtraDriftCorrection(false);

    // SeaStateFusionFilter runtime tuning knobs
    fusion_filter.setRSXYFactor(0.07f);
    fusion_filter.setSFactor(1.3f);
    fusion_filter.setSigmaCoeff(0.35f); // tame sigma inflated by IMU noise and estimation from body frame to scale OU sigma to the sea state scale
    fusion_filter.setTauCoeff(1.5f);
    fusion_filter.setRSCoeff(1.8f);
    fusion_filter.setAccNoiseFloorSigma(0.05f);
    fusion_filter.setFreqBounds(0.05f, 8.0f);
    fusion_filter.setTauBounds(0.02f, 2.0f); // let R_S adapt a bit faster
    fusion_filter.setMaxSigmaA(3.0f);
    fusion_filter.setRSBounds(0.2f, 10.0f); // do not let R_S grow too much
    fusion_filter.setAdaptationTimeConstants(2.5f, 7.0f);
    fusion_filter.setAdaptationUpdatePeriod(0.1f);
    fusion_filter.setOnlineTuneWarmupSec(5.0f);
    fusion_filter.setMagDelaySec(3.0f);
    fusion_filter.setExtraDriftGain(1.0f); // trust in extra drift measure based on first order wave approximation with frequency (higher value reduces trust)
*/

    fusion_initialized = false;
  }
  delay(3000);
  start_time = micros();
  last_update = start_time;
}

void loop(void) {
  unsigned long start = micros();
  M5.update();
  repeatMe();
  long duration = micros() - start;
  long delay_micros = 10000 - duration;
  if (delay_micros > 0) {
    delayMicroseconds(delay_micros);
  }
}
