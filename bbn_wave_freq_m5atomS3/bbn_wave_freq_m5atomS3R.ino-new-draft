/*
  Copyright 2026, Mikhail Grushinskiy

  AtomS3R Tilt-Compensated Compass (+ optional IMU Calibration Wizard)
  (SeaStateFusion version: Kalman3D_Wave + mag init + yaw correction)

  IMPORTANT knobs you may need to set once:

    1) Quaternion direction from fusion mekf:
       If your fusion quaternion accessor returns body->world, set to 1.
       If it returns world->body, set to 0.
*/
#include <Arduino.h>

#ifndef COMPASS_ENABLE_WIZARD
  #define COMPASS_ENABLE_WIZARD 0
#endif

// Quaternion direction: 1 => q rotates BODY->WORLD, 0 => q rotates WORLD->BODY
#ifndef COMPASS_QUAT_BODY_TO_WORLD
  #define COMPASS_QUAT_BODY_TO_WORLD 1
#endif

#include <M5Unified.h>
#include <cmath>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
  #define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif
#include <ArduinoEigenDense.h>

#include "AtomS3R_ImuCal.h"
#include "AtomS3R_M5Ui.h"
#if COMPASS_ENABLE_WIZARD
  #include "AtomS3R_ImuCalWizard.h"
#endif
#include "AtomS3R_CompassUI.h"
#include "NmeaCompass.h"

#ifndef COMPASS_UI_DEFAULT_GRAPHICS
  #define COMPASS_UI_DEFAULT_GRAPHICS 1
#endif

#ifndef COMPASS_SERIAL_NMEA
  #define COMPASS_SERIAL_NMEA 1
#endif

#ifndef COMPASS_NMEA_TALKER
  #define COMPASS_NMEA_TALKER "II"
#endif

// SeaStateFusion requirements
constexpr float g_std      = atoms3r_ical::ImuCalCfg::g_std;
constexpr float FREQ_GUESS = 0.3f;

#define ZERO_CROSSINGS_SCALE          1.0f
#define ZERO_CROSSINGS_DEBOUNCE_TIME  0.12f
#define ZERO_CROSSINGS_STEEPNESS_TIME 0.21f

enum class TrackerType { ARANOVSKIY = 0, KALMANF = 1, ZEROCROSS = 2 };

#include "SeaStateFusionFilter.h"

// App constants
static constexpr float    LOOP_HZ        = 240.0f;
static constexpr uint32_t LOOP_PERIOD_US = (uint32_t)(1000000.0f / LOOP_HZ);

// Mag pacing only (don’t “delta-gate” here; your fusion wrapper already gates internally)
static constexpr uint32_t MAG_SAMPLE_SPACING_MS = 12;

// Display / serial rates
static constexpr uint32_t UI_REFRESH_MS   = 100;
static constexpr uint32_t DEBUG_SERIAL_MS = 200;
static constexpr uint32_t NMEA_SERIAL_MS  = 100;

// ROT bias removal (stillness-gated gyro bias estimator)
static constexpr float ROT_BIAS_TAU_S       = 20.0f;
static constexpr float ROT_STILL_G_TOL_FRAC = 0.12f;
static constexpr float ROT_STILL_GYRO_RAD_S = 0.15f;

using namespace atoms3r_ical;
using Vector3f = Eigen::Vector3f;

// -------------------- small helpers --------------------
static inline float clampf_(float x, float lo, float hi) { return x < lo ? lo : (x > hi ? hi : x); }

static inline float wrap360_(float deg) {
  while (deg < 0.0f) deg += 360.0f;
  while (deg >= 360.0f) deg -= 360.0f;
  return deg;
}

static inline float wrap180_(float deg) {
  while (deg <= -180.0f) deg += 360.0f;
  while (deg >   180.0f) deg -= 360.0f;
  return deg;
}

static inline Vector3f quatRotate_(const Eigen::Quaternionf& q, const Vector3f& v) {
  // Applies q * v * q_conj (q maps "from" -> "to")
  const Vector3f qv(q.x(), q.y(), q.z());
  const Vector3f t = 2.0f * qv.cross(v);
  return v + q.w() * t + qv.cross(t);
}

// UI semantics (EDIT ONLY THESE TWO VECTORS IF NEEDED):
// - FWD_B: unit vector in BODY pointing "USB down the screen"
// - RGT_B: unit vector in BODY pointing "screen right"
//
// Start with BODY axes assuming x=USB-down, y=screen-right, z=screen-out (or down).
// If pitch/roll are swapped or inverted, change these vectors (or flip signs).
static inline void uiRollPitchFromDownBody_(
    const Vector3f& down_b_unit,
    float& roll_deg_out,
    float& pitch_deg_out)
{
  const Vector3f FWD_B( 1.0f, 0.0f, 0.0f); // USB direction (down the screen)
  const Vector3f RGT_B( 0.0f, 1.0f, 0.0f); // screen right

  Vector3f f = FWD_B.normalized();
  Vector3f r = RGT_B.normalized();
  Vector3f d = f.cross(r);                 // UI “screen normal” (right-hand)
  if (d.squaredNorm() < 1e-6f) { roll_deg_out = 0.0f; pitch_deg_out = 0.0f; return; }
  d.normalize();

  // Components of world-down in the UI frame
  const float df = down_b_unit.dot(f);
  const float dr = down_b_unit.dot(r);
  const float dd = down_b_unit.dot(d);

  // Roll: tilt left/right (right side down => +)
  const float roll  = atan2f(dr, dd);

  // Pitch: USB end up/down
  const float pitch = atan2f(df, sqrtf(dr*dr + dd*dd));

  roll_deg_out  = wrap180_(roll  * RAD_TO_DEG);
  pitch_deg_out = wrap180_(pitch * RAD_TO_DEG);
}

// Compute tilt-compensated heading using only DOWN (from accel) + MAG (in body).
// Heading is clockwise from North (0..360). Assumes BODY fwd axis is +X for heading reference.
// If your “forward” isn’t +X, change FWD_B below.
static inline bool headingFromDownAndMag_(
    const Vector3f& down_b_unit,
    const Vector3f& mag_b_uT,
    float& heading_deg_out)
{
  if (down_b_unit.squaredNorm() < 1e-6f) return false;
  if (mag_b_uT.squaredNorm()   < 1e-6f) return false;

  Vector3f d = down_b_unit.normalized();
  Vector3f m = mag_b_uT.normalized();

  // East in BODY: e = d x m
  Vector3f e = d.cross(m);
  if (e.squaredNorm() < 1e-6f) return false;
  e.normalize();

  // North in BODY: n = e x d
  Vector3f n = e.cross(d);
  if (n.squaredNorm() < 1e-6f) return false;
  n.normalize();

  // Heading reference axis in BODY (forward)
  const Vector3f FWD_B(1.0f, 0.0f, 0.0f);

  const float E = FWD_B.dot(e);
  const float N = FWD_B.dot(n);

  const float hdg = atan2f(E, N) * RAD_TO_DEG;
  heading_deg_out = wrap360_(hdg);
  return true;
}

// -------------------- App --------------------
class FusionApp {
public:
  FusionApp()
#if COMPASS_ENABLE_WIZARD
    : wizard_(ui_, store_)
#endif
  {}

  void begin() {
    Serial.begin(115200);
    delay(150);
    Serial.println();
    Serial.printf("[BOOT] AtomS3R Compass (SeaStateFusion) wizard=%d\n", (int)COMPASS_ENABLE_WIZARD);
    Serial.printf("[BOOT] quat body->world = %d\n", (int)COMPASS_QUAT_BODY_TO_WORLD);

    auto cfg = M5.config();
    M5.begin(cfg);

    // Critical: clear M5Unified’s own cal/offsets so it can’t stack with ours.
    clearM5UnifiedImuCalibration();
    delay(250);

    ui_.begin();

    if (use_graphics_) {
      ui_.setReadRotation();
      compass_ui_.begin();
      compass_ui_ready_ = compass_ui_.ok();
      if (!compass_ui_ready_) use_graphics_ = false;
    }

    if (!M5.Imu.isEnabled()) {
      Serial.println("[BOOT] IMU not found / not enabled");
      ui_.fail("IMU", "Not found");
      while (true) delay(100);
    }

    reloadBlobAndRuntime_();

#if COMPASS_ENABLE_WIZARD
    if (!have_blob_) {
      Serial.println("[BOOT] No saved calibration. Starting wizard...");
      ImuCalBlobV1 saved{};
      if (wizard_.runAndSave(saved)) {
        Serial.println("[BOOT] Wizard saved calibration. Loaded:");
        printBlobSummary(Serial, saved);
        printBlobDetail(Serial, saved);
        blob_ = saved;
        have_blob_ = true;
        runtime_.rebuildFromBlob(blob_);
      } else {
        Serial.println("[BOOT] Wizard did not save calibration. Running with raw values.");
      }
    } else {
      Serial.println("[BOOT] Found saved calibration:");
      printBlobSummary(Serial, blob_);
      printBlobDetail(Serial, blob_);
    }
#else
    if (!have_blob_) Serial.println("[BOOT] No saved calibration. Wizard disabled.");
    else             Serial.println("[BOOT] Found saved calibration.");
#endif

    resetFusion_();
    drawHomeStatic_();

    start_us_       = micros();
    next_tick_us_   = micros();
    last_update_us_ = micros();
  }

  void tick() {
    // pace loop ~240 Hz
    const uint32_t now_us = micros();
    int32_t wait_us = (int32_t)(next_tick_us_ - now_us);
    if (wait_us > 0) {
      if (wait_us > 200) delayMicroseconds(200);
      else delayMicroseconds((uint32_t)wait_us);
    }
    next_tick_us_ += LOOP_PERIOD_US;

#if COMPASS_ENABLE_WIZARD
    Input::update();

    if (Input::tapPressed()) {
      tap_count_++;
      tap_deadline_ms_ = millis() + M5UiCfg::MENU_TAP_WINDOW_MS;
      drawHomePending_();
      Serial.printf("[TAP] count=%d\n", tap_count_);
    }

    if (tap_count_ > 0 && (int32_t)(millis() - tap_deadline_ms_) > 0) {
      if (tap_count_ >= 3) handleErase_();
      else                 handleRunWizard_();
      tap_count_ = 0;
      tap_deadline_ms_ = 0;
      drawHomeStatic_();
    }
#endif

    ImuSample s;
    if (readImuMapped(M5.Imu, s)) {
      updateFilter_(s);
    }

    updateUI_();
    streamSerial_();
  }

private:
  // UI mode
  bool use_graphics_ = (COMPASS_UI_DEFAULT_GRAPHICS != 0);
  CompassUI compass_ui_{};
  bool compass_ui_ready_ = false;

  // ROT estimator + stillness-gated gyro bias removal
  bool     rot_inited_    = false;
  float    rot_dpm_filt_  = 0.0f;
  bool     gyro_bias_ok_  = false;
  Vector3f gyro_bias_ema_ = Vector3f::Zero();   // rad/s (BODY)

  // Plumbing
  using UI = atoms3r_ical::M5Ui;
  UI ui_{};
  ImuCalStoreNvs store_{};

#if COMPASS_ENABLE_WIZARD
  ImuCalWizard wizard_;
  int tap_count_ = 0;
  uint32_t tap_deadline_ms_ = 0;
#endif

  bool have_blob_ = false;
  ImuCalBlobV1 blob_{};
  RuntimeCals runtime_{};

  // Timing
  uint32_t start_us_ = 0;
  uint32_t next_tick_us_ = 0;
  uint32_t last_update_us_ = 0;
  uint32_t last_ui_ms_ = 0;
  uint32_t last_serial_ms_ = 0;

  // SeaStateFusion
  using Fusion = SeaStateFusion<TrackerType::KALMANF>;
  Fusion fusion_{};

  // Latest calibrated values
  Vector3f a_cal_ = Vector3f::Zero();   // specific force (m/s^2) in BODY
  Vector3f w_cal_ = Vector3f::Zero();   // rad/s in BODY
  Vector3f m_cal_ = Vector3f::Zero();   // uT in BODY
  float    a_raw_norm_ = 0.0f;

  // Display state
  float roll_deg_ = 0.0f;
  float pitch_deg_ = 0.0f;
  float heading_deg_ = 0.0f;

  // Mag gating
  bool mag_ok_ = false;
  bool mag_fresh_ = false;
  float mag_norm_uT_ = 0.0f;
  uint32_t last_mag_ms_ = 0;

private:
  void reloadBlobAndRuntime_() {
    have_blob_ = store_.load(blob_);
    if (!have_blob_) memset(&blob_, 0, sizeof(blob_));
    runtime_.rebuildFromBlob(blob_);
  }

  void resetFusion_() {
    constexpr bool WANT_LINEAR_BLOCK = true;
    const float g = ImuCalCfg::g_std;

    Vector3f sigma_a(0.06f * g, 0.06f * g, 0.06f * g);
    Vector3f sigma_g(0.0030f,   0.0030f,   0.0030f);
    Vector3f sigma_m(0.60f,     0.60f,     0.60f);

    Fusion::Config fcfg;
    fcfg.with_mag = true;
    fcfg.sigma_a  = sigma_a;
    fcfg.sigma_g  = sigma_g;
    fcfg.sigma_m  = sigma_m;

    fcfg.mag_delay_sec              = 5.0f;
    fcfg.use_fixed_mag_world_ref    = false;
    fcfg.freeze_acc_bias_until_live = true;
    fcfg.Racc_warmup                = 0.5f;

    fcfg.mag_ref_timeout_sec = 1.5f;
    fcfg.mag_odr_guess_hz    = 80.0f;

    fusion_.begin(fcfg);

    auto& ff = fusion_.raw();
    ff.enableLinearBlock(WANT_LINEAR_BLOCK);
    ff.enableTuner(true);
    ff.enableClamp(true);
    ff.setFreqInputCutoffHz(6.0f);

    last_mag_ms_ = 0;

    rot_inited_ = false;
    rot_dpm_filt_ = 0.0f;
    gyro_bias_ok_ = false;
    gyro_bias_ema_.setZero();
  }

#if COMPASS_ENABLE_WIZARD
  void handleErase_() {
    Serial.println("[HOME] ERASE");
    if (!ui_.eraseConfirm()) {
      Serial.println("[HOME] erase cancelled");
      return;
    }
    store_.erase();
    clearM5UnifiedImuCalibration();
    reloadBlobAndRuntime_();
    resetFusion_();
  }

  void handleRunWizard_() {
    Serial.println("[HOME] RUN WIZARD");
    ImuCalBlobV1 saved{};
    if (!wizard_.runAndSave(saved)) {
      ui_.notSavedNotice();
      return;
    }
    blob_ = saved;
    have_blob_ = true;
    runtime_.rebuildFromBlob(blob_);
    resetFusion_();
  }

  void drawHomePending_() {
    ui_.setReadRotation();
    ui_.title("COMPASS");
    M5.Display.printf("Tap count: %d\n", tap_count_);
    ui_.line("");
    ui_.line("Wait...");
    ui_.line("1 tap=CAL");
    ui_.line("3 taps=ERASE");

    int32_t remain = (int32_t)(tap_deadline_ms_ - millis());
    remain = remain < 0 ? 0 : remain;
    float t01 = 1.0f - (float)remain / (float)M5UiCfg::MENU_TAP_WINDOW_MS;
    ui_.bar01(t01);
  }
#endif

  void updateFilter_(const ImuSample& s) {
    a_raw_norm_ = s.a.norm();

    // Apply your runtime calibration
    a_cal_ = runtime_.applyAccel(s.a, s.tempC);
    w_cal_ = runtime_.applyGyro (s.w, s.tempC);
    m_cal_ = runtime_.applyMag  (s.m);

    // dt
    const uint32_t now_us = micros();
    float dt = (now_us - last_update_us_) * 1e-6f;
    last_update_us_ = now_us;
    dt = clampf_(dt, 0.0010f, 0.0200f);

    // Stillness (for gyro bias learning only)
    const float g = ImuCalCfg::g_std;
    const float a_err = fabsf(a_cal_.norm() - g);
    const bool still = (a_err < ROT_STILL_G_TOL_FRAC * g) && (w_cal_.norm() < ROT_STILL_GYRO_RAD_S);

    // Mag sanity
    mag_norm_uT_ = m_cal_.norm();
    mag_ok_ = (mag_norm_uT_ > 5.0f && mag_norm_uT_ < 200.0f);

    // Mag pacing (time only)
    const uint32_t now_ms = millis();
    mag_fresh_ = false;
    if (mag_ok_ && (uint32_t)(now_ms - last_mag_ms_) >= MAG_SAMPLE_SPACING_MS) {
      last_mag_ms_ = now_ms;
      mag_fresh_ = true;
      fusion_.updateMag(m_cal_);            // wrapper decides whether to use it / init ref etc.
    }

    // Main fusion update (prop + accel update inside wrapper)
    fusion_.update(dt, w_cal_, a_cal_);

    // --- UI roll/pitch & heading from ACC+MAG (independent of quaternion direction) ---
    // At rest, accel measures specific force ~ -g_world expressed in BODY.
    // So BODY "down" direction ~= -a_unit.
    Vector3f down_b = Vector3f::Zero();
    {
      Vector3f a = a_cal_;
      const float an = a.norm();
      if (an > 1e-6f) {
        a /= an;
        down_b = -a;                 // world-down in BODY
        down_b.normalize();
      }
    }

    if (down_b.squaredNorm() > 1e-6f) {
      uiRollPitchFromDownBody_(down_b, roll_deg_, pitch_deg_);
    }

    // Heading from down+mag (tilt compensated)
    // If mag bad or geometry degenerate, keep last heading.
    if (mag_ok_ && down_b.squaredNorm() > 1e-6f) {
      float hdg;
      if (headingFromDownAndMag_(down_b, m_cal_, hdg)) {
        heading_deg_ = hdg;
      }
    }

    // --- ROT using fusion quaternion (explicit direction switch, NO autodetect) ---
    // gyro bias estimator (stillness-gated)
    if (still) {
      const float alpha_b = 1.0f - expf(-dt / ROT_BIAS_TAU_S);
      if (!gyro_bias_ok_) {
        gyro_bias_ok_  = true;
        gyro_bias_ema_ = w_cal_;
      } else {
        gyro_bias_ema_ += alpha_b * (w_cal_ - gyro_bias_ema_);
      }
    }

    Vector3f w_use = w_cal_;
    if (gyro_bias_ok_) w_use -= gyro_bias_ema_;

    Eigen::Quaternionf q = fusion_.raw().mekf().quaternion_boat();
    q.normalize();

    // body->world rotator
    auto rot_body_to_world = [&](const Vector3f& v_body) -> Vector3f {
      // If q is body->world: use q. If q is world->body: body->world is q.conjugate().
      #if COMPASS_QUAT_BODY_TO_WORLD
        return quatRotate_(q, v_body);
      #else
        return quatRotate_(q.conjugate(), v_body);
      #endif
    };

    Vector3f w_world = rot_body_to_world(w_use);

    // NED: +Z is down. ROT uses rate about world Z.
    float rot_dpm_meas = w_world.z() * RAD_TO_DEG * 60.0f;
    rot_dpm_meas = clampf_(rot_dpm_meas, -720.0f, 720.0f);

    const float tau_rot = 1.5f;
    const float alpha_r = 1.0f - expf(-dt / tau_rot);
    if (!rot_inited_) { rot_inited_ = true; rot_dpm_filt_ = rot_dpm_meas; }
    else              { rot_dpm_filt_ += alpha_r * (rot_dpm_meas - rot_dpm_filt_); }
  }

  void drawHomeStatic_() {
    ui_.setReadRotation();
    ui_.title("COMPASS");
    M5.Display.printf("BLOB: %s\n", have_blob_ ? "YES" : "NO");
    M5.Display.printf("A:%d G:%d M:%d\n",
                      (int)runtime_.acc.ok, (int)runtime_.gyr.ok, (int)runtime_.mag.ok);

#if COMPASS_ENABLE_WIZARD
    ui_.line("Tap: calibrate");
    ui_.line("Tap x3: erase");
#else
    ui_.line("Wizard: DISABLED");
    ui_.line("Set COMPASS_ENABLE_WIZARD=1");
#endif
    ui_.line("");
  }

  void updateUI_() {
#if COMPASS_ENABLE_WIZARD
    if (tap_count_ > 0) return;
#endif
    const uint32_t now_ms = millis();
    if (now_ms - last_ui_ms_ < UI_REFRESH_MS) return;
    last_ui_ms_ = now_ms;

    if (use_graphics_ && compass_ui_ready_) updateUI_graphics_();
    else                                   updateUI_text_();
  }

  void updateUI_graphics_() {
    ui_.setReadRotation();
    const bool tiltWarn = (fabsf(roll_deg_) > 35.0f) || (fabsf(pitch_deg_) > 35.0f);
    compass_ui_.draw(heading_deg_, mag_ok_, mag_norm_uT_, tiltWarn);
  }

  void updateUI_text_() {
    ui_.setReadRotation();
    ui_.title("COMPASS");
    M5.Display.printf("HDG: %6.1f deg\n", (double)heading_deg_);
    M5.Display.printf("ROL: %6.1f deg\n", (double)roll_deg_);
    M5.Display.printf("PIT: %6.1f deg\n", (double)pitch_deg_);
    M5.Display.printf("MAG: %s %s\n", mag_ok_ ? "OK " : "BAD", mag_fresh_ ? "NEW" : "OLD");
    M5.Display.printf("|m|: %6.1f uT\n", (double)mag_norm_uT_);
    M5.Display.printf("|aR|:%5.2f |aC|:%5.2f\n", (double)a_raw_norm_, (double)a_cal_.norm());
    ui_.line("");
  }

  void streamSerial_() {
    const uint32_t now_ms = millis();

#if COMPASS_SERIAL_NMEA
    if (now_ms - last_serial_ms_ < NMEA_SERIAL_MS) return;
#else
    if (now_ms - last_serial_ms_ < DEBUG_SERIAL_MS) return;
#endif
    last_serial_ms_ = now_ms;

#if COMPASS_SERIAL_NMEA
    const bool valid = fusion_.isLive();
    nmea_hdm(COMPASS_NMEA_TALKER, heading_deg_);
    nmea_xdr_pitch_roll(COMPASS_NMEA_TALKER, pitch_deg_, roll_deg_);
    nmea_rot(COMPASS_NMEA_TALKER, rot_dpm_filt_, valid);
#else
    const float t = (micros() - start_us_) * 1e-6f;
    Serial.printf("t=%.2f HDG:%6.1f R:%6.1f P:%6.1f |m|=%.1f live:%d quatB2W:%d\n",
                  (double)t,
                  (double)heading_deg_,
                  (double)roll_deg_,
                  (double)pitch_deg_,
                  (double)mag_norm_uT_,
                  (int)fusion_.isLive(),
                  (int)COMPASS_QUAT_BODY_TO_WORLD);
#endif
  }
};

static FusionApp g_app;

void setup() { g_app.begin(); }
void loop()  { g_app.tick(); }
