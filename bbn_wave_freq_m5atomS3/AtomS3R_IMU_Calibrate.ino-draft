/*
  AtomS3R IMU calibration wizard (Accel + Gyro + Mag) using imu_cal::* calibrators.

  Fixes:
  - Stack-canary crash during accelCal.fit(): run fit() in a dedicated FreeRTOS task with large stack.
  - UI: human prompts, short text, no “press while screen is down”.
  - Cable-safe 6-pose set (NO USB-down):
      1 Screen Up
      2 Screen Down
      3 Left Edge Down
      4 Right Edge Down
      5 Top Edge Down
      6 Bottom Edge Down
  - Pace control: Tap to start each pose; capture; BEEP; then Tap for next pose.
  - Save + immediate readback verify.

  Controls (AtomS3R: BtnA is the screen button):
  - Tap: start calibration / advance steps
  - Triple-tap on home: erase saved calibration (with confirm)

  REQUIREMENTS:
    - M5Unified
    - ESP32 Arduino core (Preferences)
    - ArduinoEigenDense
    - CalibrateIMU_alt.h

  Units:
    accel: m/s^2
    gyro:  rad/s
    mag:   uT
*/

#include <Arduino.h>
#include <M5Unified.h>
#include <Preferences.h>

#include <stdint.h>
#include <stddef.h>     // offsetof
#include <string.h>
#include <math.h>

#include <freertos/FreeRTOS.h>
#include <freertos/task.h>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
#define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif
#include <ArduinoEigenDense.h>

#include "CalibrateIMU_alt.h"

using Vector3f = Eigen::Matrix<float,3,1>;
using Matrix3f = Eigen::Matrix<float,3,3>;
using M5_IMU   = decltype(M5.Imu);

class ImuCalApp {
public:
  static void begin() {
    auto cfg = M5.config();
    M5.begin(cfg);
    Serial.begin(115200);

    // Default “reading” rotation (you can change 0/1/2/3 if you want)
    M5.Display.setRotation(ROT_READ);

    // Disable M5 internal calibration influence
    M5.Imu.setCalibration(0, 0, 0);

    if (!M5.Imu.isEnabled()) {
      ui_fail_("IMU", "Not found");
      while (true) delay(100);
    }

    have_blob_ = load_cal_from_nvs_();
    draw_home_();
  }

  static void tick() {
    M5.update();

    // tap counting (single = start, triple = erase)
    if (M5.BtnA.wasPressed()) {
      tap_count_++;
      tap_deadline_ms_ = millis() + TAP_WINDOW_MS;
    }

    if (tap_count_ > 0 && (int32_t)(millis() - tap_deadline_ms_) > 0) {
      if (tap_count_ >= 3) {
        if (erase_confirm_()) {
          erase_our_cal_from_nvs_();
          M5.Imu.clearOffsetData();
          have_blob_ = load_cal_from_nvs_();
          if (!have_blob_) {
            memset(&cal_blob_, 0, sizeof(cal_blob_));
            rebuild_runtime_cals_from_blob_();
          }
        }
        draw_home_();
      } else {
        (void)run_wizard_();
        have_blob_ = load_cal_from_nvs_();
        draw_home_();
      }
      tap_count_ = 0;
      tap_deadline_ms_ = 0;
    }

    stream_serial_();
    delay(5);
  }

private:
  // ----------------------------
  // Tuning knobs
  // ----------------------------
  static constexpr float g_std   = 9.80665f;
  static constexpr float DEG2RAD = 3.14159265358979323846f / 180.0f;

  // UI rotation:
  // ROT_READ = how you like it while holding/reading prompts.
  // pose rotations = used during capture so text is upright in that pose.
  static constexpr uint8_t ROT_READ = 1;

  static constexpr uint32_t PLACE_TIME_MS    = 9000;
  static constexpr uint32_t ACCEL_TIMEOUT_MS = 80000;
  static constexpr uint32_t GYRO_TIMEOUT_MS  = 50000;
  static constexpr uint32_t MAG_TIMEOUT_MS   = 140000;

  static constexpr uint32_t STUCK_MS         = 15000;

  static constexpr int ACCEL_NEED_POSE       = 60;
  static constexpr int GYRO_NEED             = 220;
  static constexpr int MAG_NEED              = 260;

  // Never call fit() unless we have enough accepted samples (avoids crashes in some implementations)
  static constexpr int ACCEL_MIN_TO_FIT      = 220;
  static constexpr int GYRO_MIN_TO_FIT       = 120;
  static constexpr int MAG_MIN_TO_FIT        = 120;

  // Fit tasks (big stack to avoid stack canary crash)
  static constexpr uint32_t FIT_STACK_WORDS  = 16384;   // FreeRTOS stack depth units (large on purpose)
  static constexpr uint32_t FIT_TIMEOUT_MS   = 25000;

  static constexpr uint32_t TAP_WINDOW_MS    = 650;

  // ----------------------------
  // Axis mapping (your pipeline)
  // ----------------------------
  static inline Vector3f map_acc_to_body_ned_(const m5::imu_3d_t& a_g_units) {
    return Vector3f(a_g_units.y * g_std, a_g_units.x * g_std, -a_g_units.z * g_std);
  }
  static inline Vector3f map_gyr_to_body_ned_(const m5::imu_3d_t& w_deg_s) {
    return Vector3f(w_deg_s.y * DEG2RAD, w_deg_s.x * DEG2RAD, -w_deg_s.z * DEG2RAD);
  }
  static inline Vector3f map_mag_to_body_uT_(const m5::imu_3d_t& m_raw) {
    return Vector3f(m_raw.y / 10.0f, m_raw.x / 10.0f, -m_raw.z / 10.0f);
  }

  // ----------------------------
  // NVS blob + CRC
  // ----------------------------
  static constexpr uint32_t IMU_CAL_MAGIC    = 0x434C554D; // 'MULC'
  static constexpr uint16_t IMU_CAL_VERSION  = 1;

  struct CalBlobV1 {
    uint32_t magic = IMU_CAL_MAGIC;
    uint16_t version = IMU_CAL_VERSION;
    uint16_t size_bytes = sizeof(CalBlobV1);

    uint8_t  accel_ok = 0;
    float    accel_g = g_std;
    float    accel_S[9];
    float    accel_T0 = 25.0f;
    float    accel_b0[3];
    float    accel_k[3];
    float    accel_rms_mag = 0.0f;

    uint8_t  gyro_ok = 0;
    float    gyro_T0 = 25.0f;
    float    gyro_b0[3];
    float    gyro_k[3];

    uint8_t  mag_ok = 0;
    float    mag_A[9];
    float    mag_b[3];
    float    mag_field_uT = 0.0f;
    float    mag_rms = 0.0f;

    uint32_t crc = 0;
  };
  static constexpr size_t CRC_LEN = offsetof(CalBlobV1, crc);

  static uint32_t crc32_ieee_(const uint8_t* data, size_t n) {
    uint32_t crc = 0xFFFFFFFFu;
    for (size_t i = 0; i < n; ++i) {
      crc ^= (uint32_t)data[i];
      for (int k = 0; k < 8; ++k) {
        uint32_t mask = -(crc & 1u);
        crc = (crc >> 1) ^ (0xEDB88320u & mask);
      }
    }
    return ~crc;
  }

  static Matrix3f mat_from_rowmajor9_(const float a[9]) {
    Matrix3f M;
    M << a[0], a[1], a[2],
         a[3], a[4], a[5],
         a[6], a[7], a[8];
    return M;
  }
  static void mat_to_rowmajor9_(const Matrix3f& M, float a[9]) {
    a[0]=M(0,0); a[1]=M(0,1); a[2]=M(0,2);
    a[3]=M(1,0); a[4]=M(1,1); a[5]=M(1,2);
    a[6]=M(2,0); a[7]=M(2,1); a[8]=M(2,2);
  }

  static void rebuild_runtime_cals_from_blob_() {
    g_acc_cal_.ok = (cal_blob_.accel_ok != 0);
    g_acc_cal_.g  = cal_blob_.accel_g;
    g_acc_cal_.S  = mat_from_rowmajor9_(cal_blob_.accel_S);
    g_acc_cal_.biasT.ok = g_acc_cal_.ok;
    g_acc_cal_.biasT.T0 = cal_blob_.accel_T0;
    g_acc_cal_.biasT.b0 = Vector3f(cal_blob_.accel_b0[0], cal_blob_.accel_b0[1], cal_blob_.accel_b0[2]);
    g_acc_cal_.biasT.k  = Vector3f(cal_blob_.accel_k[0],  cal_blob_.accel_k[1],  cal_blob_.accel_k[2]);
    g_acc_cal_.rms_mag  = cal_blob_.accel_rms_mag;

    g_gyr_cal_.ok = (cal_blob_.gyro_ok != 0);
    g_gyr_cal_.S  = Matrix3f::Identity();
    g_gyr_cal_.biasT.ok = g_gyr_cal_.ok;
    g_gyr_cal_.biasT.T0 = cal_blob_.gyro_T0;
    g_gyr_cal_.biasT.b0 = Vector3f(cal_blob_.gyro_b0[0], cal_blob_.gyro_b0[1], cal_blob_.gyro_b0[2]);
    g_gyr_cal_.biasT.k  = Vector3f(cal_blob_.gyro_k[0],  cal_blob_.gyro_k[1],  cal_blob_.gyro_k[2]);

    g_mag_cal_.ok = (cal_blob_.mag_ok != 0);
    g_mag_cal_.A  = mat_from_rowmajor9_(cal_blob_.mag_A);
    g_mag_cal_.b  = Vector3f(cal_blob_.mag_b[0], cal_blob_.mag_b[1], cal_blob_.mag_b[2]);
    g_mag_cal_.field_uT = cal_blob_.mag_field_uT;
    g_mag_cal_.rms      = cal_blob_.mag_rms;
  }

  static bool load_cal_from_nvs_() {
    prefs_.begin("imu_cal", true);
    size_t n = prefs_.getBytesLength("blob");
    if (n != sizeof(CalBlobV1)) { prefs_.end(); return false; }

    CalBlobV1 tmp;
    size_t got = prefs_.getBytes("blob", &tmp, sizeof(tmp));
    prefs_.end();
    if (got != sizeof(tmp)) return false;

    if (tmp.magic != IMU_CAL_MAGIC || tmp.version != IMU_CAL_VERSION || tmp.size_bytes != sizeof(CalBlobV1))
      return false;

    uint32_t want = tmp.crc;
    tmp.crc = 0;
    uint32_t have = crc32_ieee_((const uint8_t*)&tmp, CRC_LEN);
    if (have != want) return false;

    cal_blob_ = tmp;
    rebuild_runtime_cals_from_blob_();
    return true;
  }

  static bool save_cal_to_nvs_(const CalBlobV1& in_blob) {
    CalBlobV1 tmp = in_blob;
    tmp.magic = IMU_CAL_MAGIC;
    tmp.version = IMU_CAL_VERSION;
    tmp.size_bytes = sizeof(CalBlobV1);
    tmp.crc = 0;
    tmp.crc = crc32_ieee_((const uint8_t*)&tmp, CRC_LEN);

    prefs_.begin("imu_cal", false);
    size_t wrote = prefs_.putBytes("blob", &tmp, sizeof(tmp));
    prefs_.end();
    return (wrote == sizeof(tmp));
  }

  static void erase_our_cal_from_nvs_() {
    prefs_.begin("imu_cal", false);
    prefs_.remove("blob");
    prefs_.end();
  }

  // ----------------------------
  // UI helpers (short)
  // ----------------------------
  static void ui_clear_() {
    M5.Display.fillScreen(TFT_BLACK);
    M5.Display.setCursor(0,0);
  }
  static void ui_title_(const char* t) {
    ui_clear_();
    M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    M5.Display.setTextSize(2);
    M5.Display.println(t);
    M5.Display.setTextSize(1);
    M5.Display.println();
  }
  static void ui_line_(const char* s) {
    M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    M5.Display.println(s);
  }
  static void ui_bar_(float t01) {
    if (t01 < 0) t01 = 0;
    if (t01 > 1) t01 = 1;
    int x = 6;
    int w = M5.Display.width() - 12;
    int h = 10;
    int y = M5.Display.height() - 18;
    M5.Display.drawRect(x, y, w, h, TFT_DARKGREY);
    int fillw = (int)((w-2) * t01);
    M5.Display.fillRect(x+1, y+1, fillw, h-2, TFT_GREEN);
  }
  static void beep_ok_()  { M5.Speaker.tone(2200, 60); delay(80); M5.Speaker.tone(2600, 60); }
  static void beep_bad_() { M5.Speaker.tone(400, 120); delay(140); M5.Speaker.tone(300, 160); }

  static void ui_wait_tap_(const char* title, const char* l1, const char* l2=nullptr) {
    M5.Display.setRotation(ROT_READ);
    ui_title_(title);
    ui_line_(l1);
    if (l2) ui_line_(l2);
    ui_line_("");
    ui_line_("Tap to continue");
    while (true) { M5.update(); if (M5.BtnA.wasPressed()) break; delay(10); }
  }

  static void ui_fail_(const char* where, const char* why) {
    M5.Display.setRotation(ROT_READ);
    ui_title_("FAILED");
    ui_line_(where);
    ui_line_(why);
    ui_line_("");
    ui_line_("Tap to return");
    beep_bad_();
    while (true) { M5.update(); if (M5.BtnA.wasPressed()) break; delay(10); }
  }

  static bool erase_confirm_() {
    M5.Display.setRotation(ROT_READ);
    ui_title_("ERASE?");
    ui_line_("Delete saved cal");
    ui_line_("Tap = confirm");
    ui_line_("Wait = cancel");
    uint32_t t0 = millis();
    while (millis() - t0 < 4500) {
      M5.update();
      if (M5.BtnA.wasPressed()) return true;
      delay(10);
    }
    return false;
  }

  static void draw_home_() {
    M5.Display.setRotation(ROT_READ);
    ui_title_("IMU CAL");
    M5.Display.printf("BLOB: %s\n", have_blob_ ? "YES" : "NO");
    M5.Display.printf("A:%d  G:%d  M:%d\n", (int)g_acc_cal_.ok, (int)g_gyr_cal_.ok, (int)g_mag_cal_.ok);
    ui_line_("");
    ui_line_("Tap: calibrate");
    ui_line_("Tap x3: erase");
  }

  static void place_delay_(const char* title, const char* line, uint32_t ms) {
    ui_title_(title);
    ui_line_(line);
    ui_line_("Place it now");
    ui_line_("Don't touch");
    uint32_t t0 = millis();
    while (millis() - t0 < ms) {
      ui_bar_((float)(millis() - t0) / (float)ms);
      delay(30);
    }
  }

  static void done_and_wait_next_(const char* msg) {
    M5.Display.setRotation(ROT_READ);
    ui_title_("OK");
    ui_line_(msg);
    ui_line_("");
    ui_line_("Tap for next");
    beep_ok_();
    while (true) { M5.update(); if (M5.BtnA.wasPressed()) break; delay(10); }
  }

  // ----------------------------
  // Sensors
  // ----------------------------
  static bool read_sensors_(Vector3f& a, Vector3f& w, Vector3f& m, float& tempC, uint32_t& mask_out) {
    mask_out = M5.Imu.update();
    if (!mask_out) return false;
    auto data = M5.Imu.getImuData();
    tempC = NAN;
    M5.Imu.getTemp(&tempC);

    a = map_acc_to_body_ned_(data.accel);
    w = map_gyr_to_body_ned_(data.gyro);
    m = map_mag_to_body_uT_(data.mag);
    return true;
  }

  // ----------------------------
  // Capture steps (tap -> place -> capture -> beep -> tap next)
  // ----------------------------
  struct Pose {
    const char* name;
    const char* note;
    uint8_t rot_capture;
  };

  static bool capture_accel_pose_(const Pose& p) {
    ui_wait_tap_("ACCEL", p.name, p.note);
    place_delay_("ACCEL", p.name, PLACE_TIME_MS);

    // Rotate during capture so text is upright in that physical pose
    M5.Display.setRotation(p.rot_capture);

    int start_n = accelCal_.buf.n;
    int target_n = start_n + ACCEL_NEED_POSE;

    ui_title_("ACCEL");
    ui_line_(p.name);

    uint32_t t0 = millis();
    uint32_t last_change = millis();
    int last_n = accelCal_.buf.n;

    while (millis() - t0 < ACCEL_TIMEOUT_MS) {
      Vector3f a,w,m;
      float T;
      uint32_t mask;
      if (!read_sensors_(a,w,m,T,mask)) { delay(2); continue; }

      accelCal_.addSample(a, w, T);

      int n = accelCal_.buf.n;
      if (n != last_n) { last_n = n; last_change = millis(); }

      if (millis() - last_change > STUCK_MS) {
        Serial.printf("[ACC] stuck pose='%s' got=%d\n", p.name, accelCal_.buf.n - start_n);
        M5.Display.setRotation(ROT_READ);
        ui_fail_("ACCEL", "No samples accepted");
        return false;
      }

      ui_bar_((float)(n - start_n) / (float)ACCEL_NEED_POSE);
      if (n >= target_n) {
        M5.Display.setRotation(ROT_READ);
        done_and_wait_next_(p.name);
        return true;
      }

      delay(5);
    }

    Serial.printf("[ACC] timeout pose='%s' got=%d\n", p.name, accelCal_.buf.n - start_n);
    M5.Display.setRotation(ROT_READ);
    ui_fail_("ACCEL", "Timeout");
    return false;
  }

  static bool capture_gyro_() {
    ui_wait_tap_("GYRO", "SCREEN UP", "On table, still");
    place_delay_("GYRO", "SCREEN UP", PLACE_TIME_MS);

    M5.Display.setRotation(ROT_READ);

    int start_n = gyroCal_.buf.n;
    int target_n = start_n + GYRO_NEED;

    ui_title_("GYRO");
    ui_line_("Capturing");

    uint32_t t0 = millis();
    uint32_t last_change = millis();
    int last_n = gyroCal_.buf.n;

    while (millis() - t0 < GYRO_TIMEOUT_MS) {
      Vector3f a,w,m;
      float T;
      uint32_t mask;
      if (!read_sensors_(a,w,m,T,mask)) { delay(2); continue; }

      gyroCal_.addSample(w, a, T);

      int n = gyroCal_.buf.n;
      if (n != last_n) { last_n = n; last_change = millis(); }

      if (millis() - last_change > STUCK_MS) {
        Serial.printf("[GYR] stuck got=%d\n", gyroCal_.buf.n - start_n);
        ui_fail_("GYRO", "No samples accepted");
        return false;
      }

      ui_bar_((float)(n - start_n) / (float)GYRO_NEED);
      if (n >= target_n) {
        done_and_wait_next_("GYRO done");
        return true;
      }

      delay(5);
    }

    ui_fail_("GYRO", "Timeout");
    return false;
  }

  static bool capture_mag_() {
    ui_wait_tap_("MAG", "Rotate slow", "Big loops");
    M5.Display.setRotation(ROT_READ);

    int start_n = magCal_.buf.n;
    int target_n = start_n + MAG_NEED;

    ui_title_("MAG");
    ui_line_("Rotate now");

    uint32_t t0 = millis();
    uint32_t last_change = millis();
    int last_n = magCal_.buf.n;

    while (millis() - t0 < MAG_TIMEOUT_MS) {
      Vector3f a,w,m;
      float T;
      uint32_t mask;
      if (!read_sensors_(a,w,m,T,mask)) { delay(2); continue; }

      if (mask & (uint32_t)M5_IMU::sensor_mask_mag) {
        magCal_.addSample(m);
      }

      int n = magCal_.buf.n;
      if (n != last_n) { last_n = n; last_change = millis(); }

      if (millis() - last_change > STUCK_MS) {
        Serial.printf("[MAG] stuck got=%d\n", magCal_.buf.n - start_n);
        ui_fail_("MAG", "No mag samples");
        return false;
      }

      ui_bar_((float)(n - start_n) / (float)MAG_NEED);
      if (n >= target_n) {
        done_and_wait_next_("MAG done");
        return true;
      }

      delay(5);
    }

    ui_fail_("MAG", "Timeout");
    return false;
  }

  // ----------------------------
  // Fit in big-stack task (prevents stack-canary crash)
  // ----------------------------
  static volatile bool fit_done_;
  static volatile bool fit_ok_;

  static imu_cal::AccelCalibration<float> acc_out_;
  static imu_cal::GyroCalibration<float>  gyr_out_;
  static imu_cal::MagCalibration<float>   mag_out_;

  static void acc_fit_task_(void*) {
    bool ok = accelCal_.fit(acc_out_, 3, 0.15f);
    fit_ok_ = ok && acc_out_.ok;
    fit_done_ = true;
    vTaskDelete(nullptr);
  }
  static void gyr_fit_task_(void*) {
    bool ok = gyroCal_.fit(gyr_out_);
    fit_ok_ = ok && gyr_out_.ok;
    fit_done_ = true;
    vTaskDelete(nullptr);
  }
  static void mag_fit_task_(void*) {
    bool ok = magCal_.fit(mag_out_, 3, 0.15f);
    fit_ok_ = ok && mag_out_.ok;
    fit_done_ = true;
    vTaskDelete(nullptr);
  }

  static bool run_fit_task_(TaskFunction_t fn, const char* what) {
    fit_done_ = false;
    fit_ok_   = false;

    ui_title_("FIT");
    ui_line_(what);

    BaseType_t r = xTaskCreatePinnedToCore(fn, what, FIT_STACK_WORDS, nullptr, 1, nullptr, 1);
    if (r != pdPASS) {
      ui_fail_("FIT", "Task create failed");
      return false;
    }

    uint32_t t0 = millis();
    float phase = 0.0f;

    while (!fit_done_) {
      if (millis() - t0 > FIT_TIMEOUT_MS) {
        ui_fail_("FIT", "Timeout");
        return false;
      }
      // little animated bar
      phase += 0.07f;
      float v = 0.5f + 0.5f * sinf(phase);
      ui_bar_(v);
      delay(30);
    }

    if (!fit_ok_) {
      ui_fail_("FIT", "Fit failed");
      return false;
    }

    beep_ok_();
    return true;
  }

  // ----------------------------
  // Wizard
  // ----------------------------
  static bool run_wizard_() {
    Serial.println("[WIZ] start");

    // wipe M5 offsets + disable M5 internal calibration
    M5.Imu.setCalibration(0,0,0);
    M5.Imu.clearOffsetData();

    accelCal_.clear();
    gyroCal_.clear();
    magCal_.clear();

    ui_wait_tap_("IMU CAL", "6 poses", "Tap each step");

    // Best-effort rotations for “upright text” in each pose.
    // If one edge reads upside-down, swap 0<->2 for that pose.
    const Pose poses[6] = {
      {"1/6 SCREEN UP",     nullptr,  ROT_READ},
      {"2/6 SCREEN DOWN",   "Wait for beep", ROT_READ},
      {"3/6 LEFT EDGE",     nullptr,  0},
      {"4/6 RIGHT EDGE",    nullptr,  2},
      {"5/6 TOP EDGE",      nullptr,  0},
      {"6/6 BOTTOM EDGE",   nullptr,  2},
    };

    for (int i = 0; i < 6; ++i) {
      if (!capture_accel_pose_(poses[i])) return false;
    }

    int acc_n = accelCal_.buf.n;
    Serial.printf("[ACC] accepted=%d\n", acc_n);
    if (acc_n < ACCEL_MIN_TO_FIT) {
      ui_fail_("ACCEL", "Too few accepted");
      return false;
    }

    if (!run_fit_task_(acc_fit_task_, "ACCEL")) return false;
    Serial.printf("[ACC] ok=%d rms=%.5f\n", (int)acc_out_.ok, (double)acc_out_.rms_mag);

    if (!capture_gyro_()) return false;

    int gyr_n = gyroCal_.buf.n;
    Serial.printf("[GYR] accepted=%d\n", gyr_n);
    if (gyr_n < GYRO_MIN_TO_FIT) {
      ui_fail_("GYRO", "Too few accepted");
      return false;
    }

    if (!run_fit_task_(gyr_fit_task_, "GYRO")) return false;
    Serial.printf("[GYR] ok=%d\n", (int)gyr_out_.ok);

    if (!capture_mag_()) return false;

    int mag_n = magCal_.buf.n;
    Serial.printf("[MAG] accepted=%d\n", mag_n);
    if (mag_n < MAG_MIN_TO_FIT) {
      ui_fail_("MAG", "Too few accepted");
      return false;
    }

    if (!run_fit_task_(mag_fit_task_, "MAG")) return false;
    Serial.printf("[MAG] ok=%d B=%.2f rms=%.3f\n",
                  (int)mag_out_.ok, (double)mag_out_.field_uT, (double)mag_out_.rms);

    // Build blob ONLY after all fits succeeded
    CalBlobV1 blob;
    memset(&blob, 0, sizeof(blob));
    blob.magic = IMU_CAL_MAGIC;
    blob.version = IMU_CAL_VERSION;
    blob.size_bytes = sizeof(CalBlobV1);

    blob.accel_ok = 1;
    blob.accel_g = acc_out_.g;
    mat_to_rowmajor9_(acc_out_.S, blob.accel_S);
    blob.accel_T0 = acc_out_.biasT.T0;
    blob.accel_b0[0]=acc_out_.biasT.b0.x(); blob.accel_b0[1]=acc_out_.biasT.b0.y(); blob.accel_b0[2]=acc_out_.biasT.b0.z();
    blob.accel_k[0]=acc_out_.biasT.k.x();   blob.accel_k[1]=acc_out_.biasT.k.y();   blob.accel_k[2]=acc_out_.biasT.k.z();
    blob.accel_rms_mag = acc_out_.rms_mag;

    blob.gyro_ok = 1;
    blob.gyro_T0 = gyr_out_.biasT.T0;
    blob.gyro_b0[0]=gyr_out_.biasT.b0.x(); blob.gyro_b0[1]=gyr_out_.biasT.b0.y(); blob.gyro_b0[2]=gyr_out_.biasT.b0.z();
    blob.gyro_k[0]=gyr_out_.biasT.k.x();   blob.gyro_k[1]=gyr_out_.biasT.k.y();   blob.gyro_k[2]=gyr_out_.biasT.k.z();

    blob.mag_ok = 1;
    mat_to_rowmajor9_(mag_out_.A, blob.mag_A);
    blob.mag_b[0]=mag_out_.b.x(); blob.mag_b[1]=mag_out_.b.y(); blob.mag_b[2]=mag_out_.b.z();
    blob.mag_field_uT = mag_out_.field_uT;
    blob.mag_rms = mag_out_.rms;

    ui_title_("SAVE");
    ui_line_("Writing...");
    bool wrote = save_cal_to_nvs_(blob);
    bool rb = load_cal_from_nvs_();
    have_blob_ = rb;

    Serial.printf("[SAVE] wrote=%d readback=%d\n", (int)wrote, (int)rb);

    if (!wrote || !rb) {
      ui_fail_("SAVE", "Write/readback failed");
      return false;
    }

    ui_title_("DONE");
    M5.Display.printf("BLOB: YES\n");
    M5.Display.printf("A:%d  G:%d  M:%d\n", (int)g_acc_cal_.ok, (int)g_gyr_cal_.ok, (int)g_mag_cal_.ok);
    ui_line_("");
    ui_line_("Tap to return");
    beep_ok_();
    while (true) { M5.update(); if (M5.BtnA.wasPressed()) break; delay(10); }

    return true;
  }

  // ----------------------------
  // Serial streaming (raw + cal)
  // ----------------------------
  static inline Vector3f applyAccel_(const Vector3f& a_raw, float tempC) {
    if (!g_acc_cal_.ok) return a_raw;
    return g_acc_cal_.apply(a_raw, tempC);
  }
  static inline Vector3f applyGyro_(const Vector3f& w_raw, float tempC) {
    if (!g_gyr_cal_.ok) return w_raw;
    return g_gyr_cal_.apply(w_raw, tempC);
  }
  static inline Vector3f applyMag_(const Vector3f& m_raw) {
    if (!g_mag_cal_.ok) return m_raw;
    return g_mag_cal_.apply(m_raw);
  }

  static void stream_serial_() {
    Vector3f a_raw, w_raw, m_raw;
    float tempC;
    uint32_t mask;

    if (!read_sensors_(a_raw, w_raw, m_raw, tempC, mask)) return;

    Vector3f a_cal = applyAccel_(a_raw, tempC);
    Vector3f w_cal = applyGyro_(w_raw, tempC);
    Vector3f m_cal = applyMag_(m_raw);

    uint32_t now = millis();
    if (now - last_print_ms_ > 250) {
      last_print_ms_ = now;
      Serial.printf("T:%.2f ", (double)tempC);
      Serial.printf("a:%+.3f,%+.3f,%+.3f ", (double)a_raw.x(), (double)a_raw.y(), (double)a_raw.z());
      Serial.printf("w:%+.4f,%+.4f,%+.4f ", (double)w_raw.x(), (double)w_raw.y(), (double)w_raw.z());
      Serial.printf("m:%+.2f,%+.2f,%+.2f | ", (double)m_raw.x(), (double)m_raw.y(), (double)m_raw.z());
      Serial.printf("aC:%+.3f,%+.3f,%+.3f ", (double)a_cal.x(), (double)a_cal.y(), (double)a_cal.z());
      Serial.printf("wC:%+.4f,%+.4f,%+.4f ", (double)w_cal.x(), (double)w_cal.y(), (double)w_cal.z());
      Serial.printf("mC:%+.2f,%+.2f,%+.2f\n", (double)m_cal.x(), (double)m_cal.y(), (double)m_cal.z());
    }
  }

private:
  static Preferences prefs_;
  static bool have_blob_;
  static CalBlobV1 cal_blob_;

  static imu_cal::AccelCalibration<float> g_acc_cal_;
  static imu_cal::GyroCalibration<float>  g_gyr_cal_;
  static imu_cal::MagCalibration<float>   g_mag_cal_;

  static imu_cal::AccelCalibrator<float, 400, 8> accelCal_;
  static imu_cal::GyroCalibrator<float,  400, 8> gyroCal_;
  static imu_cal::MagCalibrator<float,   400>    magCal_;

  static int tap_count_;
  static uint32_t tap_deadline_ms_;
  static uint32_t last_print_ms_;
};

// Static storage
Preferences ImuCalApp::prefs_;
bool ImuCalApp::have_blob_ = false;
ImuCalApp::CalBlobV1 ImuCalApp::cal_blob_;

imu_cal::AccelCalibration<float> ImuCalApp::g_acc_cal_;
imu_cal::GyroCalibration<float>  ImuCalApp::g_gyr_cal_;
imu_cal::MagCalibration<float>   ImuCalApp::g_mag_cal_;

imu_cal::AccelCalibrator<float, 400, 8> ImuCalApp::accelCal_;
imu_cal::GyroCalibrator<float,  400, 8> ImuCalApp::gyroCal_;
imu_cal::MagCalibrator<float,   400>    ImuCalApp::magCal_;

volatile bool ImuCalApp::fit_done_ = false;
volatile bool ImuCalApp::fit_ok_   = false;
imu_cal::AccelCalibration<float> ImuCalApp::acc_out_;
imu_cal::GyroCalibration<float>  ImuCalApp::gyr_out_;
imu_cal::MagCalibration<float>   ImuCalApp::mag_out_;

int ImuCalApp::tap_count_ = 0;
uint32_t ImuCalApp::tap_deadline_ms_ = 0;
uint32_t ImuCalApp::last_print_ms_ = 0;

// Arduino entrypoints
void setup() { ImuCalApp::begin(); }
void loop()  { ImuCalApp::tick(); }
