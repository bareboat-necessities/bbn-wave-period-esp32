/*
  AtomS3R IMU calibration wizard (Accel + Gyro + Mag) using imu_cal::* calibrators.

  UI goals:
    - Short prompts that fit
    - No button needed during poses (screen may be DOWN)
    - Clear progress + clear fail reason
    - Detect REBOOT cause + last wizard stage

  Start: tap screen (BtnA) on status.
  Abort wizard: Serial 'Q'
  Erase saved cal: Serial 'E'

  REQUIREMENTS:
    - M5Unified
    - ESP32 Arduino core (Preferences, esp_reset_reason)
    - ArduinoEigenDense
    - CalibrateIMU_alt.h

  Units:
    accel: m/s^2
    gyro:  rad/s
    mag:   uT
*/

// IMPORTANT: Arduino .ino auto-prototypes need this:
struct CalBlobV1;

#include <M5Unified.h>
#include <Arduino.h>
#include <Preferences.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <stddef.h>      // offsetof
#include <esp_system.h>  // esp_reset_reason()

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
#define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif
#include <ArduinoEigenDense.h>

using M5_IMU = decltype(M5.Imu);
#include "CalibrateIMU_alt.h"

using Vector3f = Eigen::Matrix<float,3,1>;
using Matrix3f = Eigen::Matrix<float,3,3>;

static constexpr float g_std   = 9.80665f;
static constexpr float DEG2RAD = 3.14159265358979323846f / 180.0f;

// ----------------------------
// Timing (human)
// ----------------------------
static constexpr uint32_t SETUP_MS          = 12000;   // time to place device
static constexpr uint32_t CAPTURE_MS        = 120000;  // per accel pose
static constexpr uint32_t GYRO_SETUP_MS     = 9000;
static constexpr uint32_t GYRO_CAPTURE_MS   = 80000;
static constexpr uint32_t MAG_SETUP_MS      = 7000;
static constexpr uint32_t MAG_CAPTURE_MS    = 220000;

static constexpr int ACC_FACE_NEED = 60;    // accepted samples per pose
static constexpr int GYRO_NEED     = 250;
static constexpr int MAG_NEED      = 350;

// ----------------------------
// Axis mapping (MATCH YOUR PATH)
// acc_body = ( ay, ax, -az ) * g
// gyr_body = ( gy, gx, -gz ) * deg2rad
// mag_body = ( my, mx, -mz ) * (1/10)
// ----------------------------
static inline Vector3f map_acc_to_body_ned(const m5::imu_3d_t& a_g_units) {
  return Vector3f(a_g_units.y * g_std, a_g_units.x * g_std, -a_g_units.z * g_std);
}
static inline Vector3f map_gyr_to_body_ned(const m5::imu_3d_t& w_deg_s) {
  return Vector3f(w_deg_s.y * DEG2RAD, w_deg_s.x * DEG2RAD, -w_deg_s.z * DEG2RAD);
}
static inline Vector3f map_mag_to_body_uT(const m5::imu_3d_t& m_raw) {
  return Vector3f(m_raw.y / 10.0f, m_raw.x / 10.0f, -m_raw.z / 10.0f);
}

// ----------------------------
// Reset + stage tracking (diagnostic)
// ----------------------------
RTC_DATA_ATTR uint32_t g_last_stage = 0;   // persists across resets

static const char* reset_reason_str(esp_reset_reason_t r) {
  switch (r) {
    case ESP_RST_POWERON:   return "POWERON";
    case ESP_RST_EXT:       return "EXT";
    case ESP_RST_SW:        return "SW";
    case ESP_RST_PANIC:     return "PANIC";
    case ESP_RST_INT_WDT:   return "WDT_INT";
    case ESP_RST_TASK_WDT:  return "WDT_TASK";
    case ESP_RST_WDT:       return "WDT";
    case ESP_RST_BROWNOUT:  return "BROWNOUT";
    case ESP_RST_SDIO:      return "SDIO";
    default:                return "UNKNOWN";
  }
}

static const char* stage_str(uint32_t s) {
  switch (s) {
    case 0:   return "NONE";
    case 10:  return "ACC_SETUP";
    case 11:  return "ACC_CAPTURE";
    case 20:  return "ACC_FIT";
    case 30:  return "GYRO_SETUP";
    case 31:  return "GYRO_CAPTURE";
    case 40:  return "GYRO_FIT";
    case 50:  return "MAG_SETUP";
    case 51:  return "MAG_CAPTURE";
    case 60:  return "MAG_FIT";
    case 70:  return "SAVE_NVS";
    case 71:  return "VERIFY_NVS";
    default:  return "???";
  }
}

// ----------------------------
// NVS blob + CRC
// ----------------------------
static constexpr uint32_t IMU_CAL_MAGIC   = 0x434C554D; // 'MULC'
static constexpr uint16_t IMU_CAL_VERSION = 1;

static uint32_t crc32_ieee(const uint8_t* data, size_t n) {
  uint32_t crc = 0xFFFFFFFFu;
  for (size_t i = 0; i < n; ++i) {
    crc ^= (uint32_t)data[i];
    for (int k = 0; k < 8; ++k) {
      uint32_t mask = -(int32_t)(crc & 1u);
      crc = (crc >> 1) ^ (0xEDB88320u & mask);
    }
  }
  return ~crc;
}

struct CalBlobV1 {
  uint32_t magic;
  uint16_t version;
  uint16_t size_bytes;

  uint8_t  accel_ok;
  uint8_t  _pad0[3];
  float    accel_g;
  float    accel_S[9];
  float    accel_T0;
  float    accel_b0[3];
  float    accel_k[3];
  float    accel_rms_mag;

  uint8_t  gyro_ok;
  uint8_t  _pad1[3];
  float    gyro_T0;
  float    gyro_b0[3];
  float    gyro_k[3];

  uint8_t  mag_ok;
  uint8_t  _pad2[3];
  float    mag_A[9];
  float    mag_b[3];
  float    mag_field_uT;
  float    mag_rms;

  uint32_t crc;
};

static constexpr size_t CAL_CRC_LEN = offsetof(CalBlobV1, crc);

static Preferences prefs;
static bool have_blob = false;
static CalBlobV1 cal_blob;

// runtime cal objects
static imu_cal::AccelCalibration<float> g_acc_cal;
static imu_cal::GyroCalibration<float>  g_gyr_cal;
static imu_cal::MagCalibration<float>   g_mag_cal;

// ----------------------------
// Matrix helpers
// ----------------------------
static Matrix3f mat_from_rowmajor9(const float a[9]) {
  Matrix3f M;
  M << a[0], a[1], a[2],
       a[3], a[4], a[5],
       a[6], a[7], a[8];
  return M;
}
static void mat_to_rowmajor9(const Matrix3f& M, float a[9]) {
  a[0]=M(0,0); a[1]=M(0,1); a[2]=M(0,2);
  a[3]=M(1,0); a[4]=M(1,1); a[5]=M(1,2);
  a[6]=M(2,0); a[7]=M(2,1); a[8]=M(2,2);
}

static void rebuild_runtime_cals_from_blob() {
  // accel
  g_acc_cal.ok = (cal_blob.accel_ok != 0);
  g_acc_cal.g  = cal_blob.accel_g;
  g_acc_cal.S  = mat_from_rowmajor9(cal_blob.accel_S);
  g_acc_cal.biasT.ok = g_acc_cal.ok;
  g_acc_cal.biasT.T0 = cal_blob.accel_T0;
  g_acc_cal.biasT.b0 = Vector3f(cal_blob.accel_b0[0], cal_blob.accel_b0[1], cal_blob.accel_b0[2]);
  g_acc_cal.biasT.k  = Vector3f(cal_blob.accel_k[0],  cal_blob.accel_k[1],  cal_blob.accel_k[2]);
  g_acc_cal.rms_mag  = cal_blob.accel_rms_mag;

  // gyro
  g_gyr_cal.ok = (cal_blob.gyro_ok != 0);
  g_gyr_cal.S  = Matrix3f::Identity();
  g_gyr_cal.biasT.ok = g_gyr_cal.ok;
  g_gyr_cal.biasT.T0 = cal_blob.gyro_T0;
  g_gyr_cal.biasT.b0 = Vector3f(cal_blob.gyro_b0[0], cal_blob.gyro_b0[1], cal_blob.gyro_b0[2]);
  g_gyr_cal.biasT.k  = Vector3f(cal_blob.gyro_k[0],  cal_blob.gyro_k[1],  cal_blob.gyro_k[2]);

  // mag
  g_mag_cal.ok = (cal_blob.mag_ok != 0);
  g_mag_cal.A  = mat_from_rowmajor9(cal_blob.mag_A);
  g_mag_cal.b  = Vector3f(cal_blob.mag_b[0], cal_blob.mag_b[1], cal_blob.mag_b[2]);
  g_mag_cal.field_uT = cal_blob.mag_field_uT;
  g_mag_cal.rms      = cal_blob.mag_rms;
}

static bool load_cal_from_nvs() {
  if (!prefs.begin("imu_cal", true)) return false;

  size_t n = prefs.getBytesLength("blob");
  if (n != sizeof(CalBlobV1)) { prefs.end(); return false; }

  CalBlobV1 tmp;
  size_t got = prefs.getBytes("blob", &tmp, sizeof(tmp));
  prefs.end();
  if (got != sizeof(tmp)) return false;

  if (tmp.magic != IMU_CAL_MAGIC || tmp.version != IMU_CAL_VERSION || tmp.size_bytes != sizeof(CalBlobV1))
    return false;

  uint32_t want = tmp.crc;
  tmp.crc = 0;
  uint32_t have = crc32_ieee((const uint8_t*)&tmp, CAL_CRC_LEN);
  if (have != want) return false;

  cal_blob = tmp;
  rebuild_runtime_cals_from_blob();
  return true;
}

static bool save_cal_to_nvs_verified(const CalBlobV1& in_blob) {
  CalBlobV1 tmp;
  memset(&tmp, 0, sizeof(tmp));

  tmp.magic = IMU_CAL_MAGIC;
  tmp.version = IMU_CAL_VERSION;
  tmp.size_bytes = sizeof(CalBlobV1);

  // copy fields we care about
  tmp.accel_ok = in_blob.accel_ok;
  tmp.accel_g = in_blob.accel_g;
  memcpy(tmp.accel_S, in_blob.accel_S, sizeof(tmp.accel_S));
  tmp.accel_T0 = in_blob.accel_T0;
  memcpy(tmp.accel_b0, in_blob.accel_b0, sizeof(tmp.accel_b0));
  memcpy(tmp.accel_k,  in_blob.accel_k,  sizeof(tmp.accel_k));
  tmp.accel_rms_mag = in_blob.accel_rms_mag;

  tmp.gyro_ok = in_blob.gyro_ok;
  tmp.gyro_T0 = in_blob.gyro_T0;
  memcpy(tmp.gyro_b0, in_blob.gyro_b0, sizeof(tmp.gyro_b0));
  memcpy(tmp.gyro_k,  in_blob.gyro_k,  sizeof(tmp.gyro_k));

  tmp.mag_ok = in_blob.mag_ok;
  memcpy(tmp.mag_A, in_blob.mag_A, sizeof(tmp.mag_A));
  memcpy(tmp.mag_b, in_blob.mag_b, sizeof(tmp.mag_b));
  tmp.mag_field_uT = in_blob.mag_field_uT;
  tmp.mag_rms      = in_blob.mag_rms;

  tmp.crc = 0;
  tmp.crc = crc32_ieee((const uint8_t*)&tmp, CAL_CRC_LEN);

  g_last_stage = 70; // SAVE_NVS
  if (!prefs.begin("imu_cal", false)) return false;
  size_t put = prefs.putBytes("blob", &tmp, sizeof(tmp));
  prefs.end();
  if (put != sizeof(tmp)) return false;

  // verify immediately
  g_last_stage = 71; // VERIFY_NVS
  return load_cal_from_nvs();
}

static void erase_our_cal_from_nvs() {
  if (!prefs.begin("imu_cal", false)) return;
  prefs.remove("blob");
  prefs.end();
}

// ----------------------------
// Apply helpers
// ----------------------------
static inline Vector3f applyAccel(const Vector3f& a_raw_body, float tempC) {
  if (!g_acc_cal.ok) return a_raw_body;
  return g_acc_cal.apply(a_raw_body, tempC);
}
static inline Vector3f applyGyro(const Vector3f& w_raw_body, float tempC) {
  if (!g_gyr_cal.ok) return w_raw_body;
  return g_gyr_cal.apply(w_raw_body, tempC);
}
static inline Vector3f applyMag(const Vector3f& m_raw_uT_body) {
  if (!g_mag_cal.ok) return m_raw_uT_body;
  return g_mag_cal.apply(m_raw_uT_body);
}

// ----------------------------
// UI (short)
// ----------------------------
static auto& disp = M5.Display;

static void ui_clear(uint16_t bg = TFT_BLACK) { disp.fillScreen(bg); }

static void ui_title(const char* s) {
  disp.setTextColor(TFT_WHITE, TFT_BLACK);
  disp.setCursor(0, 0);
  disp.setTextSize(2);
  disp.println(s);
  disp.setTextSize(1);
  disp.println();
}

static void ui_line(const char* s) {
  disp.setTextColor(TFT_WHITE, TFT_BLACK);
  disp.println(s);
}

static void ui_progress(int done, int total) {
  if (total <= 0) total = 1;
  if (done < 0) done = 0;
  if (done > total) done = total;

  int w = disp.width() - 10;
  int x = 5;
  int y = disp.height() - 16;
  int h = 10;

  disp.drawRect(x, y, w, h, TFT_DARKGREY);
  int fillw = (w - 2) * done / total;
  disp.fillRect(x + 1, y + 1, fillw, h - 2, TFT_GREEN);

  disp.setCursor(0, disp.height() - 32);
  disp.setTextColor(TFT_CYAN, TFT_BLACK);
  disp.printf("%d/%d      \n", done, total);
}

static bool serial_abort() {
  while (Serial.available()) {
    char c = (char)Serial.read();
    if (c == 'Q' || c == 'q') return true;
  }
  return false;
}

// ----------------------------
// Calibrators & sensor read
// ----------------------------
static imu_cal::AccelCalibrator<float, 400, 8> accelCal;
static imu_cal::GyroCalibrator<float, 400, 8>  gyroCal;
static imu_cal::MagCalibrator<float, 400>      magCal;

static bool read_sensors(Vector3f& a_raw_body, Vector3f& w_raw_body, Vector3f& m_raw_uT_body,
                         float& tempC, uint32_t& mask_out)
{
  mask_out = M5.Imu.update();
  if (!mask_out) return false;

  auto data = M5.Imu.getImuData();
  tempC = NAN;
  M5.Imu.getTemp(&tempC);

  a_raw_body    = map_acc_to_body_ned(data.accel);
  w_raw_body    = map_gyr_to_body_ned(data.gyro);
  m_raw_uT_body = map_mag_to_body_uT(data.mag);
  return true;
}

static bool detect_mag_present() {
  uint32_t t0 = millis();
  while (millis() - t0 < 1200) {
    Vector3f a, w, m;
    float tC;
    uint32_t mask;
    if (read_sensors(a, w, m, tC, mask)) {
      if (mask & (uint32_t)M5_IMU::sensor_mask_mag) return true;
    }
    delay(5);
  }
  return false;
}

// ----------------------------
// Pages
// ----------------------------
static bool setup_page(const char* title, const char* l1, const char* l2, const char* l3, uint32_t ms) {
  ui_clear();
  ui_title(title);
  ui_line(l1);
  if (l2 && l2[0]) ui_line(l2);
  if (l3 && l3[0]) ui_line(l3);
  disp.println();
  ui_line("Wait... (auto)");

  uint32_t t0 = millis();
  uint32_t last = 0;
  while (millis() - t0 < ms) {
    if (serial_abort()) return false;
    uint32_t now = millis();
    if (now - last > 250) {
      last = now;
      uint32_t remain_s = (ms - (now - t0) + 999) / 1000;
      disp.setCursor(0, disp.height() - 32);
      disp.setTextColor(TFT_YELLOW, TFT_BLACK);
      disp.printf("%lus       \n", (unsigned long)remain_s);
    }
    delay(10);
  }
  return true;
}

static void show_fail(const char* title, const char* msg) {
  ui_clear();
  ui_title(title);
  ui_line(msg);
  ui_line("Serial: Q abort");
  delay(3500);
}

// ----------------------------
// Capture helpers (let YOUR calibrator decide acceptance)
// ----------------------------
static bool collect_acc_pose(const char* stepTitle, const char* hint, int need, uint32_t timeout_ms) {
  ui_clear();
  ui_title(stepTitle);
  ui_line("Hold still.");
  disp.println();

  int n0 = accelCal.buf.n;
  uint32_t t0 = millis();
  uint32_t last_hint = 0;

  while (millis() - t0 < timeout_ms) {
    if (serial_abort()) return false;

    Vector3f a, w, m;
    float tC;
    uint32_t mask;
    if (!read_sensors(a, w, m, tC, mask)) { delay(2); continue; }

    // feed every time; calibrator decides if it accepts
    accelCal.addSample(a, w, tC);

    int got = accelCal.buf.n - n0;
    ui_progress(got, need);

    // simple motion hint (NOT a gate)
    disp.setCursor(0, 52);
    disp.setTextColor(TFT_WHITE, TFT_BLACK);
    float amag_err = fabsf(a.norm() - g_std);
    float wnorm = w.norm();
    disp.printf("Move:%s   \n", (amag_err < 0.9f && wnorm < 0.25f) ? "NO" : "YES");

    if (got == 0 && (millis() - t0) > 15000 && (millis() - last_hint) > 3000) {
      last_hint = millis();
      disp.setCursor(0, 70);
      disp.setTextColor(TFT_YELLOW, TFT_BLACK);
      disp.println("Hint:");
      disp.setTextColor(TFT_WHITE, TFT_BLACK);
      disp.println(hint);
    }

    if (got >= need) return true;
    delay(6);
  }
  return false;
}

static bool collect_gyro(int need, uint32_t timeout_ms) {
  ui_clear();
  ui_title("GYRO");
  ui_line("Display UP.");
  ui_line("Hands off.");
  disp.println();

  int n0 = gyroCal.buf.n;
  uint32_t t0 = millis();

  while (millis() - t0 < timeout_ms) {
    if (serial_abort()) return false;

    Vector3f a, w, m;
    float tC;
    uint32_t mask;
    if (!read_sensors(a, w, m, tC, mask)) { delay(2); continue; }

    gyroCal.addSample(w, a, tC);

    int got = gyroCal.buf.n - n0;
    ui_progress(got, need);

    if (got >= need) return true;
    delay(6);
  }
  return false;
}

static bool collect_mag(int need, uint32_t timeout_ms) {
  ui_clear();
  ui_title("MAG");
  ui_line("Rotate slow.");
  ui_line("Big loops.");
  disp.println();

  int n0 = magCal.buf.n;
  uint32_t t0 = millis();

  while (millis() - t0 < timeout_ms) {
    if (serial_abort()) return false;

    Vector3f a, w, m;
    float tC;
    uint32_t mask;
    if (!read_sensors(a, w, m, tC, mask)) { delay(2); continue; }

    if (mask & (uint32_t)M5_IMU::sensor_mask_mag) magCal.addSample(m);

    int got = magCal.buf.n - n0;
    ui_progress(got, need);

    if (got >= need) return true;
    delay(8);
  }
  return false;
}

// ----------------------------
// Wizard
// ----------------------------
static bool run_calibration_wizard(bool has_mag) {
  Serial.println("[WIZ] start");

  // Stage markers help you see where it died after a reboot
  g_last_stage = 10;

  // wipe M5 offsets + disable their internal influence
  M5.Imu.setCalibration(0, 0, 0);
  M5.Imu.clearOffsetData();

  accelCal.clear();
  gyroCal.clear();
  magCal.clear();

  struct Face {
    const char* setupTitle;
    const char* l1;
    const char* l2;
    const char* l3;
    const char* capTitle;
    const char* hint;
  };

  const Face faces[6] = {
    {"POSE 1/6", "DISPLAY UP",   "",           "",           "ACC 1/6", "Keep it still."},
    {"POSE 2/6", "DISPLAY DOWN", "",           "",           "ACC 2/6", "Let it rest flat."},
    {"POSE 3/6", "USB DOWN",     "Cable slack","(edge helps)","ACC 3/6", "Cable pushes it. Put near edge so cable hangs."},
    {"POSE 4/6", "USB UP",       "",           "",           "ACC 4/6", "Hold steady then rest it."},
    {"POSE 5/6", "LEFT DOWN",    "",           "",           "ACC 5/6", "Don't let it rock."},
    {"POSE 6/6", "RIGHT DOWN",   "",           "",           "ACC 6/6", "Don't let it rock."},
  };

  for (int i = 0; i < 6; ++i) {
    if (!setup_page(faces[i].setupTitle, faces[i].l1, faces[i].l2, faces[i].l3, SETUP_MS)) {
      show_fail("ABORT", "Wizard cancelled.");
      return false;
    }

    g_last_stage = 11; // ACC_CAPTURE
    bool ok = collect_acc_pose(faces[i].capTitle, faces[i].hint, ACC_FACE_NEED, CAPTURE_MS);
    if (!ok) {
      show_fail("ACC FAIL", "No samples.");
      return false;
    }
  }

  g_last_stage = 20; // ACC_FIT
  imu_cal::AccelCalibration<float> acc_out;
  bool acc_fit_ok = accelCal.fit(acc_out, 3, 0.15f);
  Serial.printf("[ACC] fit=%d ok=%d rms|g|=%.5f\n", (int)acc_fit_ok, (int)acc_out.ok, (double)acc_out.rms_mag);
  if (!acc_fit_ok || !acc_out.ok) {
    show_fail("ACC FAIL", "Fit failed.");
    return false;
  }

  g_last_stage = 30; // GYRO_SETUP
  if (!setup_page("GYRO", "DISPLAY UP", "Hands off.", "", GYRO_SETUP_MS)) {
    show_fail("ABORT", "Wizard cancelled.");
    return false;
  }

  g_last_stage = 31; // GYRO_CAPTURE
  if (!collect_gyro(GYRO_NEED, GYRO_CAPTURE_MS)) {
    show_fail("GYRO FAIL", "No samples.");
    return false;
  }

  g_last_stage = 40; // GYRO_FIT
  imu_cal::GyroCalibration<float> gyr_out;
  bool gyr_fit_ok = gyroCal.fit(gyr_out);
  Serial.printf("[GYR] fit=%d ok=%d\n", (int)gyr_fit_ok, (int)gyr_out.ok);
  if (!gyr_fit_ok || !gyr_out.ok) {
    show_fail("GYRO FAIL", "Fit failed.");
    return false;
  }

  imu_cal::MagCalibration<float> mag_out;
  if (has_mag) {
    g_last_stage = 50; // MAG_SETUP
    if (!setup_page("MAG", "Rotate slow", "Big loops", "", MAG_SETUP_MS)) {
      show_fail("ABORT", "Wizard cancelled.");
      return false;
    }

    g_last_stage = 51; // MAG_CAPTURE
    if (!collect_mag(MAG_NEED, MAG_CAPTURE_MS)) {
      show_fail("MAG FAIL", "No samples.");
      return false;
    }

    g_last_stage = 60; // MAG_FIT
    bool mag_fit_ok = magCal.fit(mag_out, 3, 0.15f);
    Serial.printf("[MAG] fit=%d ok=%d B=%.2f rms=%.3f\n", (int)mag_fit_ok, (int)mag_out.ok, (double)mag_out.field_uT, (double)mag_out.rms);
    if (!mag_fit_ok || !mag_out.ok) {
      show_fail("MAG FAIL", "Fit failed.");
      return false;
    }
  } else {
    mag_out.ok = false;
    mag_out.A = Matrix3f::Identity();
    mag_out.b = Vector3f::Zero();
    mag_out.field_uT = 0.0f;
    mag_out.rms = 0.0f;
  }

  // Build blob
  CalBlobV1 blob;
  memset(&blob, 0, sizeof(blob));
  blob.magic = IMU_CAL_MAGIC;
  blob.version = IMU_CAL_VERSION;
  blob.size_bytes = sizeof(CalBlobV1);

  blob.accel_ok = acc_out.ok ? 1 : 0;
  blob.accel_g  = acc_out.g;
  mat_to_rowmajor9(acc_out.S, blob.accel_S);
  blob.accel_T0 = acc_out.biasT.T0;
  blob.accel_b0[0]=acc_out.biasT.b0.x(); blob.accel_b0[1]=acc_out.biasT.b0.y(); blob.accel_b0[2]=acc_out.biasT.b0.z();
  blob.accel_k[0]=acc_out.biasT.k.x();   blob.accel_k[1]=acc_out.biasT.k.y();   blob.accel_k[2]=acc_out.biasT.k.z();
  blob.accel_rms_mag = acc_out.rms_mag;

  blob.gyro_ok = gyr_out.ok ? 1 : 0;
  blob.gyro_T0 = gyr_out.biasT.T0;
  blob.gyro_b0[0]=gyr_out.biasT.b0.x(); blob.gyro_b0[1]=gyr_out.biasT.b0.y(); blob.gyro_b0[2]=gyr_out.biasT.b0.z();
  blob.gyro_k[0]=gyr_out.biasT.k.x();   blob.gyro_k[1]=gyr_out.biasT.k.y();   blob.gyro_k[2]=gyr_out.biasT.k.z();

  blob.mag_ok = (has_mag && mag_out.ok) ? 1 : 0;
  mat_to_rowmajor9(mag_out.A, blob.mag_A);
  blob.mag_b[0]=mag_out.b.x(); blob.mag_b[1]=mag_out.b.y(); blob.mag_b[2]=mag_out.b.z();
  blob.mag_field_uT = mag_out.field_uT;
  blob.mag_rms      = mag_out.rms;

  // Save + verify
  ui_clear();
  ui_title("SAVING");
  ui_line("Writing NVS...");
  bool saved_ok = save_cal_to_nvs_verified(blob);
  Serial.printf("[SAVE] ok=%d\n", (int)saved_ok);
  if (!saved_ok) {
    show_fail("SAVE FAIL", "NVS verify failed.");
    return false;
  }

  // Show result
  ui_clear();
  ui_title("SAVED");
  disp.setTextColor(TFT_WHITE, TFT_BLACK);
  disp.printf("ACC: %s\n", g_acc_cal.ok ? "OK" : "FAIL");
  disp.printf("GYR: %s\n", g_gyr_cal.ok ? "OK" : "FAIL");
  if (has_mag) disp.printf("MAG: %s\n", g_mag_cal.ok ? "OK" : "FAIL");
  else         disp.printf("MAG: none\n");
  delay(3000);

  g_last_stage = 0; // success
  return true;
}

// ----------------------------
// Status
// ----------------------------
static bool g_has_mag = true;
static uint32_t last_print_ms = 0;

static void draw_status(const char* boot_note) {
  ui_clear();
  ui_title("IMU CAL");

  disp.setTextColor(TFT_WHITE, TFT_BLACK);
  disp.printf("Saved: %s\n", have_blob ? "YES" : "NO");
  disp.printf("ACC:%s  GYR:%s\n", g_acc_cal.ok ? "OK" : "--", g_gyr_cal.ok ? "OK" : "--");
  if (g_has_mag) disp.printf("MAG:%s\n", g_mag_cal.ok ? "OK" : "--");
  else           disp.printf("MAG:none\n");

  disp.println();
  ui_line("Tap: START");
  ui_line("Serial: E erase");
  ui_line("Serial: Q abort");

  if (boot_note && boot_note[0]) {
    disp.println();
    disp.setTextColor(TFT_YELLOW, TFT_BLACK);
    disp.println(boot_note);
  }
}

void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);

  esp_reset_reason_t rr = esp_reset_reason();
  Serial.printf("[BOOT] reset=%s last_stage=%s(%lu)\n",
                reset_reason_str(rr), stage_str(g_last_stage), (unsigned long)g_last_stage);

  if (!M5.Imu.isEnabled()) {
    ui_clear();
    ui_title("IMU FAIL");
    ui_line("IMU not found.");
    while (true) delay(100);
  }

  // Disable M5 internal cal influence
  M5.Imu.setCalibration(0, 0, 0);

  g_has_mag = detect_mag_present();
  have_blob = load_cal_from_nvs();
  if (!have_blob) {
    memset(&cal_blob, 0, sizeof(cal_blob));
    rebuild_runtime_cals_from_blob();
  }

  char boot_note[64];
  snprintf(boot_note, sizeof(boot_note), "RST:%s  LAST:%s",
           reset_reason_str(rr), stage_str(g_last_stage));

  draw_status(boot_note);

  // If it rebooted mid-wizard, keep stage for you to see (donâ€™t wipe it here)
  Serial.println("Tap screen to START. Serial: E=erase  Q=abort wizard.");
}

void loop() {
  M5.update();

  // serial commands
  while (Serial.available()) {
    char c = (char)Serial.read();
    if (c == 'E' || c == 'e') {
      Serial.println("[CMD] erase");
      erase_our_cal_from_nvs();
      M5.Imu.clearOffsetData();
      have_blob = false;
      memset(&cal_blob, 0, sizeof(cal_blob));
      rebuild_runtime_cals_from_blob();
      draw_status("");
    } else if (c == 'Q' || c == 'q') {
      Serial.println("[CMD] abort (no-op on status)");
    }
  }

  if (M5.BtnA.wasPressed()) {
    bool ok = run_calibration_wizard(g_has_mag);
    Serial.printf("[WIZ] ok=%d\n", (int)ok);

    have_blob = load_cal_from_nvs();
    draw_status("");
  }

  // live print (serial only)
  Vector3f a_raw, w_raw, m_raw;
  float tempC;
  uint32_t mask;
  if (read_sensors(a_raw, w_raw, m_raw, tempC, mask)) {
    Vector3f a_cal = applyAccel(a_raw, tempC);
    Vector3f w_cal = applyGyro(w_raw, tempC);
    Vector3f m_cal = applyMag(m_raw);

    uint32_t now = millis();
    if (now - last_print_ms > 300) {
      last_print_ms = now;
      Serial.printf("T:%.2f a:%+.3f,%+.3f,%+.3f w:%+.4f,%+.4f,%+.4f m:%+.2f,%+.2f,%+.2f\n",
        (double)tempC,
        (double)a_cal.x(), (double)a_cal.y(), (double)a_cal.z(),
        (double)w_cal.x(), (double)w_cal.y(), (double)w_cal.z(),
        (double)m_cal.x(), (double)m_cal.y(), (double)m_cal.z());
    }
  }

  delay(5);
}
