/*
  AtomS3R IMU calibration wizard (Accel + Gyro + Mag) using imu_cal::* calibrators.

  Key UX fixes:
  - NEVER silently returns to main screen:
      * Keeps last fail reason + shows it on status screen.
      * Failure screens stay up long enough to read (and also print to Serial).
  - Human-paced:
      * Each pose has a reposition countdown.
      * Wizard waits for STILLNESS before sampling.
      * Sampling only happens while still.
  - Edge-pose friendly:
      * USB-side / edge poses are harder; allows higher gyro threshold.
      * If accepted stays 0 for too long, it shows specific help and retries the same pose.

  REQUIREMENTS:
    - M5Unified library
    - ESP32 Arduino core (Preferences)
    - ArduinoEigenDense
    - CalibrateIMU_alt.h

  Units:
    accel: m/s^2   (auto-detect g-units vs m/s^2)
    gyro:  rad/s
    mag:   uT      (auto-detect /10 scaling)
*/

struct CalBlobV1;

#include <M5Unified.h>
#include <Arduino.h>
#include <Preferences.h>
#include <stdint.h>
#include <string.h>
#include <math.h>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
#define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif
#include <ArduinoEigenDense.h>

using M5_IMU = decltype(M5.Imu);
#include "CalibrateIMU_alt.h"

using Vector3f = Eigen::Matrix<float,3,1>;
using Matrix3f = Eigen::Matrix<float,3,3>;

static constexpr float g_std   = 9.80665f;
static constexpr float DEG2RAD = 3.14159265358979323846f / 180.0f;

// ----------------------------
// Timing (human-friendly)
// ----------------------------
static constexpr uint32_t REPOSITION_COUNTDOWN_MS  = 12000;   // time to move/position
static constexpr uint32_t WAIT_STILL_LIMIT_MS      = 80000;   // allowed time to become still
static constexpr uint32_t FACE_TIME_LIMIT_MS       = 160000;  // per accel face
static constexpr uint32_t GYRO_TIME_LIMIT_MS       = 120000;
static constexpr uint32_t MAG_TIME_LIMIT_MS        = 260000;

static constexpr uint32_t SAMPLE_PERIOD_MS         = 40;      // 25 Hz feed
static constexpr uint32_t UI_REFRESH_MS            = 150;

static constexpr uint32_t CANCEL_HOLD_MS           = 2000;    // hold BtnA to cancel
static constexpr uint32_t STILL_HOLD_MS            = 1800;    // must be still this long before sampling
static constexpr uint32_t NO_ACCEPT_HELP_MS        = 12000;   // show help if accepted==0 for this long

// accepted targets (buffer is 400 total)
static constexpr int ACC_FACE_NEED = 60;    // 6 faces -> 360
static constexpr int GYRO_NEED     = 250;
static constexpr int MAG_NEED      = 300;

// ----------------------------
// Stillness thresholds
// ----------------------------
static constexpr float STILL_W_RAD_S_FLAT  = 0.06f;  // ~3.4 deg/s
static constexpr float STILL_A_REL_FLAT    = 0.08f;  // ±8% of g
static constexpr float STILL_W_RAD_S_EDGE  = 0.14f;  // ~8 deg/s (edge poses wobble more)
static constexpr float STILL_A_REL_EDGE    = 0.14f;  // ±14% of g

// ----------------------------
// Axis mapping (your existing path)
// acc_body = ( ay, ax, -az ) * g
// gyr_body = ( gy, gx, -gz ) * deg2rad
// mag_body = ( my, mx, -mz ) * (1/10)   (auto-detected)
// ----------------------------
static float g_acc_scale = g_std;  // if accel is in g-units => *g_std; else 1.0
static float g_mag_scale = 0.1f;   // if mag needs /10 => 0.1; else 1.0

static inline Vector3f map_acc_to_body_ned_scaled(const m5::imu_3d_t& a_in) {
  return Vector3f(
    a_in.y * g_acc_scale,
    a_in.x * g_acc_scale,
   -a_in.z * g_acc_scale
  );
}
static inline Vector3f map_gyr_to_body_ned(const m5::imu_3d_t& w_deg_s) {
  return Vector3f(
    w_deg_s.y * DEG2RAD,
    w_deg_s.x * DEG2RAD,
   -w_deg_s.z * DEG2RAD
  );
}
static inline Vector3f map_mag_to_body_uT_scaled(const m5::imu_3d_t& m_in) {
  return Vector3f(
    m_in.y * g_mag_scale,
    m_in.x * g_mag_scale,
   -m_in.z * g_mag_scale
  );
}

// ----------------------------
// NVS blob
// ----------------------------
static constexpr uint32_t IMU_CAL_MAGIC   = 0x434C554D; // 'MULC'
static constexpr uint16_t IMU_CAL_VERSION = 1;

static uint32_t crc32_ieee(const uint8_t* data, size_t n) {
  uint32_t crc = 0xFFFFFFFFu;
  for (size_t i = 0; i < n; ++i) {
    crc ^= (uint32_t)data[i];
    for (int k = 0; k < 8; ++k) {
      uint32_t mask = -(crc & 1u);
      crc = (crc >> 1) ^ (0xEDB88320u & mask);
    }
  }
  return ~crc;
}

struct CalBlobV1 {
  uint32_t magic = IMU_CAL_MAGIC;
  uint16_t version = IMU_CAL_VERSION;
  uint16_t size_bytes = sizeof(CalBlobV1);

  uint8_t  accel_ok = 0;
  float    accel_g = g_std;
  float    accel_S[9];
  float    accel_T0 = 25.0f;
  float    accel_b0[3];
  float    accel_k[3];
  float    accel_rms_mag = 0.0f;

  uint8_t  gyro_ok = 0;
  float    gyro_T0 = 25.0f;
  float    gyro_b0[3];
  float    gyro_k[3];

  uint8_t  mag_ok = 0;
  float    mag_A[9];
  float    mag_b[3];
  float    mag_field_uT = 0.0f;
  float    mag_rms = 0.0f;

  uint32_t crc = 0;
};

static Preferences prefs;
static bool have_blob = false;
static CalBlobV1 cal_blob;

// runtime calibrations
static imu_cal::AccelCalibration<float> g_acc_cal;
static imu_cal::GyroCalibration<float>  g_gyr_cal;
static imu_cal::MagCalibration<float>   g_mag_cal;

// ----------------------------
// Wizard status reporting (so it never "mysteriously returns")
// ----------------------------
enum class WizFail : uint8_t {
  NONE = 0,
  CANCEL,
  STILL_TIMEOUT,
  FACE_TIMEOUT,
  FACE_ZERO_ACCEPT,
  ACC_FIT_FAIL,
  GYRO_TIMEOUT,
  GYRO_FIT_FAIL,
  MAG_TIMEOUT,
  MAG_FIT_FAIL,
  SAVE_FAIL,
  READBACK_FAIL,
};

static WizFail g_last_fail = WizFail::NONE;
static char    g_last_fail_detail[64] = {0};
static int     g_face_accepted[6] = {0};

static const char* fail_name(WizFail f) {
  switch (f) {
    case WizFail::NONE: return "NONE";
    case WizFail::CANCEL: return "CANCEL";
    case WizFail::STILL_TIMEOUT: return "STILL_TIMEOUT";
    case WizFail::FACE_TIMEOUT: return "FACE_TIMEOUT";
    case WizFail::FACE_ZERO_ACCEPT: return "FACE_ZERO_ACCEPT";
    case WizFail::ACC_FIT_FAIL: return "ACC_FIT_FAIL";
    case WizFail::GYRO_TIMEOUT: return "GYRO_TIMEOUT";
    case WizFail::GYRO_FIT_FAIL: return "GYRO_FIT_FAIL";
    case WizFail::MAG_TIMEOUT: return "MAG_TIMEOUT";
    case WizFail::MAG_FIT_FAIL: return "MAG_FIT_FAIL";
    case WizFail::SAVE_FAIL: return "SAVE_FAIL";
    case WizFail::READBACK_FAIL: return "READBACK_FAIL";
    default: return "UNKNOWN";
  }
}

static void set_fail(WizFail f, const char* detail = "") {
  g_last_fail = f;
  strncpy(g_last_fail_detail, detail ? detail : "", sizeof(g_last_fail_detail)-1);
  g_last_fail_detail[sizeof(g_last_fail_detail)-1] = 0;
  Serial.printf("[WIZ_FAIL] %s : %s\n", fail_name(f), g_last_fail_detail);
}

// ----------------------------
// Matrix helpers
// ----------------------------
static Matrix3f mat_from_rowmajor9(const float a[9]) {
  Matrix3f M;
  M << a[0], a[1], a[2],
       a[3], a[4], a[5],
       a[6], a[7], a[8];
  return M;
}
static void mat_to_rowmajor9(const Matrix3f& M, float a[9]) {
  a[0]=M(0,0); a[1]=M(0,1); a[2]=M(0,2);
  a[3]=M(1,0); a[4]=M(1,1); a[5]=M(1,2);
  a[6]=M(2,0); a[7]=M(2,1); a[8]=M(2,2);
}

static void rebuild_runtime_cals_from_blob() {
  g_acc_cal.ok = (cal_blob.accel_ok != 0);
  g_acc_cal.g  = cal_blob.accel_g;
  g_acc_cal.S  = mat_from_rowmajor9(cal_blob.accel_S);
  g_acc_cal.biasT.ok = g_acc_cal.ok;
  g_acc_cal.biasT.T0 = cal_blob.accel_T0;
  g_acc_cal.biasT.b0 = Vector3f(cal_blob.accel_b0[0], cal_blob.accel_b0[1], cal_blob.accel_b0[2]);
  g_acc_cal.biasT.k  = Vector3f(cal_blob.accel_k[0],  cal_blob.accel_k[1],  cal_blob.accel_k[2]);
  g_acc_cal.rms_mag  = cal_blob.accel_rms_mag;

  g_gyr_cal.ok = (cal_blob.gyro_ok != 0);
  g_gyr_cal.S  = Matrix3f::Identity();
  g_gyr_cal.biasT.ok = g_gyr_cal.ok;
  g_gyr_cal.biasT.T0 = cal_blob.gyro_T0;
  g_gyr_cal.biasT.b0 = Vector3f(cal_blob.gyro_b0[0], cal_blob.gyro_b0[1], cal_blob.gyro_b0[2]);
  g_gyr_cal.biasT.k  = Vector3f(cal_blob.gyro_k[0],  cal_blob.gyro_k[1],  cal_blob.gyro_k[2]);

  g_mag_cal.ok = (cal_blob.mag_ok != 0);
  g_mag_cal.A  = mat_from_rowmajor9(cal_blob.mag_A);
  g_mag_cal.b  = Vector3f(cal_blob.mag_b[0], cal_blob.mag_b[1], cal_blob.mag_b[2]);
  g_mag_cal.field_uT = cal_blob.mag_field_uT;
  g_mag_cal.rms      = cal_blob.mag_rms;
}

static bool load_cal_from_nvs() {
  if (!prefs.begin("imu_cal", true)) return false;
  size_t n = prefs.getBytesLength("blob");
  if (n != sizeof(CalBlobV1)) { prefs.end(); return false; }
  CalBlobV1 tmp;
  size_t got = prefs.getBytes("blob", &tmp, sizeof(tmp));
  prefs.end();
  if (got != sizeof(tmp)) return false;
  if (tmp.magic != IMU_CAL_MAGIC || tmp.version != IMU_CAL_VERSION || tmp.size_bytes != sizeof(CalBlobV1))
    return false;

  uint32_t want = tmp.crc;
  tmp.crc = 0;
  uint32_t have = crc32_ieee((const uint8_t*)&tmp, sizeof(tmp));
  if (have != want) return false;

  cal_blob = tmp;
  rebuild_runtime_cals_from_blob();
  return true;
}

static bool save_cal_to_nvs(const CalBlobV1& blob_in) {
  CalBlobV1 tmp = blob_in;
  tmp.magic = IMU_CAL_MAGIC;
  tmp.version = IMU_CAL_VERSION;
  tmp.size_bytes = sizeof(CalBlobV1);
  tmp.crc = 0;
  tmp.crc = crc32_ieee((const uint8_t*)&tmp, sizeof(tmp));

  if (!prefs.begin("imu_cal", false)) return false;
  size_t wrote = prefs.putBytes("blob", &tmp, sizeof(tmp));
  prefs.end();
  return (wrote == sizeof(tmp));
}

// ----------------------------
// Apply functions
// ----------------------------
static inline Vector3f applyAccel(const Vector3f& a_raw_body, float tempC) {
  if (!g_acc_cal.ok) return a_raw_body;
  return g_acc_cal.apply(a_raw_body, tempC);
}
static inline Vector3f applyGyro(const Vector3f& w_raw_body, float tempC) {
  if (!g_gyr_cal.ok) return w_raw_body;
  return g_gyr_cal.apply(w_raw_body, tempC);
}
static inline Vector3f applyMag(const Vector3f& m_raw_uT_body) {
  if (!g_mag_cal.ok) return m_raw_uT_body;
  return g_mag_cal.apply(m_raw_uT_body);
}

// ----------------------------
// UI helpers
// ----------------------------
static auto& disp = M5.Display;

static void ui_clear(uint16_t bg = TFT_BLACK) { disp.fillScreen(bg); }
static void ui_title(const char* s) {
  disp.setTextColor(TFT_WHITE, TFT_BLACK);
  disp.setCursor(0, 0);
  disp.setTextSize(2);
  disp.println(s);
  disp.setTextSize(1);
  disp.println();
}
static void ui_line(const char* s) {
  disp.setTextColor(TFT_WHITE, TFT_BLACK);
  disp.println(s);
}
static void ui_progress(const char* label, int done, int total) {
  if (total <= 0) total = 1;
  if (done < 0) done = 0;
  if (done > total) done = total;
  int w = disp.width() - 10;
  int x = 5;
  int y = disp.height() - 18;
  int h = 10;
  disp.fillRect(0, y - 14, disp.width(), 32, TFT_BLACK);
  disp.setCursor(0, y - 14);
  disp.setTextColor(TFT_CYAN, TFT_BLACK);
  disp.printf("%s %d/%d\n", label, done, total);
  disp.drawRect(x, y, w, h, TFT_DARKGREY);
  int fillw = (w - 2) * done / total;
  disp.fillRect(x + 1, y + 1, fillw, h - 2, TFT_GREEN);
}

static bool cancel_requested() {
  static uint32_t t_down = 0;
  M5.update();
  if (M5.BtnA.isPressed()) {
    if (t_down == 0) t_down = millis();
    if (millis() - t_down >= CANCEL_HOLD_MS) { t_down = 0; return true; }
  } else {
    t_down = 0;
  }
  return false;
}

// shows message for at least min_ms; auto-exits after max_ms; BtnA can exit after min_ms
static void show_msg_blocking(const char* title, const char* l1, const char* l2 = "",
                              const char* l3 = "", uint32_t min_ms = 6000, uint32_t max_ms = 30000)
{
  ui_clear();
  ui_title(title);
  if (l1 && l1[0]) ui_line(l1);
  if (l2 && l2[0]) ui_line(l2);
  if (l3 && l3[0]) ui_line(l3);
  disp.println();
  disp.setTextColor(TFT_YELLOW, TFT_BLACK);
  disp.println("BtnA = exit (after a bit)");
  uint32_t t0 = millis();
  while (true) {
    M5.update();
    uint32_t dt = millis() - t0;
    if (dt >= max_ms) break;
    if (dt >= min_ms && M5.BtnA.wasPressed()) break;
    delay(10);
  }
}

// ----------------------------
// Calibrators & sensor read
// ----------------------------
static imu_cal::AccelCalibrator<float, 400, 8> accelCal;
static imu_cal::GyroCalibrator<float, 400, 8>  gyroCal;
static imu_cal::MagCalibrator<float, 400>      magCal;

static bool read_sensors(Vector3f& a_raw_body, Vector3f& w_raw_body, Vector3f& m_raw_uT_body,
                         float& tempC, uint32_t& mask_out, float& a_mag, float& w_mag)
{
  mask_out = M5.Imu.update();
  if (!mask_out) return false;

  auto data = M5.Imu.getImuData();
  tempC = NAN;
  M5.Imu.getTemp(&tempC);

  a_raw_body    = map_acc_to_body_ned_scaled(data.accel);
  w_raw_body    = map_gyr_to_body_ned(data.gyro);
  m_raw_uT_body = map_mag_to_body_uT_scaled(data.mag);

  a_mag = a_raw_body.norm();
  w_mag = w_raw_body.norm();
  return true;
}

static bool is_still(float a_mag, float w_mag, bool edge_pose) {
  float w_thr = edge_pose ? STILL_W_RAD_S_EDGE : STILL_W_RAD_S_FLAT;
  float a_rel_thr = edge_pose ? STILL_A_REL_EDGE : STILL_A_REL_FLAT;
  float a_rel = fabsf(a_mag - g_std) / g_std;
  return (w_mag <= w_thr) && (a_rel <= a_rel_thr);
}

// ----------------------------
// Autodetect accel + mag scaling
// ----------------------------
static void autodetect_scales() {
  float a_norm_avg = 0.0f;
  float m_norm_avg = 0.0f;
  int n = 0;

  uint32_t t0 = millis();
  while (millis() - t0 < 900) {
    uint32_t mask = M5.Imu.update();
    if (!mask) { delay(5); continue; }
    auto d = M5.Imu.getImuData();
    float a0 = sqrtf(d.accel.x*d.accel.x + d.accel.y*d.accel.y + d.accel.z*d.accel.z);
    float m0 = sqrtf(d.mag.x*d.mag.x + d.mag.y*d.mag.y + d.mag.z*d.mag.z);
    a_norm_avg += a0;
    m_norm_avg += m0;
    n++;
    delay(10);
  }
  if (n <= 0) return;
  a_norm_avg /= (float)n;
  m_norm_avg /= (float)n;

  g_acc_scale = (a_norm_avg > 4.0f) ? 1.0f : g_std;     // m/s^2 vs g
  g_mag_scale = (m_norm_avg > 120.0f) ? 0.1f : 1.0f;    // /10 vs 1x

  Serial.printf("[SCALE] accel_norm_avg=%.3f -> acc_scale=%s, mag_norm_avg=%.1f -> mag_scale=%s\n",
    (double)a_norm_avg,
    (g_acc_scale == g_std) ? "*g" : "1x",
    (double)m_norm_avg,
    (g_mag_scale == 0.1f) ? "/10" : "1x");
}

// ----------------------------
// Countdown + stillness wait
// ----------------------------
static bool reposition_countdown(const char* title, const char* text, uint32_t ms) {
  ui_clear();
  ui_title(title);
  ui_line(text);
  disp.println();
  disp.setTextColor(TFT_WHITE, TFT_BLACK);
  disp.println("No button needed.");
  disp.println("It will start when");
  disp.println("it becomes STILL.");
  disp.println("Hold BtnA=cancel");

  uint32_t t0 = millis();
  uint32_t last_ui = 0;

  while (millis() - t0 < ms) {
    if (cancel_requested()) { set_fail(WizFail::CANCEL, "during reposition"); return false; }
    if (millis() - last_ui > UI_REFRESH_MS) {
      last_ui = millis();
      uint32_t remain = ms - (millis() - t0);
      uint32_t s = (remain + 999) / 1000;
      int y = disp.height() - 36;
      disp.fillRect(0, y, disp.width(), 36, TFT_BLACK);
      disp.setCursor(0, y);
      disp.setTextColor(TFT_YELLOW, TFT_BLACK);
      disp.printf("Starting in %lus\n", (unsigned long)s);
      disp.setTextColor(TFT_WHITE, TFT_BLACK);
      disp.println("Get it positioned");
    }
    delay(10);
  }
  return true;
}

static bool wait_until_still(bool edge_pose, uint32_t limit_ms) {
  ui_clear();
  ui_title("WAIT STILL");
  ui_line("Waiting for STILL...");
  ui_line("Lean/support it.");
  ui_line("Hold BtnA=cancel");

  uint32_t t0 = millis();
  uint32_t t_still0 = 0;
  uint32_t last_ui = 0;

  while (millis() - t0 < limit_ms) {
    if (cancel_requested()) { set_fail(WizFail::CANCEL, "during still wait"); return false; }

    Vector3f a, w, m;
    float tempC, amag, wmag;
    uint32_t mask;
    if (!read_sensors(a, w, m, tempC, mask, amag, wmag)) { delay(2); continue; }

    bool still = is_still(amag, wmag, edge_pose);
    if (still) {
      if (t_still0 == 0) t_still0 = millis();
      if (millis() - t_still0 >= STILL_HOLD_MS) return true;
    } else {
      t_still0 = 0;
    }

    if (millis() - last_ui > UI_REFRESH_MS) {
      last_ui = millis();
      disp.setCursor(0, 110);
      disp.fillRect(0, 110, disp.width(), 40, TFT_BLACK);
      disp.setTextColor(TFT_CYAN, TFT_BLACK);
      disp.printf("|a|=%.2f  |w|=%.3f\n", (double)amag, (double)wmag);
      disp.setTextColor(TFT_YELLOW, TFT_BLACK);
      disp.printf("STILL: %s\n", still ? "YES (holding...)" : "NO");
    }
    delay(8);
  }

  set_fail(WizFail::STILL_TIMEOUT, edge_pose ? "edge pose" : "flat pose");
  show_msg_blocking("TIMEOUT", "Couldn't get STILL.", "Use mug/book support.", "Then retry.", 8000, 30000);
  return false;
}

// ----------------------------
// Accel face capture (only feed when still)
// ----------------------------
static bool capture_accel_face(int face_idx, const char* face_title, bool edge_pose, int need, uint32_t timeout_ms) {
  ui_clear();
  ui_title("ACCEL CAPTURE");
  ui_line(face_title);
  disp.println();
  ui_line("Sampling only when STILL.");
  ui_line("Hold BtnA=cancel");

  uint32_t t0 = millis();
  uint32_t last_sample = 0;
  uint32_t last_ui = 0;
  uint32_t no_accept_since = millis();

  const int start_n = accelCal.buf.n;

  while (millis() - t0 < timeout_ms) {
    if (cancel_requested()) { set_fail(WizFail::CANCEL, "during accel capture"); return false; }

    Vector3f a, w, m;
    float tempC, amag, wmag;
    uint32_t mask;
    if (!read_sensors(a, w, m, tempC, mask, amag, wmag)) { delay(2); continue; }

    bool still = is_still(amag, wmag, edge_pose);

    uint32_t now = millis();
    if (now - last_sample >= SAMPLE_PERIOD_MS) {
      last_sample = now;
      if (still) {
        int before = accelCal.buf.n;
        accelCal.addSample(a, w, tempC);
        if (accelCal.buf.n > before) {
          no_accept_since = now;
        }
      }
    }

    int got = accelCal.buf.n - start_n;
    ui_progress("Accepted", got, need);

    // If we haven't accepted ANYTHING for too long -> show help and abort (so caller retries pose)
    if (got == 0 && (now - no_accept_since) >= NO_ACCEPT_HELP_MS) {
      set_fail(WizFail::FACE_ZERO_ACCEPT, face_title);
      show_msg_blocking(
        "0 ACCEPTED",
        "This pose is wobbling.",
        "EDGE poses MUST be",
        "leaned/supported.",
        12000, 45000
      );
      return false;
    }

    if (millis() - last_ui > UI_REFRESH_MS) {
      last_ui = millis();
      disp.setCursor(0, 110);
      disp.fillRect(0, 110, disp.width(), 40, TFT_BLACK);
      disp.setTextColor(TFT_CYAN, TFT_BLACK);
      disp.printf("|a|=%.2f  |w|=%.3f\n", (double)amag, (double)wmag);
      disp.setTextColor(TFT_YELLOW, TFT_BLACK);
      disp.printf("STILL: %s\n", still ? "YES" : "NO");
    }

    if (got >= need) {
      g_face_accepted[face_idx] = got;
      Serial.printf("[ACC_FACE] %d accepted=%d\n", face_idx+1, got);

      char buf[48];
      snprintf(buf, sizeof(buf), "Captured: %d accepted", got);
      show_msg_blocking("FACE OK", face_title, buf, "", 2000, 6000);
      return true;
    }

    delay(5);
  }

  set_fail(WizFail::FACE_TIMEOUT, face_title);
  show_msg_blocking("TIMEOUT", "Not enough accepted.", "Try steadier support.", face_title, 9000, 30000);
  return false;
}

// ----------------------------
// Gyro + Mag capture
// ----------------------------
static bool capture_gyro(uint32_t timeout_ms) {
  ui_clear();
  ui_title("GYRO CAPTURE");
  ui_line("DISPLAY UP on table.");
  ui_line("Don't touch it.");
  ui_line("Hold BtnA=cancel");

  uint32_t t0 = millis();
  uint32_t last_sample = 0;
  int start_n = gyroCal.buf.n;

  while (millis() - t0 < timeout_ms) {
    if (cancel_requested()) { set_fail(WizFail::CANCEL, "during gyro capture"); return false; }

    Vector3f a, w, m;
    float tempC, amag, wmag;
    uint32_t mask;
    if (!read_sensors(a, w, m, tempC, mask, amag, wmag)) { delay(2); continue; }

    uint32_t now = millis();
    if (now - last_sample >= SAMPLE_PERIOD_MS) {
      last_sample = now;
      gyroCal.addSample(w, a, tempC);
    }

    int got = gyroCal.buf.n - start_n;
    ui_progress("Accepted", got, GYRO_NEED);
    if (got >= GYRO_NEED) return true;

    delay(5);
  }

  set_fail(WizFail::GYRO_TIMEOUT, "gyro samples");
  show_msg_blocking("GYRO TIMEOUT", "Not enough samples.", "Was it moving?", "", 8000, 30000);
  return false;
}

static bool capture_mag(uint32_t timeout_ms) {
  ui_clear();
  ui_title("MAG CAPTURE");
  ui_line("Rotate slowly.");
  ui_line("Big loops/figure-8");
  ui_line("Hold BtnA=cancel");

  uint32_t t0 = millis();
  int start_n = magCal.buf.n;

  while (millis() - t0 < timeout_ms) {
    if (cancel_requested()) { set_fail(WizFail::CANCEL, "during mag capture"); return false; }

    Vector3f a, w, m;
    float tempC, amag, wmag;
    uint32_t mask;
    if (!read_sensors(a, w, m, tempC, mask, amag, wmag)) { delay(2); continue; }

    if (mask & (uint32_t)M5_IMU::sensor_mask_mag) {
      magCal.addSample(m);
    }

    int got = magCal.buf.n - start_n;
    ui_progress("Accepted", got, MAG_NEED);
    if (got >= MAG_NEED) return true;

    delay(8);
  }

  set_fail(WizFail::MAG_TIMEOUT, "mag samples");
  show_msg_blocking("MAG TIMEOUT", "Not enough samples.", "Rotate longer/wider.", "", 8000, 30000);
  return false;
}

// ----------------------------
// Wizard
// ----------------------------
static bool run_calibration_wizard() {
  g_last_fail = WizFail::NONE;
  g_last_fail_detail[0] = 0;
  for (int i=0;i<6;i++) g_face_accepted[i]=0;

  // wipe M5 offsets + disable internal
  M5.Imu.setCalibration(0, 0, 0);
  M5.Imu.clearOffsetData();

  accelCal.clear();
  gyroCal.clear();
  magCal.clear();

  ui_clear();
  ui_title("IMU CAL");
  ui_line("6 accel poses.");
  ui_line("EDGE poses must be");
  ui_line("LEANED/SUPPORTED.");
  ui_line("Hold BtnA=cancel");
  delay(3000);

  struct Face {
    const char* setup;
    const char* title;
    bool edge;
  } faces[6] = {
    {"FACE 1/6\nDISPLAY UP\n(flat on table)",                      "1/6 DISPLAY UP", false},
    {"FACE 2/6\nDISPLAY DOWN\n(flat on table)",                    "2/6 DISPLAY DOWN", false},

    {"FACE 3/6 (EDGE)\nUSB SIDE DOWN\n(port hole faces table)\nIMPORTANT:\nUSB HOLE MUST NOT TOUCH!\nUse 2 coins/spacers.\nLean against mug/book.",
                                                                 "3/6 USB SIDE DOWN", true},

    {"FACE 4/6 (EDGE)\nTOP SIDE DOWN\n(edge opposite USB)\n(USB points up)\nLean against mug/book.",
                                                                 "4/6 TOP SIDE DOWN", true},

    {"FACE 5/6 (EDGE)\nLEFT EDGE DOWN\n(when screen faces you)\nLean against mug/book.",
                                                                 "5/6 LEFT EDGE DOWN", true},

    {"FACE 6/6 (EDGE)\nRIGHT EDGE DOWN\n(when screen faces you)\nLean against mug/book.",
                                                                 "6/6 RIGHT EDGE DOWN", true},
  };

  for (int i = 0; i < 6; ++i) {
    // Retry same face until it actually captures.
    while (true) {
      if (!reposition_countdown("ACCEL SETUP", faces[i].setup, REPOSITION_COUNTDOWN_MS)) return false;
      if (!wait_until_still(faces[i].edge, WAIT_STILL_LIMIT_MS)) return false;

      bool ok = capture_accel_face(i, faces[i].title, faces[i].edge, ACC_FACE_NEED, FACE_TIME_LIMIT_MS);
      if (ok) break;

      // If capture failed (zero accept / timeout), retry same face.
      // Keep going unless user canceled.
      if (g_last_fail == WizFail::CANCEL) return false;
    }
  }

  // Fit accel (this is where you are likely failing)
  ui_clear();
  ui_title("FITTING");
  ui_line("Fitting ACCEL...");
  delay(800);

  imu_cal::AccelCalibration<float> acc_out;
  bool acc_fit_ok = accelCal.fit(acc_out, /*robust_iters=*/3, /*trim_frac=*/0.15f);

  Serial.printf("[ACC_FIT] fit_ok=%d acc_ok=%d rms|g|=%.5f\n",
    (int)acc_fit_ok, (int)acc_out.ok, (double)acc_out.rms_mag);

  if (!acc_fit_ok || !acc_out.ok) {
    set_fail(WizFail::ACC_FIT_FAIL, "accelCal.fit failed");

    char lineA[64];
    snprintf(lineA, sizeof(lineA), "Counts: %d %d %d %d %d %d",
      g_face_accepted[0], g_face_accepted[1], g_face_accepted[2],
      g_face_accepted[3], g_face_accepted[4], g_face_accepted[5]);

    show_msg_blocking("ACCEL FIT FAIL",
      "Accel fit rejected.",
      lineA,
      "Try steadier / more distinct poses.",
      15000, 60000
    );
    return false;
  }

  show_msg_blocking("ACCEL OK", "Accel fit OK.", "Next: GYRO", "", 2500, 6000);

  // Gyro
  if (!reposition_countdown("GYRO SETUP", "DISPLAY UP on table.\nDon't touch it.", 9000)) return false;
  if (!wait_until_still(false, WAIT_STILL_LIMIT_MS)) return false;
  if (!capture_gyro(GYRO_TIME_LIMIT_MS)) return false;

  ui_clear();
  ui_title("FITTING");
  ui_line("Fitting GYRO...");
  delay(800);

  imu_cal::GyroCalibration<float> gyr_out;
  bool gyr_fit_ok = gyroCal.fit(gyr_out);

  Serial.printf("[GYR_FIT] fit_ok=%d gyr_ok=%d\n", (int)gyr_fit_ok, (int)gyr_out.ok);

  if (!gyr_fit_ok || !gyr_out.ok) {
    set_fail(WizFail::GYRO_FIT_FAIL, "gyroCal.fit failed");
    show_msg_blocking("GYRO FIT FAIL", "Gyro fit rejected.", "Was it moving?", "", 12000, 45000);
    return false;
  }

  show_msg_blocking("GYRO OK", "Gyro fit OK.", "Next: MAG", "", 2500, 6000);

  // Mag
  show_msg_blocking("MAG SETUP", "Pick up and rotate slowly.", "Big loops / figure-8.", "", 5000, 12000);
  if (!capture_mag(MAG_TIME_LIMIT_MS)) return false;

  ui_clear();
  ui_title("FITTING");
  ui_line("Fitting MAG...");
  delay(800);

  imu_cal::MagCalibration<float> mag_out;
  bool mag_fit_ok = magCal.fit(mag_out, /*robust_iters=*/3, /*trim_frac=*/0.15f);

  Serial.printf("[MAG_FIT] fit_ok=%d mag_ok=%d B=%.2f rms=%.3f\n",
    (int)mag_fit_ok, (int)mag_out.ok, (double)mag_out.field_uT, (double)mag_out.rms);

  if (!mag_fit_ok || !mag_out.ok) {
    set_fail(WizFail::MAG_FIT_FAIL, "magCal.fit failed");
    show_msg_blocking("MAG FIT FAIL", "Mag fit rejected.", "Rotate longer/wider.", "Away from metal.", 14000, 60000);
    return false;
  }

  // Build + save blob
  CalBlobV1 blob;
  memset(&blob, 0, sizeof(blob));
  blob.magic = IMU_CAL_MAGIC;
  blob.version = IMU_CAL_VERSION;
  blob.size_bytes = sizeof(CalBlobV1);

  blob.accel_ok = acc_out.ok ? 1 : 0;
  blob.accel_g = acc_out.g;
  mat_to_rowmajor9(acc_out.S, blob.accel_S);
  blob.accel_T0 = acc_out.biasT.T0;
  blob.accel_b0[0]=acc_out.biasT.b0.x(); blob.accel_b0[1]=acc_out.biasT.b0.y(); blob.accel_b0[2]=acc_out.biasT.b0.z();
  blob.accel_k[0]=acc_out.biasT.k.x();   blob.accel_k[1]=acc_out.biasT.k.y();   blob.accel_k[2]=acc_out.biasT.k.z();
  blob.accel_rms_mag = acc_out.rms_mag;

  blob.gyro_ok = gyr_out.ok ? 1 : 0;
  blob.gyro_T0 = gyr_out.biasT.T0;
  blob.gyro_b0[0]=gyr_out.biasT.b0.x(); blob.gyro_b0[1]=gyr_out.biasT.b0.y(); blob.gyro_b0[2]=gyr_out.biasT.b0.z();
  blob.gyro_k[0]=gyr_out.biasT.k.x();   blob.gyro_k[1]=gyr_out.biasT.k.y();   blob.gyro_k[2]=gyr_out.biasT.k.z();

  blob.mag_ok = mag_out.ok ? 1 : 0;
  mat_to_rowmajor9(mag_out.A, blob.mag_A);
  blob.mag_b[0]=mag_out.b.x(); blob.mag_b[1]=mag_out.b.y(); blob.mag_b[2]=mag_out.b.z();
  blob.mag_field_uT = mag_out.field_uT;
  blob.mag_rms = mag_out.rms;

  ui_clear();
  ui_title("SAVING");
  ui_line("Writing NVS...");
  delay(400);

  bool save_ok = save_cal_to_nvs(blob);
  if (!save_ok) {
    set_fail(WizFail::SAVE_FAIL, "putBytes failed");
    show_msg_blocking("SAVE FAIL", "NVS write failed.", "Prefs/flash issue?", "", 12000, 45000);
    return false;
  }

  ui_line("Readback verify...");
  delay(300);

  have_blob = load_cal_from_nvs();
  if (!have_blob) {
    set_fail(WizFail::READBACK_FAIL, "load after save failed");
    show_msg_blocking("READBACK FAIL", "Saved but can't read.", "CRC mismatch?", "", 14000, 60000);
    return false;
  }

  // Success
  set_fail(WizFail::NONE, "success");
  ui_clear();
  ui_title("CAL DONE");
  disp.setTextColor(TFT_WHITE, TFT_BLACK);
  disp.printf("BLOB: YES\n");
  disp.printf("ACC ok:%d  rms|g|:%.4f\n", (int)g_acc_cal.ok, (double)g_acc_cal.rms_mag);
  disp.printf("GYR ok:%d\n", (int)g_gyr_cal.ok);
  disp.printf("MAG ok:%d  B:%.1f  rms:%.2f\n", (int)g_mag_cal.ok, (double)g_mag_cal.field_uT, (double)g_mag_cal.rms);
  disp.println();
  disp.printf("acc_scale=%s  mag_scale=%s\n",
              (g_acc_scale == g_std) ? "*g" : "1x",
              (g_mag_scale == 0.1f) ? "/10" : "1x");
  disp.println();
  disp.setTextColor(TFT_YELLOW, TFT_BLACK);
  disp.println("Returning in 10s...");
  delay(10000);

  return true;
}

// ----------------------------
// Status / loop
// ----------------------------
static uint32_t last_print_ms = 0;

static void draw_status() {
  ui_clear();
  ui_title("IMU CAL");

  disp.setTextColor(TFT_WHITE, TFT_BLACK);
  disp.printf("BLOB: %s\n", have_blob ? "YES" : "NO");
  disp.printf("ACC ok:%d  GYR ok:%d  MAG ok:%d\n",
              (int)g_acc_cal.ok, (int)g_gyr_cal.ok, (int)g_mag_cal.ok);

  disp.println();
  disp.setTextColor(TFT_YELLOW, TFT_BLACK);
  disp.printf("LAST: %s\n", fail_name(g_last_fail));
  if (g_last_fail_detail[0]) disp.printf("%s\n", g_last_fail_detail);

  disp.println();
  disp.setTextColor(TFT_WHITE, TFT_BLACK);
  disp.printf("acc_scale=%s  mag_scale=%s\n",
              (g_acc_scale == g_std) ? "*g" : "1x",
              (g_mag_scale == 0.1f) ? "/10" : "1x");
  disp.println();
  disp.println("BtnA: start wizard");
  disp.println("Hold BtnA 2s: cancel step");
}

void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);
  Serial.println("\n--- BOOT ---");

  M5.Imu.setCalibration(0, 0, 0);

  autodetect_scales();
  have_blob = load_cal_from_nvs();
  if (!have_blob) memset(&cal_blob, 0, sizeof(cal_blob)), rebuild_runtime_cals_from_blob();

  set_fail(WizFail::NONE, "idle");
  draw_status();

  if (!M5.Imu.isEnabled()) {
    ui_clear();
    ui_title("IMU FAIL");
    ui_line("IMU not found.");
    while (true) delay(100);
  }
}

void loop() {
  M5.update();

  if (M5.BtnA.wasPressed()) {
    bool ok = run_calibration_wizard();
    (void)ok;
    have_blob = load_cal_from_nvs();
    if (!have_blob) memset(&cal_blob, 0, sizeof(cal_blob)), rebuild_runtime_cals_from_blob();
    draw_status();
  }

  // Live read/print (slow)
  Vector3f a_raw, w_raw, m_raw;
  float tempC, amag, wmag;
  uint32_t mask;

  if (read_sensors(a_raw, w_raw, m_raw, tempC, mask, amag, wmag)) {
    Vector3f a_cal = applyAccel(a_raw, tempC);
    Vector3f w_cal = applyGyro(w_raw, tempC);
    Vector3f m_cal = applyMag(m_raw);

    uint32_t now = millis();
    if (now - last_print_ms > 500) {
      last_print_ms = now;
      Serial.printf("temp:%.2f, |a|:%.2f, |w|:%.3f, blob:%d, acc_ok:%d gyr_ok:%d mag_ok:%d\n",
        (double)tempC, (double)a_raw.norm(), (double)w_raw.norm(),
        (int)have_blob, (int)g_acc_cal.ok, (int)g_gyr_cal.ok, (int)g_mag_cal.ok);
      (void)a_cal; (void)w_cal; (void)m_cal;
    }
  }

  delay(5);
}
