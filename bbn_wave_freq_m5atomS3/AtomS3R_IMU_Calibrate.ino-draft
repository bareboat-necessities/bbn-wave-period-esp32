/*
  AtomS3R IMU calibration wizard (Accel + Gyro + Mag) using imu_cal::* calibrators.

  Fixes vs “loops too fast”:
  - Pose change is REQUIRED between faces (detect movement or gravity direction change).
  - Reposition countdown before each capture (no button needed even when screen is down).
  - Minimum capture duration per face + slower sampling rate (human speed).

  Also includes:
  - Live diagnostics: |a|, |w|, STILL yes/no, and “MOVE IT” gate.
  - Auto-detect accel/mag scale (prevents “nothing accepted” when units mismatch).
  - End screen shows FIT/SAVE/READBACK explicitly.

  REQUIREMENTS:
    - M5Unified library
    - ESP32 Arduino core (Preferences)
    - ArduinoEigenDense
    - CalibrateIMU_alt.h

  Internal units:
    accel: m/s^2
    gyro:  rad/s
    mag:   uT
*/

struct CalBlobV1;

#include <M5Unified.h>
#include <Arduino.h>
#include <Preferences.h>
#include <stdint.h>
#include <string.h>
#include <math.h>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
#define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif
#include <ArduinoEigenDense.h>

using M5_IMU = decltype(M5.Imu);
#include "CalibrateIMU_alt.h"

using Vector3f = Eigen::Matrix<float,3,1>;
using Matrix3f = Eigen::Matrix<float,3,3>;

static constexpr float g_std   = 9.80665f;
static constexpr float DEG2RAD = 3.14159265358979323846f / 180.0f;

// ----------------------------
// Human timing knobs
// ----------------------------
static constexpr uint32_t FACE_TIME_LIMIT_MS     = 120000;  // 120s per accel face max
static constexpr uint32_t GYRO_TIME_LIMIT_MS     = 70000;   // 70s
static constexpr uint32_t MAG_TIME_LIMIT_MS      = 180000;  // 180s

static constexpr uint32_t REPOSITION_COUNTDOWN_MS = 12000;  // 12s to place it
static constexpr uint32_t MIN_FACE_CAPTURE_MS     = 6000;   // each face must capture >= 6s
static constexpr uint32_t SAMPLE_PERIOD_MS        = 40;     // ~25 Hz feeding addSample()

static constexpr uint32_t UI_REFRESH_MS           = 120;
static constexpr uint32_t END_SCREEN_MIN_MS       = 7000;

static constexpr uint32_t CANCEL_HOLD_MS          = 2000;   // hold BtnA to cancel wizard

// Sample counts (accepted)
static constexpr int ACC_FACE_NEED = 90;     // per face (will take ~6–10s depending on gates)
static constexpr int GYRO_NEED     = 300;
static constexpr int MAG_NEED      = 350;

// Stillness thresholds (internal units)
static constexpr float STILL_W_RAD_S  = 0.20f;      // ~11.5 deg/s
static constexpr float STILL_A_REL    = 0.12f;      // within ±12% of 1g
static constexpr uint32_t STILL_HOLD_MS = 900;      // must be still for ~0.9s before capture

// Pose-change thresholds
static constexpr float POSE_DOT_THRESH = 0.965f;    // require >= ~15° gravity dir change between faces
static constexpr uint32_t MOVE_DETECT_HOLD_MS = 250;

// ----------------------------
// Axis mapping (your existing)
// ----------------------------
static float g_acc_scale = g_std;  // auto-detected: g_std or 1.0
static float g_mag_scale = 0.1f;   // auto-detected: 0.1 or 1.0

static inline Vector3f map_acc_to_body_ned_scaled(const m5::imu_3d_t& a_in) {
  return Vector3f(
    a_in.y * g_acc_scale,
    a_in.x * g_acc_scale,
   -a_in.z * g_acc_scale
  );
}

static inline Vector3f map_gyr_to_body_ned(const m5::imu_3d_t& w_deg_s) {
  return Vector3f(
    w_deg_s.y * DEG2RAD,
    w_deg_s.x * DEG2RAD,
   -w_deg_s.z * DEG2RAD
  );
}

static inline Vector3f map_mag_to_body_uT_scaled(const m5::imu_3d_t& m_in) {
  return Vector3f(
    m_in.y * g_mag_scale,
    m_in.x * g_mag_scale,
   -m_in.z * g_mag_scale
  );
}

// ----------------------------
// NVS blob
// ----------------------------
static constexpr uint32_t IMU_CAL_MAGIC   = 0x434C554D; // 'MULC'
static constexpr uint16_t IMU_CAL_VERSION = 1;

static uint32_t crc32_ieee(const uint8_t* data, size_t n) {
  uint32_t crc = 0xFFFFFFFFu;
  for (size_t i = 0; i < n; ++i) {
    crc ^= (uint32_t)data[i];
    for (int k = 0; k < 8; ++k) {
      uint32_t mask = -(crc & 1u);
      crc = (crc >> 1) ^ (0xEDB88320u & mask);
    }
  }
  return ~crc;
}

struct CalBlobV1 {
  uint32_t magic = IMU_CAL_MAGIC;
  uint16_t version = IMU_CAL_VERSION;
  uint16_t size_bytes = sizeof(CalBlobV1);

  uint8_t  accel_ok = 0;
  float    accel_g = g_std;
  float    accel_S[9];
  float    accel_T0 = 25.0f;
  float    accel_b0[3];
  float    accel_k[3];
  float    accel_rms_mag = 0.0f;

  uint8_t  gyro_ok = 0;
  float    gyro_T0 = 25.0f;
  float    gyro_b0[3];
  float    gyro_k[3];

  uint8_t  mag_ok = 0;
  float    mag_A[9];
  float    mag_b[3];
  float    mag_field_uT = 0.0f;
  float    mag_rms = 0.0f;

  uint32_t crc = 0;
};

static Preferences prefs;
static bool have_blob = false;
static CalBlobV1 cal_blob;

static imu_cal::AccelCalibration<float> g_acc_cal;
static imu_cal::GyroCalibration<float>  g_gyr_cal;
static imu_cal::MagCalibration<float>   g_mag_cal;

// ----------------------------
// Matrix helpers
// ----------------------------
static Matrix3f mat_from_rowmajor9(const float a[9]) {
  Matrix3f M;
  M << a[0], a[1], a[2],
       a[3], a[4], a[5],
       a[6], a[7], a[8];
  return M;
}

static void mat_to_rowmajor9(const Matrix3f& M, float a[9]) {
  a[0]=M(0,0); a[1]=M(0,1); a[2]=M(0,2);
  a[3]=M(1,0); a[4]=M(1,1); a[5]=M(1,2);
  a[6]=M(2,0); a[7]=M(2,1); a[8]=M(2,2);
}

static void rebuild_runtime_cals_from_blob() {
  g_acc_cal.ok = (cal_blob.accel_ok != 0);
  g_acc_cal.g  = cal_blob.accel_g;
  g_acc_cal.S  = mat_from_rowmajor9(cal_blob.accel_S);
  g_acc_cal.biasT.ok = g_acc_cal.ok;
  g_acc_cal.biasT.T0 = cal_blob.accel_T0;
  g_acc_cal.biasT.b0 = Vector3f(cal_blob.accel_b0[0], cal_blob.accel_b0[1], cal_blob.accel_b0[2]);
  g_acc_cal.biasT.k  = Vector3f(cal_blob.accel_k[0],  cal_blob.accel_k[1],  cal_blob.accel_k[2]);
  g_acc_cal.rms_mag  = cal_blob.accel_rms_mag;

  g_gyr_cal.ok = (cal_blob.gyro_ok != 0);
  g_gyr_cal.S  = Matrix3f::Identity();
  g_gyr_cal.biasT.ok = g_gyr_cal.ok;
  g_gyr_cal.biasT.T0 = cal_blob.gyro_T0;
  g_gyr_cal.biasT.b0 = Vector3f(cal_blob.gyro_b0[0], cal_blob.gyro_b0[1], cal_blob.gyro_b0[2]);
  g_gyr_cal.biasT.k  = Vector3f(cal_blob.gyro_k[0],  cal_blob.gyro_k[1],  cal_blob.gyro_k[2]);

  g_mag_cal.ok = (cal_blob.mag_ok != 0);
  g_mag_cal.A  = mat_from_rowmajor9(cal_blob.mag_A);
  g_mag_cal.b  = Vector3f(cal_blob.mag_b[0], cal_blob.mag_b[1], cal_blob.mag_b[2]);
  g_mag_cal.field_uT = cal_blob.mag_field_uT;
  g_mag_cal.rms      = cal_blob.mag_rms;
}

static bool load_cal_from_nvs() {
  if (!prefs.begin("imu_cal", true)) return false;
  size_t n = prefs.getBytesLength("blob");
  if (n != sizeof(CalBlobV1)) { prefs.end(); return false; }

  CalBlobV1 tmp;
  size_t got = prefs.getBytes("blob", &tmp, sizeof(tmp));
  prefs.end();
  if (got != sizeof(tmp)) return false;

  if (tmp.magic != IMU_CAL_MAGIC || tmp.version != IMU_CAL_VERSION || tmp.size_bytes != sizeof(CalBlobV1))
    return false;

  const uint32_t want = tmp.crc;
  tmp.crc = 0;
  const uint32_t have = crc32_ieee((const uint8_t*)&tmp, sizeof(tmp));
  if (have != want) return false;

  cal_blob = tmp;
  rebuild_runtime_cals_from_blob();
  return true;
}

static bool save_cal_to_nvs(const CalBlobV1& blob_in) {
  CalBlobV1 tmp = blob_in;
  tmp.magic = IMU_CAL_MAGIC;
  tmp.version = IMU_CAL_VERSION;
  tmp.size_bytes = sizeof(CalBlobV1);
  tmp.crc = 0;
  tmp.crc = crc32_ieee((const uint8_t*)&tmp, sizeof(tmp));

  if (!prefs.begin("imu_cal", false)) return false;
  const size_t wrote = prefs.putBytes("blob", &tmp, sizeof(tmp));
  prefs.end();
  return (wrote == sizeof(tmp));
}

// ----------------------------
// Apply functions
// ----------------------------
static inline Vector3f applyAccel(const Vector3f& a_raw_body, float tempC) {
  if (!g_acc_cal.ok) return a_raw_body;
  return g_acc_cal.apply(a_raw_body, tempC);
}
static inline Vector3f applyGyro(const Vector3f& w_raw_body, float tempC) {
  if (!g_gyr_cal.ok) return w_raw_body;
  return g_gyr_cal.apply(w_raw_body, tempC);
}
static inline Vector3f applyMag(const Vector3f& m_raw_uT_body) {
  if (!g
