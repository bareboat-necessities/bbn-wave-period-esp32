/*
  AtomS3R (M5Unified) — Pose Wizard (PROMPT -> CHANGE POSE -> SETTLE -> CAPTURE)

  Serial commands:
    - Send 'r' to restart to STEP 1
    - Send 'h' to print help

  Key behavior:
    - STEP 1 is ALWAYS SCREEN UP first
    - It will NOT advance until:
        (A) pose changed appropriately, AND
        (B) the new pose is held steady for SETTLE_MS, AND
        (C) then stable samples are collected for CAPTURE_MS
*/

#include <M5Unified.h>
#include <cmath>
#include <cstdint>
#include <algorithm>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
#define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif
#ifdef EIGEN_NON_ARDUINO
  #include <Eigen/Dense>
#else
  #include <ArduinoEigenDense.h>
#endif

#ifdef ARDUINO_ARCH_ESP32
  #include "esp_timer.h"
#endif

class IMUWizard {
public:
  using Vec3 = Eigen::Matrix<float,3,1>;

  // ---------------- Config ----------------
  static constexpr float    ACC_GYR_RATE_HZ = 200.0f;
  static constexpr float    MAG_RATE_HZ     = 50.0f;

  static constexpr uint32_t SETTLE_MS       = 2500;   // must be steady this long after pose-change
  static constexpr uint32_t CAPTURE_MS      = 1400;   // capture duration once settled
  static constexpr uint32_t STEP_TIMEOUT_MS = 60000;  // per-step timeout
  static constexpr uint32_t PROMPT_REPRINT_MS = 2500; // reprint prompt periodically

  // Pose-change thresholds (unit accel dot products)
  // - Opposite: dot <= this (more negative is "more opposite")
  static constexpr float DOT_OPPOSITE_MAX   = -0.85f;
  // - Orthogonal-ish: |dot| <= this (0 = perfect 90deg)
  static constexpr float DOT_ORTHO_ABS_MAX  = 0.50f;

  // "hold still" gating
  static constexpr float HOLD_COS_MIN       = 0.9988f; // slightly looser than before (~2.8 deg)
  static constexpr float ACC_NORM_REL_MAX   = 0.04f;   // 4%
  static constexpr float GYRO_ABS_MAX_RAW   = 10.0f;
  static constexpr float GYRO_FLOOR_RAW     = 0.35f;

  // ---------------- Types ----------------
  struct IMUSample {
    int64_t t_us = 0;
    Vec3 acc = Vec3::Zero();
    Vec3 gyr = Vec3::Zero();
    Vec3 mag = Vec3::Zero();
    bool have_mag = false;
  };

  struct PoseAvg {
    Vec3 acc_sum = Vec3::Zero();
    Vec3 gyr_sum = Vec3::Zero();
    Vec3 mag_sum = Vec3::Zero();
    int n = 0;
    int nmag = 0;

    void reset() { acc_sum.setZero(); gyr_sum.setZero(); mag_sum.setZero(); n=0; nmag=0; }
    void add(const IMUSample& s) {
      acc_sum += s.acc;
      gyr_sum += s.gyr;
      n++;
      if (s.have_mag) { mag_sum += s.mag; nmag++; }
    }
    Vec3 acc_mean() const { return (n>0) ? (acc_sum / (float)n) : Vec3(0,0,0); }
  };

  // Minimal mapping placeholders (you can re-add full solve later)
  struct SignedPerm {
    int8_t idx[3] = {0,1,2};
    int8_t sgn[3] = {+1,+1,+1};
    int8_t det    = +1;
  };

  void begin() {
    setup_rates_();
    restart_();
    print_help_();
  }

  void update() {
    M5.update();
    handle_serial_cmds_();

    IMUSample s;
    bool got_acc=false, got_mag=false;
    if (!scheduled_poll_(s, got_acc, got_mag)) { delay(1); return; }
    if (!got_acc) return;

    update_step_(s);
  }

private:
  // ---------------- Stage enum ----------------
  enum Stage { ST_STEP1=0, ST_STEP2, ST_STEP3, ST_STEP4, ST_SOLVE, ST_DONE };
  Stage stage_ = ST_STEP1;

  // ---------------- Step context ----------------
  int step_idx_ = 1;
  const char* step_pose_name_ = nullptr;

  int64_t step_start_us_    = 0;
  int64_t settle_start_us_  = 0;
  int64_t capture_start_us_ = 0;

  int64_t last_prompt_reprint_us_ = 0;
  int64_t last_status_print_us_   = 0;

  // Pose averages + stored pose unit directions
  PoseAvg step_avg_;
  PoseAvg pose_[4];
  Vec3    pose_unit_[4] = { Vec3(0,0,1), Vec3(0,0,-1), Vec3(1,0,0), Vec3(0,1,0) };
  bool    pose_valid_[4] = { false, false, false, false };

  // "hold still" reference for within-pose stability
  Vec3 hold_ref_unit_ = Vec3(0,0,1);
  bool hold_ref_valid_ = false;

  // ---------------- Scheduler ----------------
  int64_t next_acc_us_ = 0;
  int64_t next_mag_us_ = 0;
  int64_t acc_period_us_ = 0;
  int64_t mag_period_us_ = 0;

  uint32_t acc_ticks_ = 0;
  uint32_t mag_valid_ticks_ = 0;
  int64_t rate_t0_us_ = 0;
  int64_t rate_last_print_us_ = 0;

  IMUSample last_sample_;
  int64_t last_sample_us_ = 0;

  // ---------------- Utilities ----------------
  static inline int64_t now_us_() {
  #ifdef ARDUINO_ARCH_ESP32
    return (int64_t)esp_timer_get_time();
  #else
    return (int64_t)micros();
  #endif
  }

  static inline float clampf_(float x, float a, float b) { return std::max(a, std::min(b, x)); }

  static inline float safe_norm_(const Vec3& v) {
    float n = v.norm();
    return (std::isfinite(n) && n > 1e-12f) ? n : 0.0f;
  }

  static inline Vec3 safe_unit_(const Vec3& v, const Vec3& fallback=Vec3(0,0,1)) {
    float n = safe_norm_(v);
    return (n > 0.0f) ? (v / n) : fallback;
  }

  void print_help_() {
    Serial.println();
    Serial.println("============================================================");
    Serial.println("IMU Pose Wizard");
    Serial.println("Commands:");
    Serial.println("  r  -> restart to STEP 1");
    Serial.println("  h  -> help");
    Serial.println("Notes:");
    Serial.println("  Step labels are instructions, not the code claiming your pose.");
    Serial.println("  It will not advance until pose-change + settle + capture complete.");
    Serial.println("============================================================");
  }

  void handle_serial_cmds_() {
    while (Serial.available() > 0) {
      char c = (char)Serial.read();
      if (c == 'r' || c == 'R') {
        Serial.println("[SERIAL] Restart requested (r).");
        restart_();
      } else if (c == 'h' || c == 'H') {
        print_help_();
      }
    }
  }

  void enter_step_(int idx, const char* prompt, const char* pose_name) {
    step_idx_ = idx;
    step_pose_name_ = pose_name;

    step_start_us_ = now_us_();
    settle_start_us_ = 0;
    capture_start_us_ = 0;
    hold_ref_valid_ = false;
    step_avg_.reset();

    last_prompt_reprint_us_ = 0;
    last_status_print_us_ = 0;

    Serial.println();
    Serial.println("============================================================");
    Serial.printf("STEP %d/5:\n%s\n", idx, prompt);
    Serial.println("Type 'r' to restart at any time.");
    Serial.println("============================================================");
  }

  void restart_() {
    stage_ = ST_STEP1;
    last_sample_us_ = 0;
    hold_ref_valid_ = false;
    step_avg_.reset();

    for (int i=0;i<4;i++) pose_valid_[i] = false;

    enter_step_(1,
      "Place device SCREEN UP on a flat surface.\n"
      "Wait for pose detection, then hold still...",
      "SCREEN UP (flat)");
  }

  // ---------------- IMU read ----------------
  bool read_imu_once_(IMUSample& out) {
    (void)M5.Imu.update();
    auto d = M5.Imu.getImuData();
    out.t_us = now_us_();
    out.acc  = Vec3(d.accel.x, d.accel.y, d.accel.z);
    out.gyr  = Vec3(d.gyro.x,  d.gyro.y,  d.gyro.z);
    out.mag  = Vec3(d.mag.x,   d.mag.y,   d.mag.z);
    out.have_mag =
      std::isfinite(out.mag.x()) && std::isfinite(out.mag.y()) && std::isfinite(out.mag.z()) &&
      (std::fabs(out.mag.x()) + std::fabs(out.mag.y()) + std::fabs(out.mag.z()) > 1e-6f);
    return true;
  }

  void setup_rates_() {
    auto hz_to_period = [](float hz)->int64_t {
      if (!(hz > 0.1f)) hz = 1.0f;
      double p = 1000000.0 / (double)hz;
      if (p < 1000.0) p = 1000.0;
      return (int64_t)llround(p);
    };

    acc_period_us_ = hz_to_period(ACC_GYR_RATE_HZ);
    mag_period_us_ = hz_to_period(MAG_RATE_HZ);

    int64_t now = now_us_();
    next_acc_us_ = now + acc_period_us_;
    next_mag_us_ = now + mag_period_us_;

    rate_t0_us_ = now;
    rate_last_print_us_ = now;
    acc_ticks_ = mag_valid_ticks_ = 0;
  }

  void maybe_print_rate_(bool have_mag) {
    int64_t now = now_us_();
    if (now - rate_last_print_us_ < 1000000) return;
    rate_last_print_us_ = now;

    double dt = (now - rate_t0_us_) * 1e-6;
    if (dt <= 0.0) dt = 1.0;

    float acc_hz = (float)(acc_ticks_ / dt);
    float mag_hz = (float)(mag_valid_ticks_ / dt);

    Serial.printf("[RATE] acc/gyro observed ~%.1f Hz (target %.1f)\n", acc_hz, ACC_GYR_RATE_HZ);
    Serial.printf("[RATE] mag observed     ~%.1f Hz (target %.1f) %s\n",
                  mag_hz, MAG_RATE_HZ, have_mag ? "" : "(mag may be unavailable)");

    rate_t0_us_ = now;
    acc_ticks_ = mag_valid_ticks_ = 0;
  }

  bool scheduled_poll_(IMUSample& out, bool& got_acc, bool& got_mag) {
    got_acc = false; got_mag = false;
    int64_t now = now_us_();

    bool due_acc = (now >= next_acc_us_);
    bool due_mag = (now >= next_mag_us_);
    if (!due_acc && !due_mag) return false;

    if (due_acc) {
      int64_t late = now - next_acc_us_;
      next_acc_us_ = (late > 2*acc_period_us_) ? (now + acc_period_us_) : (next_acc_us_ + acc_period_us_);
      got_acc = true;
      acc_ticks_++;
    }
    if (due_mag) {
      int64_t late = now - next_mag_us_;
      next_mag_us_ = (late > 2*mag_period_us_) ? (now + mag_period_us_) : (next_mag_us_ + mag_period_us_);
      got_mag = true;
    }

    read_imu_once_(last_sample_);
    out = last_sample_;
    if (got_mag && out.have_mag) mag_valid_ticks_++;
    maybe_print_rate_(out.have_mag);
    return true;
  }

  // ---------------- Stillness gating ----------------
  struct Ema { float v=0.0f; bool init=false; void reset(){v=0;init=false;} float update(float x,float a){ if(!init){v=x;init=true;return v;} v=(1-a)*v+a*x; return v; } };
  Ema acc_norm_ema_;
  Ema gyro_norm_ema_;

  bool steady_enough_(const IMUSample& s, const Vec3& unit_now, float dt_s,
                      float* out_cos_ref, float* out_gn, float* out_th, float* out_an_rel)
  {
    float alpha = clampf_(dt_s / 0.35f, 0.01f, 0.25f);

    float an = safe_norm_(s.acc);
    float gn = safe_norm_(s.gyr);

    float an_ema = acc_norm_ema_.update(an, alpha);
    float gn_ema = gyro_norm_ema_.update(gn, alpha);

    float gyro_th = std::max(GYRO_FLOOR_RAW, 3.0f * gn_ema + GYRO_FLOOR_RAW);
    float an_rel  = (an_ema > 1e-6f) ? std::fabs(an - an_ema) / an_ema : 0.0f;

    if (!hold_ref_valid_) {
      hold_ref_unit_ = unit_now;
      hold_ref_valid_ = true;
    }

    float cos_ref = clampf_(unit_now.dot(hold_ref_unit_), -1.0f, 1.0f);

    bool ok = (cos_ref > HOLD_COS_MIN) &&
              (gn < gyro_th) &&
              (gn < GYRO_ABS_MAX_RAW) &&
              (an_rel < ACC_NORM_REL_MAX);

    if (out_cos_ref) *out_cos_ref = cos_ref;
    if (out_gn) *out_gn = gn;
    if (out_th) *out_th = gyro_th;
    if (out_an_rel) *out_an_rel = an_rel;

    // keep reference local if drifting
    if (cos_ref < HOLD_COS_MIN) {
      hold_ref_unit_ = unit_now;
      hold_ref_valid_ = true;
    }
    return ok;
  }

  // ---------------- Pose-change rules per step ----------------
  bool pose_change_ok_(int step_idx, const Vec3& unit_now,
                      float* d1=nullptr, float* d2=nullptr, float* d3=nullptr)
  {
    // step 1: no dependency
    if (step_idx == 1) return true;

    // we depend on earlier poses being captured
    auto dot_with = [&](int poseIndex1based)->float {
      int i = poseIndex1based - 1;
      if (i < 0 || i >= 4 || !pose_valid_[i]) return 2.0f; // invalid sentinel
      return clampf_(unit_now.dot(pose_unit_[i]), -1.0f, 1.0f);
    };

    float dot1 = dot_with(1);
    float dot2 = dot_with(2);
    float dot3 = dot_with(3);

    if (d1) *d1 = dot1;
    if (d2) *d2 = dot2;
    if (d3) *d3 = dot3;

    if (step_idx == 2) {
      // must be opposite to STEP 1
      if (dot1 > 1.5f) return false;
      return (dot1 <= DOT_OPPOSITE_MAX);
    }

    if (step_idx == 3) {
      // must be "edge": orthogonal to flat (Step 1)
      if (dot1 > 1.5f) return false;
      return (std::fabs(dot1) <= DOT_ORTHO_ABS_MAX);
    }

    if (step_idx == 4) {
      // must be edge AND different from Step 3:
      // orthogonal to flat (Step 1) AND orthogonal to right-edge (Step 3)
      if (dot1 > 1.5f || dot3 > 1.5f) return false;
      return (std::fabs(dot1) <= DOT_ORTHO_ABS_MAX) &&
             (std::fabs(dot3) <= DOT_ORTHO_ABS_MAX);
    }

    return false;
  }

  void maybe_reprint_prompt_() {
    int64_t t = now_us_();
    if (last_prompt_reprint_us_ == 0) { last_prompt_reprint_us_ = t; return; }
    if ((t - last_prompt_reprint_us_) < (int64_t)PROMPT_REPRINT_MS * 1000) return;
    last_prompt_reprint_us_ = t;

    Serial.println();
    Serial.println("------------------------------------------------------------");
    Serial.printf("CURRENT STEP %d/5: %s\n", step_idx_, step_pose_name_);
    Serial.println("Type 'r' to restart. Type 'h' for help.");
    Serial.println("------------------------------------------------------------");
  }

  void update_step_(const IMUSample& s) {
    maybe_reprint_prompt_();

    int64_t now = s.t_us;
    float dt_s = 0.01f;
    if (last_sample_us_ != 0) {
      dt_s = (float)((now - last_sample_us_) * 1e-6);
      if (!(dt_s > 0.0f && dt_s < 0.5f)) dt_s = 0.01f;
    }
    last_sample_us_ = now;

    Vec3 unit_now = safe_unit_(s.acc, Vec3(0,0,1));

    float dot1=0, dot2=0, dot3=0;
    bool change_ok = pose_change_ok_(step_idx_, unit_now, &dot1, &dot2, &dot3);

    float cos_ref=0, gn=0, th=0, an_rel=0;
    bool steady_ok = steady_enough_(s, unit_now, dt_s, &cos_ref, &gn, &th, &an_rel);

    // 1) WAIT FOR POSE CHANGE
    if (!change_ok) {
      settle_start_us_ = 0;
      capture_start_us_ = 0;
      hold_ref_valid_ = false;
      step_avg_.reset();

      int64_t tnow = now_us_();
      if (tnow - last_status_print_us_ > 900000) {
        last_status_print_us_ = tnow;

        Serial.printf("[POSE] %s  waiting_pose_change  a_unit=[%.3f %.3f %.3f]\n",
                      step_pose_name_, unit_now.x(), unit_now.y(), unit_now.z());

        if (step_idx_ == 2) {
          Serial.printf("       need dot(step1) <= %.2f (flip). dot1=%.3f\n",
                        DOT_OPPOSITE_MAX, dot1);
        } else if (step_idx_ == 3) {
          Serial.printf("       need |dot(step1)| <= %.2f (edge). |dot1|=%.3f\n",
                        DOT_ORTHO_ABS_MAX, std::fabs(dot1));
        } else if (step_idx_ == 4) {
          Serial.printf("       need |dot(step1)|<=%.2f AND |dot(step3)|<=%.2f (top edge).\n",
                        DOT_ORTHO_ABS_MAX, DOT_ORTHO_ABS_MAX);
          Serial.printf("       |dot1|=%.3f  |dot3|=%.3f\n", std::fabs(dot1), std::fabs(dot3));
        }
        Serial.println("       (If this never changes, your accel vector isn’t changing with orientation!)");
      }

      if ((tnow - step_start_us_) > (int64_t)STEP_TIMEOUT_MS * 1000) {
        Serial.printf("[POSE] TIMEOUT in %s -> type 'r' to restart.\n", step_pose_name_);
      }
      return;
    }

    // 2) POSE CHANGED; REQUIRE STEADY FOR SETTLE_MS
    if (!steady_ok) {
      settle_start_us_ = 0;
      capture_start_us_ = 0;
      step_avg_.reset();

      int64_t tnow = now_us_();
      if (tnow - last_status_print_us_ > 900000) {
        last_status_print_us_ = tnow;
        Serial.printf("[POSE] %s  pose OK, but moving: cos=%.4f gyro=%.3f<th=%.3f aRel=%.3f\n",
                      step_pose_name_, cos_ref, gn, th, an_rel);
      }
      return;
    }

    if (settle_start_us_ == 0) {
      settle_start_us_ = now_us_();
      capture_start_us_ = 0;
      step_avg_.reset();
      Serial.printf("[POSE] %s  detected. Hold still... (settling %ums)\n",
                    step_pose_name_, (unsigned)SETTLE_MS);
      return;
    }

    uint32_t settle_ms = (uint32_t)((now_us_() - settle_start_us_) / 1000);
    if (settle_ms < SETTLE_MS) {
      int64_t tnow = now_us_();
      if (tnow - last_status_print_us_ > 900000) {
        last_status_print_us_ = tnow;
        Serial.printf("[POSE] %s  settling... %ums/%ums\n",
                      step_pose_name_, settle_ms, (unsigned)SETTLE_MS);
      }
      return;
    }

    // 3) SETTLED; CAPTURE FOR CAPTURE_MS
    if (capture_start_us_ == 0) {
      capture_start_us_ = now_us_();
      step_avg_.reset();
      Serial.printf("[POSE] %s  settled. Capturing %ums...\n",
                    step_pose_name_, (unsigned)CAPTURE_MS);
    }

    // if it becomes unstable during capture, restart capture window
    if (!steady_ok) {
      capture_start_us_ = now_us_();
      step_avg_.reset();
      return;
    }

    step_avg_.add(s);

    uint32_t cap_ms = (uint32_t)((now_us_() - capture_start_us_) / 1000);
    if (cap_ms >= CAPTURE_MS && step_avg_.n > 30) {
      Vec3 a_mean = step_avg_.acc_mean();
      Vec3 u_mean = safe_unit_(a_mean, unit_now);

      int idx = step_idx_ - 1;
      if (idx >= 0 && idx < 4) {
        pose_[idx] = step_avg_;
        pose_unit_[idx] = u_mean;
        pose_valid_[idx] = true;
      }

      Serial.printf("[POSE] OK: %s  samples=%d (mag_samples=%d)  mean_unit=[%.3f %.3f %.3f]\n",
                    step_pose_name_, step_avg_.n, step_avg_.nmag,
                    u_mean.x(), u_mean.y(), u_mean.z());

      advance_stage_();
      return;
    }
  }

  void advance_stage_() {
    acc_norm_ema_.reset();
    gyro_norm_ema_.reset();
    hold_ref_valid_ = false;
    last_status_print_us_ = 0;

    if (stage_ == ST_STEP1) {
      stage_ = ST_STEP2;
      enter_step_(2,
        "Flip device SCREEN DOWN on the same flat surface.\n"
        "It will wait until you actually flipped, then you hold still...",
        "SCREEN DOWN (flat)");
      return;
    }
    if (stage_ == ST_STEP2) {
      stage_ = ST_STEP3;
      enter_step_(3,
        "Stand device on its RIGHT EDGE (screen facing you; right edge on table).\n"
        "It will wait until it is an EDGE pose (not flat), then you hold still...",
        "RIGHT EDGE DOWN");
      return;
    }
    if (stage_ == ST_STEP3) {
      stage_ = ST_STEP4;
      enter_step_(4,
        "Stand device on its TOP EDGE (screen facing you; top edge on table).\n"
        "It will wait until it is EDGE AND different from right-edge, then you hold still...",
        "TOP EDGE DOWN");
      return;
    }
    if (stage_ == ST_STEP4) {
      stage_ = ST_DONE;
      Serial.println();
      Serial.println("============================================================");
      Serial.println("[DONE] Captured 4 poses. (Mapping solve can be re-added next.)");
      Serial.println("Type 'r' to restart.");
      Serial.println("============================================================");
      return;
    }
  }
};

// ---------------- Global wizard ----------------
static IMUWizard g_wiz;

void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);
  delay(350);
  g_wiz.begin();
}

void loop() {
  g_wiz.update();
}
