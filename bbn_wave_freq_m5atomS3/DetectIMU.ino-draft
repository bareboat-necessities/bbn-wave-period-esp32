/*
  AtomS3R (M5Unified) â€” IMU Auto-detect Wizard (poses + rotation)
  OUTPUT FRAME = NED (screen-up reference):
    N = toward TOP edge of screen (when screen is up)
    E = toward RIGHT edge of screen
    D = DOWN into the table

  Poses used:
    Step1 SCREEN UP     => +D
    Step2 SCREEN DOWN   => -D
    Step3 RIGHT EDGE DOWN => +E
    Step4 TOP EDGE DOWN   => +N

  Commands over Serial:
    r : restart wizard
    v : toggle verbose status prints
*/

#include <M5Unified.h>
#include <cmath>
#include <cstdint>
#include <algorithm>

#ifdef ARDUINO_ARCH_ESP32
  #include "esp_timer.h"
#endif

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
#define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif
#ifdef EIGEN_NON_ARDUINO
  #include <Eigen/Dense>
#else
  #include <ArduinoEigenDense.h>
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

class IMUWizard {
public:
  using Vec3 = Eigen::Matrix<float,3,1>;

  // ------------------------------ Tunables ------------------------------
  static constexpr float    G_STD           = 9.80665f;
  static constexpr float    ACC_GYR_RATE_HZ = 200.0f;
  static constexpr float    MAG_RATE_HZ     = 50.0f;

  static constexpr uint32_t POSE_SETTLE_MS  = 2500;
  static constexpr uint32_t POSE_STABLE_MS  = 1400;
  static constexpr uint32_t POSE_TIMEOUT_MS = 45000;

  static constexpr uint32_t ROT_GET_READY_MS = 2000;
  static constexpr uint32_t ROT_CAPTURE_MS   = 8000;
  static constexpr uint32_t ROT_TIMEOUT_MS   = 45000;

  // Pose-change detection
  static constexpr float CHANGE_DOT_MAX   = 0.85f;
  static constexpr float AXISLIKE_MINABS  = 0.85f;

  // Stillness
  static constexpr float STILL_COS_MIN     = 0.9985f;
  static constexpr float ACC_NORM_REL_MAX  = 0.05f;
  static constexpr float GYRO_ABS_MAX_RAW  = 10.0f;
  static constexpr float GYRO_FLOOR_RAW    = 0.35f;

  // Rotation arming
  static constexpr float ROT_FLAT_COS_MIN  = 0.985f;
  static constexpr float ROT_ARM_GYRO_MAX  = 0.6f;
  static constexpr float ROT_MOVE_GYRO_MIN = 0.25f;

  // Rotation storage
  static constexpr int MAX_ROT_SAMPLES = 520;

  // Mag mapping quality gates
  static constexpr float MAG_CORR_MIN       = 0.55f;
  static constexpr float MAG_UNWRAP_MIN_RAD = 5.3f; // ~304 deg

  // ------------------------------ Types ------------------------------
  struct AxisMap { int8_t idx[3]; int8_t sgn[3]; }; // outputs are {N,E,D} in that order

  struct SignedPerm {
    int8_t idx[3] = {0,1,2};
    int8_t sgn[3] = {+1,+1,+1};
    int8_t det    = +1;
  };

  struct IMUSample {
    int64_t t_us = 0;
    Vec3 acc = Vec3::Zero();
    Vec3 gyr = Vec3::Zero();
    Vec3 mag = Vec3::Zero();
    bool have_mag = false;
    bool got_mag_tick = false;
  };

  struct PoseAvg {
    Vec3 acc_sum = Vec3::Zero();
    Vec3 gyr_sum = Vec3::Zero();
    Vec3 mag_sum = Vec3::Zero();
    int n = 0;
    int nmag = 0;
    void reset() { acc_sum.setZero(); gyr_sum.setZero(); mag_sum.setZero(); n=0; nmag=0; }
    void add(const IMUSample& s) {
      acc_sum += s.acc;
      gyr_sum += s.gyr;
      n++;
      if (s.have_mag) { mag_sum += s.mag; nmag++; }
    }
    Vec3 acc_mean() const {
      if (n > 0) return acc_sum / (float)n;
      return Vec3::Zero();
    }
    Vec3 gyr_mean() const {
      if (n > 0) return gyr_sum / (float)n;
      return Vec3::Zero();
    }
    Vec3 mag_mean() const {
      if (nmag > 0) return mag_sum / (float)nmag;
      return Vec3::Zero();
    }
  };

  struct RotCap {
    IMUSample s[MAX_ROT_SAMPLES];
    int n = 0;
    void reset() { n = 0; }
    void push(const IMUSample& x) { if (n < MAX_ROT_SAMPLES) s[n++] = x; }
  };

  struct Stillness {
    Vec3  a_unit_ema = Vec3(0,0,1);
    float a_norm_ema = 1.0f;
    float gyro_ema   = 0.0f;

    void reset() { a_unit_ema = Vec3(0,0,1); a_norm_ema = 1.0f; gyro_ema = 0.0f; }

    bool update_and_check(const Vec3& a_raw, const Vec3& g_raw, float dt_s,
                          float* out_cos=nullptr, float* out_gn=nullptr,
                          float* out_th=nullptr, float* out_an_rel=nullptr)
    {
      const float alpha_dir  = clampf(dt_s / 0.25f, 0.01f, 0.25f);
      const float alpha_norm = clampf(dt_s / 0.35f, 0.01f, 0.25f);
      const float alpha_gyro = clampf(dt_s / 0.45f, 0.01f, 0.25f);

      Vec3 au = safe_unit(a_raw, a_unit_ema);
      a_unit_ema = safe_unit((1.0f - alpha_dir) * a_unit_ema + alpha_dir * au, au);

      float an = safe_norm(a_raw);
      if (an > 1e-6f) a_norm_ema = (1.0f - alpha_norm) * a_norm_ema + alpha_norm * an;

      float gn = safe_norm(g_raw);
      gyro_ema = (1.0f - alpha_gyro) * gyro_ema + alpha_gyro * gn;

      float cos_sim = clampf(au.dot(a_unit_ema), -1.0f, 1.0f);
      float gyro_th = std::max(GYRO_FLOOR_RAW, 3.0f * gyro_ema + GYRO_FLOOR_RAW);

      float an_rel = 0.0f;
      if (a_norm_ema > 1e-6f) an_rel = std::fabs(an - a_norm_ema) / a_norm_ema;

      bool ok = (cos_sim > STILL_COS_MIN) &&
                (gn < gyro_th) &&
                (gn < GYRO_ABS_MAX_RAW) &&
                (an_rel < ACC_NORM_REL_MAX);

      if (out_cos) *out_cos = cos_sim;
      if (out_gn)  *out_gn  = gn;
      if (out_th)  *out_th  = gyro_th;
      if (out_an_rel) *out_an_rel = an_rel;
      return ok;
    }
  };

  // ------------------------------ Public API ------------------------------
  void begin() {
    setup_rates_();
    verbose_ = true;
    reset_all_();
    print_banner_();
    print_pose_prompt_(0);
  }

  void update() {
    handle_serial_commands_();

    switch (stage_) {
      case ST_POSE: {
        PoseAvg* out = pose_ptr_(pose_i_);
        const Vec3* prev_u = (pose_i_ > 0) ? &pose_dir_raw_[pose_i_-1] : nullptr;

        if (capture_pose_prompted_(*out, pose_name_(pose_i_), prev_u, pose_dir_raw_[pose_i_])) {
          pose_i_++;
          if (pose_i_ < 4) {
            print_pose_prompt_(pose_i_);
          } else {
            stage_ = ST_SOLVE_ACCEL;
          }
        }
      } break;

      case ST_SOLVE_ACCEL: {
        SignedPerm map;
        float best=0, second=0, margin=0;
        bool ok = build_mapping_from_poses_to_NED_(poseZup_, poseZdown_, poseRight_, poseTop_, map, &best, &second, &margin);
        if (!ok) {
          Serial.printf("\n[ACCEL] Could not solve mapping confidently. best=%.3f second=%.3f margin=%.3f\n", best, second, margin);
          Serial.println("[ACCEL] Likely: pose was not actually changed, or not axis-like, or moved during hold.");
          Serial.println("Send 'r' to restart and redo poses slowly.");
          stage_ = ST_WAIT_CMD;
          break;
        }

        map_raw_to_ned_ = map;
        acc_scale_mps2_ = choose_acc_scale_mps2_(map_raw_to_ned_, poseZup_, poseZdown_, poseRight_, poseTop_);

        Serial.println("\n[ACCEL] Solved mapping raw->NED (screen-up reference).");
        Serial.printf("ACC_SCALE_MPS2   = %.9g\n", acc_scale_mps2_);
        print_ned_map_("ACC_MAP  (raw->NED)", map_to_axis_map_(map_raw_to_ned_));

        // Move to rotation test
        stage_ = ST_ROTATE;
        rot_.reset();
        rot_state_ = ROT_GET_READY;
        rot_t0_us_ = now_us64_();
        print_rotation_prompt_();
      } break;

      case ST_ROTATE: {
        if (run_rotation_test_()) {
          stage_ = ST_SOLVE_MAG_GYRO;
        }
      } break;

      case ST_SOLVE_MAG_GYRO: {
        // Gyro integral in NED-D during rotation (raw units * sec)
        double gyro_int_raw = 0.0;
        for (int i=1;i<rot_.n;i++) {
          float dt = (float)((rot_.s[i].t_us - rot_.s[i-1].t_us) * 1e-6);
          if (!(dt > 1e-6f && dt < 0.2f)) continue;
          Vec3 g_ned = apply_perm_(map_raw_to_ned_, rot_.s[i].gyr);
          gyro_int_raw += (double)g_ned.z() * (double)dt; // z = D
        }

        float heading_unwrap_rad = 0.0f;
        float mag_norm_mean_raw  = 0.0f;
        float corr_abs           = 0.0f;

        int magCount = 0;
        for (int i=0;i<rot_.n;i++) if (rot_.s[i].have_mag) magCount++;
        have_mag_ = (magCount >= 60);

        if (!have_mag_) {
          Serial.println("\n[MAG] Magnetometer not available (or always zero). Skipping mag mapping.");
          map_mag_raw_to_ned_ = make_perm_(0,+1, 1,+1, 2,+1);
          mag_scale_uT_ = 1.0f;
        } else {
          bool ok = find_best_mag_mapping_quality_gated_(
            rot_,
            map_raw_to_ned_,
            pose_dir_raw_[0],               // gravity direction in RAW from step1 (screen up)
            map_mag_raw_to_ned_,
            heading_unwrap_rad,
            mag_norm_mean_raw,
            corr_abs
          );

          if (!ok) {
            Serial.println("\n[MAG] Rotation quality too low -> NOT outputting mag mapping (prevents random result).");
            Serial.println("Redo STEP 5: keep flat, rotate at least ONE FULL TURN, away from metal.");
            Serial.println("Send 'r' to restart, or just redo STEP 5 now.");
            stage_ = ST_ROTATE;
            rot_.reset();
            rot_state_ = ROT_GET_READY;
            rot_t0_us_ = now_us64_();
            print_rotation_prompt_();
            break;
          }

          mag_scale_uT_ = choose_mag_scale_uT_(mag_norm_mean_raw);
        }

        gyro_scale_radps_ = choose_gyro_scale_radps_(heading_unwrap_rad, (float)gyro_int_raw);

        print_results_(heading_unwrap_rad, mag_norm_mean_raw, corr_abs, (float)gyro_int_raw);
        stage_ = ST_DONE;
      } break;

      case ST_WAIT_CMD:
        delay(10);
        break;

      case ST_DONE:
        delay(50);
        break;
    }
  }

private:
  // ------------------------------ Stages ------------------------------
  enum Stage { ST_POSE=0, ST_SOLVE_ACCEL, ST_ROTATE, ST_SOLVE_MAG_GYRO, ST_WAIT_CMD, ST_DONE };
  Stage stage_ = ST_POSE;
  int pose_i_ = 0;

  // Poses
  PoseAvg poseZup_, poseZdown_, poseRight_, poseTop_;
  Vec3    pose_dir_raw_[4] = {Vec3(0,0,1),Vec3(0,0,1),Vec3(0,0,1),Vec3(0,0,1)};

  Stillness still_;
  RotCap rot_;

  enum RotState { ROT_GET_READY=0, ROT_ARM_FLAT_STILL, ROT_WAIT_MOVE, ROT_CAPTURING, ROT_DONE };
  RotState rot_state_ = ROT_GET_READY;
  int64_t rot_t0_us_ = 0;
  int64_t rot_cap_start_us_ = 0;

  // Maps/scales
  SignedPerm map_raw_to_ned_;
  SignedPerm map_mag_raw_to_ned_;
  float acc_scale_mps2_   = 1.0f;
  float gyro_scale_radps_ = 1.0f;
  float mag_scale_uT_     = 1.0f;
  bool  have_mag_         = false;

  // Scheduler
  int64_t next_acc_us_ = 0, next_mag_us_ = 0;
  int64_t acc_period_us_ = 0, mag_period_us_ = 0;
  uint32_t acc_ticks_ = 0, mag_ticks_ = 0, mag_valid_ticks_ = 0;
  int64_t rate_t0_us_ = 0, rate_last_print_us_ = 0;
  IMUSample last_sample_;
  bool verbose_ = true;

  // Rotation timers
  int64_t arm_start_us_ = 0;
  int64_t move_start_us_ = 0;
  int64_t rot_last_print_us_ = 0;

  // ------------------------------ Basics ------------------------------
  static inline int64_t now_us64_() {
  #ifdef ARDUINO_ARCH_ESP32
    return (int64_t)esp_timer_get_time();
  #else
    return (int64_t)micros();
  #endif
  }
  static inline float clampf(float x, float a, float b) { return std::max(a, std::min(b, x)); }
  static inline float safe_norm(const Vec3& v) {
    float n = v.norm();
    return (std::isfinite(n) && n > 1e-12f) ? n : 0.0f;
  }
  static inline Vec3 safe_unit(const Vec3& v, const Vec3& fallback = Vec3(0,0,1)) {
    float n = safe_norm(v);
    if (n > 0.0f) return v / n;
    return fallback;
  }
  static inline float wrap_pi_(float a) {
    while (a >  (float)M_PI) a -= 2.0f*(float)M_PI;
    while (a < -(float)M_PI) a += 2.0f*(float)M_PI;
    return a;
  }

  // ------------------------------ Serial commands ------------------------------
  void handle_serial_commands_() {
    while (Serial.available() > 0) {
      char c = (char)Serial.read();
      if (c == 'r' || c == 'R') {
        Serial.println("\n[CMD] restart");
        reset_all_();
        print_banner_();
        print_pose_prompt_(0);
      } else if (c == 'v' || c == 'V') {
        verbose_ = !verbose_;
        Serial.printf("\n[CMD] verbose=%s\n", verbose_ ? "ON" : "OFF");
      }
    }
  }

  void reset_all_() {
    stage_ = ST_POSE;
    pose_i_ = 0;
    poseZup_.reset(); poseZdown_.reset(); poseRight_.reset(); poseTop_.reset();
    still_.reset();
    rot_.reset();
    rot_state_ = ROT_GET_READY;
    map_raw_to_ned_     = make_perm_(0,+1,1,+1,2,+1);
    map_mag_raw_to_ned_ = make_perm_(0,+1,1,+1,2,+1);
    acc_scale_mps2_ = 1.0f; gyro_scale_radps_=1.0f; mag_scale_uT_=1.0f;
    have_mag_ = false;
    setup_rates_();
  }

  // ------------------------------ UI prints ------------------------------
  void print_sep_() const {
    Serial.println();
    Serial.println("============================================================");
  }

  void print_banner_() {
    print_sep_();
    Serial.println("IMU Auto-Detect Wizard");
    Serial.println("OUTPUT FRAME: NED (screen-up reference)");
    Serial.println("  N = TOP edge, E = RIGHT edge, D = down into table (screen up)");
    Serial.println("Serial commands: 'r' restart, 'v' verbose toggle");
    Serial.println("============================================================");
  }

  const char* pose_name_(int i) const {
    switch (i) {
      case 0: return "STEP 1/5: SCREEN UP (flat)";
      case 1: return "STEP 2/5: SCREEN DOWN (flat)";
      case 2: return "STEP 3/5: RIGHT EDGE DOWN (screen facing you)";
      case 3: return "STEP 4/5: TOP EDGE DOWN (screen facing you)";
      default: return "?";
    }
  }

  PoseAvg* pose_ptr_(int i) {
    switch (i) {
      case 0: return &poseZup_;
      case 1: return &poseZdown_;
      case 2: return &poseRight_;
      case 3: return &poseTop_;
      default: return &poseZup_;
    }
  }

  void print_pose_prompt_(int i) {
    print_sep_();
    Serial.println(pose_name_(i));
    Serial.println("1) Put device in that pose.");
    Serial.println("2) WAIT until it is steady.");
    Serial.printf("3) Auto-settle (%u ms) then require stable hold (%u ms).\n",
                  (unsigned)POSE_SETTLE_MS, (unsigned)POSE_STABLE_MS);
    Serial.println("(Send 'r' to restart, 'v' for verbose.)");
    Serial.println("============================================================");
  }

  void print_rotation_prompt_() {
    print_sep_();
    Serial.println("STEP 5/5: Rotation test");
    Serial.println("1) Place device SCREEN UP (flat).");
    Serial.println("2) Wait ~2 seconds.");
    Serial.println("3) Rotate CLOCKWISE (viewed from above) for ~8 seconds, keep it flat.");
    Serial.println("(Send 'r' to restart, 'v' for verbose.)");
    Serial.println("============================================================");
  }

  // ------------------------------ IMU read + scheduler ------------------------------
  bool read_imu_once_(IMUSample& out) {
    M5.update();
    (void)M5.Imu.update();
    auto d = M5.Imu.getImuData();

    out.t_us = now_us64_();
    out.acc  = Vec3(d.accel.x, d.accel.y, d.accel.z);
    out.gyr  = Vec3(d.gyro.x,  d.gyro.y,  d.gyro.z);
    out.mag  = Vec3(d.mag.x,   d.mag.y,   d.mag.z);

    out.have_mag =
      std::isfinite(out.mag.x()) && std::isfinite(out.mag.y()) && std::isfinite(out.mag.z()) &&
      (std::fabs(out.mag.x()) + std::fabs(out.mag.y()) + std::fabs(out.mag.z()) > 1e-6f);

    return true;
  }

  void setup_rates_() {
    auto hz_to_period = [](float hz)->int64_t {
      if (!(hz > 0.1f)) hz = 1.0f;
      double p = 1000000.0 / (double)hz;
      if (p < 1000.0) p = 1000.0;
      return (int64_t)llround(p);
    };

    acc_period_us_ = hz_to_period(ACC_GYR_RATE_HZ);
    mag_period_us_ = hz_to_period(MAG_RATE_HZ);

    int64_t now = now_us64_();
    next_acc_us_ = now + acc_period_us_;
    next_mag_us_ = now + mag_period_us_;

    rate_t0_us_ = now;
    rate_last_print_us_ = now;
    acc_ticks_ = mag_ticks_ = mag_valid_ticks_ = 0;
  }

  void maybe_print_rate_report_(bool have_mag) {
    int64_t now = now_us64_();
    if (now - rate_last_print_us_ < 1000000) return;
    rate_last_print_us_ = now;

    double dt = (now - rate_t0_us_) * 1e-6;
    if (dt <= 0.0) dt = 1.0;

    float acc_hz = (float)(acc_ticks_ / dt);
    float mag_hz = (float)(mag_valid_ticks_ / dt);

    Serial.printf("[RATE] acc/gyro observed ~%.1f Hz (target %.1f)\n", acc_hz, ACC_GYR_RATE_HZ);
    Serial.printf("[RATE] mag observed     ~%.1f Hz (target %.1f) %s\n",
                  mag_hz, MAG_RATE_HZ, (have_mag ? "" : "(mag may be unavailable)"));

    rate_t0_us_ = now;
    acc_ticks_ = mag_ticks_ = mag_valid_ticks_ = 0;
  }

  bool scheduled_poll_(IMUSample& out, bool& got_acc, bool& got_mag) {
    got_acc = false; got_mag = false;
    int64_t now = now_us64_();

    bool due_acc = (now >= next_acc_us_);
    bool due_mag = (now >= next_mag_us_);
    if (!due_acc && !due_mag) return false;

    if (due_acc) {
      int64_t late = now - next_acc_us_;
      next_acc_us_ = (late > 2*acc_period_us_) ? (now + acc_period_us_) : (next_acc_us_ + acc_period_us_);
      got_acc = true;
      acc_ticks_++;
    }
    if (due_mag) {
      int64_t late = now - next_mag_us_;
      next_mag_us_ = (late > 2*mag_period_us_) ? (now + mag_period_us_) : (next_mag_us_ + mag_period_us_);
      got_mag = true;
      mag_ticks_++;
    }

    read_imu_once_(last_sample_);
    out = last_sample_;
    out.got_mag_tick = got_mag;

    if (got_mag && out.have_mag) mag_valid_ticks_++;
    maybe_print_rate_report_(out.have_mag);
    return true;
  }

  // ------------------------------ Pose capture ------------------------------
  bool capture_pose_prompted_(PoseAvg& out,
                              const char* pose_label,
                              const Vec3* prev_dir_unit_raw,
                              Vec3& out_dir_unit_raw)
  {
    out.reset();
    still_.reset();

    enum { WAIT_CHANGE=0, SETTLING=1, STABILIZING=2 } sub = WAIT_CHANGE;
    if (!prev_dir_unit_raw) sub = SETTLING;

    int64_t t_start = now_us64_();
    int64_t settle_start = 0;
    int64_t stable_start = 0;
    int64_t last_us = now_us64_();
    int64_t last_print = now_us64_();

    Vec3 cur_u = Vec3(0,0,1);

    while (true) {
      handle_serial_commands_();

      IMUSample s;
      bool got_acc=false, got_mag=false;
      if (!scheduled_poll_(s, got_acc, got_mag)) { delay(1); continue; }
      if (!got_acc) continue;

      int64_t now = s.t_us;
      float dt_s = (float)((now - last_us) * 1e-6);
      last_us = now;
      if (!(dt_s > 0.0f && dt_s < 0.5f)) dt_s = 0.01f;

      cur_u = safe_unit(s.acc, cur_u);
      float maxAbs = std::max({std::fabs(cur_u.x()), std::fabs(cur_u.y()), std::fabs(cur_u.z())});

      if (sub == WAIT_CHANGE) {
        float dotPrev = prev_dir_unit_raw ? clampf(cur_u.dot(*prev_dir_unit_raw), -1.0f, 1.0f) : 0.0f;
        bool changed = (dotPrev < CHANGE_DOT_MAX) && (maxAbs > AXISLIKE_MINABS);
        if (changed) {
          sub = SETTLING;
          settle_start = now_us64_();
          stable_start = 0;
          out.reset();
          still_.reset();
          if (verbose_) Serial.printf("[POSE] pose-change detected. settling %u ms...\n", (unsigned)POSE_SETTLE_MS);
        } else {
          if (now_us64_() - last_print > 800000) {
            last_print = now_us64_();
            Serial.printf("[POSE] waiting_pose_change  dotPrev=%.3f  maxAbs=%.3f\n", dotPrev, maxAbs);
          }
          if ((now_us64_() - t_start) > (int64_t)POSE_TIMEOUT_MS * 1000) {
            Serial.println("[POSE] TIMEOUT waiting for pose change. (Send 'r' to restart)");
            return false;
          }
          continue;
        }
      }

      if (sub == SETTLING) {
        int64_t elapsed = now_us64_() - settle_start;
        if (elapsed < (int64_t)POSE_SETTLE_MS * 1000) {
          if (verbose_ && (now_us64_() - last_print > 800000)) {
            last_print = now_us64_();
            uint32_t rem = (uint32_t)((POSE_SETTLE_MS*1000 - elapsed)/1000);
            Serial.printf("[POSE] settling... %ums remaining  a_unit=[%.3f %.3f %.3f]\n",
                          (unsigned)rem, cur_u.x(), cur_u.y(), cur_u.z());
          }
          continue;
        }
        sub = STABILIZING;
        stable_start = 0;
        out.reset();
        still_.reset();
        if (verbose_) Serial.printf("[POSE] %s: now hold still (%u ms)\n", pose_label, (unsigned)POSE_STABLE_MS);
      }

      float cos_sim=0, gn=0, th=0, an_rel=0;
      bool ok = still_.update_and_check(s.acc, s.gyr, dt_s, &cos_sim, &gn, &th, &an_rel);

      if (!ok) {
        stable_start = 0;
        out.reset();
      } else {
        if (stable_start == 0) stable_start = now_us64_();
        out.add(s);
        if ((now_us64_() - stable_start) >= (int64_t)POSE_STABLE_MS * 1000 && out.n > 20) {
          out_dir_unit_raw = safe_unit(out.acc_mean(), cur_u);
          Serial.printf("[POSE] OK: %s  samples=%d\n", pose_label, out.n);
          return true;
        }
      }

      if (now_us64_() - last_print > 900000) {
        last_print = now_us64_();
        uint32_t stable_ms = (stable_start == 0) ? 0 : (uint32_t)((now_us64_() - stable_start)/1000);
        Serial.printf("[POSE] stable=%ums/%u  cos=%.4f  gyro=%.3f<th=%.3f  aRel=%.3f  n=%d\n",
                      stable_ms, (unsigned)POSE_STABLE_MS, cos_sim, gn, th, an_rel, out.n);
      }

      if ((now_us64_() - t_start) > (int64_t)POSE_TIMEOUT_MS * 1000) {
        Serial.println("[POSE] TIMEOUT holding stable. (Send 'r' to restart)");
        return false;
      }
    }
  }

  // ------------------------------ Permutations ------------------------------
  int perm_parity3_(int a, int b, int c) const {
    int inv = 0;
    int arr[3] = {a,b,c};
    for (int i=0;i<3;i++) for (int j=i+1;j<3;j++) if (arr[i] > arr[j]) inv++;
    return (inv % 2 == 0) ? +1 : -1;
  }

  SignedPerm make_perm_(int ix,int sx,int iy,int sy,int iz,int sz) const {
    SignedPerm p;
    p.idx[0]=(int8_t)ix; p.sgn[0]=(int8_t)sx;
    p.idx[1]=(int8_t)iy; p.sgn[1]=(int8_t)sy;
    p.idx[2]=(int8_t)iz; p.sgn[2]=(int8_t)sz;
    int parity = perm_parity3_(ix,iy,iz);
    int sprod  = sx * sy * sz;
    p.det = (int8_t)(parity * sprod);
    return p;
  }

  int enumerate_perms_(SignedPerm* out, int max_out, bool det_pos_only) const {
    int n = 0;
    const int perms[6][3] = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
    const int sgns[8][3]  = {
      {+1,+1,+1},{+1,+1,-1},{+1,-1,+1},{+1,-1,-1},
      {-1,+1,+1},{-1,+1,-1},{-1,-1,+1},{-1,-1,-1}
    };
    for (int pi=0; pi<6; ++pi) for (int si=0; si<8; ++si) {
      SignedPerm p = make_perm_(perms[pi][0], sgns[si][0],
                                perms[pi][1], sgns[si][1],
                                perms[pi][2], sgns[si][2]);
      if (det_pos_only && p.det < 0) continue;
      if (n < max_out) out[n++] = p;
    }
    return n;
  }

  Vec3 apply_perm_(const SignedPerm& p, const Vec3& v) const {
    Vec3 o;
    o(0) = (float)p.sgn[0] * v((int)p.idx[0]);
    o(1) = (float)p.sgn[1] * v((int)p.idx[1]);
    o(2) = (float)p.sgn[2] * v((int)p.idx[2]);
    return o;
  }

  static inline const char* rawax_(int i) { return (i==0)?"X":(i==1)?"Y":"Z"; }

  AxisMap map_to_axis_map_(const SignedPerm& p) const {
    AxisMap m;
    m.idx[0]=p.idx[0]; m.idx[1]=p.idx[1]; m.idx[2]=p.idx[2];
    m.sgn[0]=p.sgn[0]; m.sgn[1]=p.sgn[1]; m.sgn[2]=p.sgn[2];
    return m;
  }

  void print_ned_map_(const char* label, const AxisMap& m) const {
    auto term = [&](int out)->String {
      String s = (m.sgn[out] < 0) ? "-" : "+";
      s += rawax_(m.idx[out]);
      return s;
    };
    Serial.printf("%s : N=%s, E=%s, D=%s\n",
                  label,
                  term(0).c_str(), term(1).c_str(), term(2).c_str());
  }

  float score_dir_(const Vec3& v, const Vec3& target_unit) const {
    Vec3 u = safe_unit(v);
    return u.dot(target_unit);
  }

  // ------------------------------ Solve mapping raw->NED ------------------------------
  bool build_mapping_from_poses_to_NED_(const PoseAvg& pZ_up,
                                       const PoseAvg& pZ_down,
                                       const PoseAvg& pRightEdgeDown,
                                       const PoseAvg& pTopEdgeDown,
                                       SignedPerm& out_map,
                                       float* out_best=nullptr,
                                       float* out_second=nullptr,
                                       float* out_margin=nullptr) const
  {
    Vec3 aUp   = pZ_up.acc_mean();
    Vec3 aDown = pZ_down.acc_mean();
    Vec3 aR    = pRightEdgeDown.acc_mean();
    Vec3 aT    = pTopEdgeDown.acc_mean();

    // Output frame is NED = (N,E,D). Targets are unit vectors in that frame:
    const Vec3 tUp (0,0, +1);  // SCREEN UP => +D
    const Vec3 tDn (0,0, -1);  // SCREEN DOWN => -D
    const Vec3 tR  (0,+1,0);   // RIGHT EDGE DOWN => +E
    const Vec3 tT  (+1,0,0);   // TOP EDGE DOWN   => +N

    SignedPerm perms[64];
    int nperm = enumerate_perms_(perms, 64, false);

    float best = -1e9f, second = -1e9f;
    SignedPerm bestp = perms[0];

    for (int i=0;i<nperm;i++) {
      Vec3 mUp = apply_perm_(perms[i], aUp);
      Vec3 mDn = apply_perm_(perms[i], aDown);
      Vec3 mR  = apply_perm_(perms[i], aR);
      Vec3 mT  = apply_perm_(perms[i], aT);

      float sc = 0.0f;
      sc += 2.8f * score_dir_(mUp, tUp);
      sc += 2.3f * score_dir_(mDn, tDn);
      sc += 2.0f * score_dir_(mR,  tR);
      sc += 2.0f * score_dir_(mT,  tT);

      float nUp = safe_norm(mUp), nDn = safe_norm(mDn), nR = safe_norm(mR), nT = safe_norm(mT);
      float nmean = 0.25f*(nUp+nDn+nR+nT);
      float nvar  = (nUp-nmean)*(nUp-nmean)+(nDn-nmean)*(nDn-nmean)+(nR-nmean)*(nR-nmean)+(nT-nmean)*(nT-nmean);
      sc -= 0.12f * nvar / (nmean*nmean + 1e-6f);

      if (sc > best) { second = best; best = sc; bestp = perms[i]; }
      else if (sc > second) { second = sc; }
    }

    out_map = bestp;
    if (out_best) *out_best = best;
    if (out_second) *out_second = second;
    if (out_margin) *out_margin = best - second;

    return (best > 6.0f) && ((best - second) > 0.25f);
  }

  float choose_acc_scale_mps2_(const SignedPerm& map_out,
                              const PoseAvg& pUp,
                              const PoseAvg& pDown,
                              const PoseAvg& pR,
                              const PoseAvg& pT) const
  {
    float mags[4] = {
      safe_norm(apply_perm_(map_out, pUp.acc_mean())),
      safe_norm(apply_perm_(map_out, pDown.acc_mean())),
      safe_norm(apply_perm_(map_out, pR.acc_mean())),
      safe_norm(apply_perm_(map_out, pT.acc_mean()))
    };
    float m = 0.25f*(mags[0]+mags[1]+mags[2]+mags[3]);

    if (m > 0.35f && m < 2.3f) return G_STD; // g -> m/s^2
    if (m > 4.0f  && m < 15.0f) return 1.0f; // already m/s^2
    return (m > 1e-6f) ? (G_STD / m) : 1.0f;
  }

  // ------------------------------ Rotation test ------------------------------
  bool run_rotation_test_() {
    const int64_t now = now_us64_();
    const Vec3 g_ref_raw = pose_dir_raw_[0]; // gravity direction in RAW for screen-up pose

    IMUSample s;
    bool got_acc=false, got_mag=false;
    if (!scheduled_poll_(s, got_acc, got_mag)) { delay(1); return false; }
    if (!got_acc) return false;

    Vec3 au = safe_unit(s.acc, Vec3(0,0,1));
    float flat_cos = clampf(au.dot(g_ref_raw), -1.0f, 1.0f);
    float gyro_n = safe_norm(s.gyr);

    switch (rot_state_) {
      case ROT_GET_READY: {
        int64_t elapsed = now - rot_t0_us_;
        int64_t rem_us = (int64_t)ROT_GET_READY_MS*1000 - elapsed;
        if (rem_us > 0) {
          static int64_t lastp=0;
          if (verbose_ && (now - lastp > 800000)) {
            lastp = now;
            Serial.printf("[ROT] get ready... %ld ms\n", (long)(rem_us/1000));
          }
          return false;
        }
        rot_state_ = ROT_ARM_FLAT_STILL;
        arm_start_us_ = now_us64_();
        if (verbose_) Serial.println("[ROT] waiting: flat & still...");
        return false;
      }

      case ROT_ARM_FLAT_STILL: {
        bool flat_ok = (flat_cos > ROT_FLAT_COS_MIN);
        bool still_ok = (gyro_n < ROT_ARM_GYRO_MAX);
        if (verbose_ && (now - rot_last_print_us_ > 900000)) {
          rot_last_print_us_ = now;
          Serial.printf("[ROT] arming... flat_cos=%.4f(%s) gyro=%.3f(%s)\n",
                        flat_cos, flat_ok?"ok":"no",
                        gyro_n, still_ok?"still":"moving");
        }
        if (flat_ok && still_ok) {
          if ((now_us64_() - arm_start_us_) > 600000) {
            rot_state_ = ROT_WAIT_MOVE;
            move_start_us_ = 0;
            if (verbose_) Serial.println("[ROT] armed. start rotating CLOCKWISE now...");
          }
        } else {
          arm_start_us_ = now_us64_();
        }
        if ((now_us64_() - rot_t0_us_) > (int64_t)ROT_TIMEOUT_MS*1000) {
          Serial.println("[ROT] TIMEOUT arming. (Send 'r' to restart)");
          stage_ = ST_WAIT_CMD;
        }
        return false;
      }

      case ROT_WAIT_MOVE: {
        bool flat_ok = (flat_cos > ROT_FLAT_COS_MIN);
        bool moving = (gyro_n > ROT_MOVE_GYRO_MIN);

        if (verbose_ && (now - rot_last_print_us_ > 900000)) {
          rot_last_print_us_ = now;
          Serial.printf("[ROT] waiting move... flat_cos=%.4f(%s) gyro=%.3f(%s)\n",
                        flat_cos, flat_ok?"ok":"no",
                        gyro_n, moving?"moving":"still");
        }

        if (flat_ok && moving) {
          if (move_start_us_ == 0) move_start_us_ = now_us64_();
          if ((now_us64_() - move_start_us_) > 200000) {
            rot_state_ = ROT_CAPTURING;
            rot_cap_start_us_ = now_us64_();
            rot_.reset();
            Serial.println("[ROT] Capture started. Rotate now (8s)...");
          }
        } else {
          move_start_us_ = 0;
        }

        if ((now_us64_() - rot_t0_us_) > (int64_t)ROT_TIMEOUT_MS*1000) {
          Serial.println("[ROT] TIMEOUT waiting for rotation motion. (Send 'r' to restart)");
          stage_ = ST_WAIT_CMD;
        }
        return false;
      }

      case ROT_CAPTURING: {
        int64_t elapsed = now_us64_() - rot_cap_start_us_;
        int64_t rem = (int64_t)ROT_CAPTURE_MS*1000 - elapsed;

        if (s.got_mag_tick && s.have_mag) {
          if (rot_.n < MAX_ROT_SAMPLES) rot_.push(s);
        }

        if (verbose_ && (now - rot_last_print_us_ > 900000)) {
          rot_last_print_us_ = now;
          Serial.printf("[ROT] capturing... stored=%d/%d  remaining=%ld ms  flat_cos=%.4f\n",
                        rot_.n, MAX_ROT_SAMPLES, (long)std::max<int64_t>(0, rem/1000), flat_cos);
        }

        if (rem <= 0) {
          int magCount=0;
          for (int i=0;i<rot_.n;i++) if (rot_.s[i].have_mag) magCount++;
          Serial.printf("[ROT] Done. Stored mag samples: %d (max %d)\n", magCount, MAX_ROT_SAMPLES);
          rot_state_ = ROT_DONE;
          return true;
        }
        return false;
      }

      case ROT_DONE:
      default:
        return true;
    }
  }

  // ------------------------------ Mag mapping (quality gated) ------------------------------
  // Stack-safe: streaming correlation (no big arrays on the stack)
  SignedPerm find_best_mag_mapping_(const RotCap& cap,
                                   const SignedPerm& map_acc_screen,
                                   float& out_heading_unwrap_rad,
                                   float& out_mag_norm_mean_raw,
                                   float& out_corr_abs) const
  {
    struct CorrAcc {
      double sx=0, sy=0, sxx=0, syy=0, sxy=0;
      int n=0;
      inline void reset(){ sx=sy=sxx=syy=sxy=0; n=0; }
      inline void add(double x, double y){
        sx += x; sy += y;
        sxx += x*x; syy += y*y;
        sxy += x*y;
        n++;
      }
      inline float corr() const {
        if (n < 12) return 0.0f;
        const double mx = sx / (double)n;
        const double my = sy / (double)n;
        const double vx = sxx - (double)n * mx * mx;
        const double vy = syy - (double)n * my * my;
        const double c  = sxy - (double)n * mx * my;
        const double denom = std::sqrt(std::max(0.0, vx) * std::max(0.0, vy));
        if (!(denom > 1e-12)) return 0.0f;
        return (float)(c / denom);
      }
    };

    SignedPerm perms[64];
    const int nperm = enumerate_perms_(perms, 64, true);

    const int n = std::min(cap.n, MAX_ROT_SAMPLES);
    if (n < 20) {
      out_heading_unwrap_rad = 0.0f;
      out_mag_norm_mean_raw  = 0.0f;
      out_corr_abs           = 0.0f;
      return make_perm_(0,+1, 1,+1, 2,+1);
    }

    float bestScore = -1e9f;
    SignedPerm bestP = perms[0];
    float best_corr_abs = 0.0f;
    float best_heading_unwrap = 0.0f;
    float best_mag_norm_mean = 0.0f;

    for (int pi=0; pi<nperm; ++pi) {
      bool psi_init = false;
      float psi_prev = 0.0f;
      float psi_unwrap = 0.0f;
      float psi_total_abs = 0.0f;

      double mag_norm_sum = 0.0;
      int mag_norm_n = 0;

      CorrAcc acc;
      acc.reset();

      for (int i=1;i<n;i++) {
        const IMUSample& s0 = cap.s[i-1];
        const IMUSample& s1 = cap.s[i];

        const float dt = (float)((s1.t_us - s0.t_us) * 1e-6);
        if (!(dt > 1e-6f && dt < 0.2f)) continue;
        if (!s1.have_mag) continue;

        // wz (gyro z in SCREEN frame) from accel-mapping (gyro shares accel mapping)
        const Vec3 g_scr = apply_perm_(map_acc_screen, s1.gyr);
        const float wz = g_scr.z();

        // mag in candidate SCREEN frame
        const Vec3 m_scr = apply_perm_(perms[pi], s1.mag);

        const float mn = safe_norm(m_scr);
        if (mn > 1e-6f) { mag_norm_sum += (double)mn; mag_norm_n++; }

        const float psi = std::atan2(m_scr.y(), m_scr.x());

        if (!psi_init) {
          psi_prev = psi;
          psi_unwrap = psi;
          psi_init = true;
          continue;
        }

        const float dpsi = wrap_pi_(psi - psi_prev);
        psi_prev = psi;
        psi_unwrap += dpsi;
        psi_total_abs += std::fabs(dpsi);

        const float hrate = dpsi / dt;   // heading rate (rad/s)
        acc.add((double)wz, (double)hrate);
      }

      if (acc.n < 24 || mag_norm_n < 24) continue;

      const float c = acc.corr();
      const float cabs = std::fabs(c);
      const float mag_norm_mean = (float)(mag_norm_sum / (double)mag_norm_n);

      // score: prefer strong correlation + sufficient turning
      const float score = 3.0f * cabs + 0.0015f * psi_total_abs;

      if (score > bestScore) {
        bestScore = score;
        bestP = perms[pi];
        best_corr_abs = cabs;
        best_heading_unwrap = psi_unwrap;
        best_mag_norm_mean = mag_norm_mean;
      }
    }

    out_heading_unwrap_rad = best_heading_unwrap;
    out_mag_norm_mean_raw  = best_mag_norm_mean;
    out_corr_abs           = best_corr_abs;
    return bestP;
  }

  float choose_mag_scale_uT_(float mag_norm_mean_raw) const {
    const float candidates[] = { 1.0f, 0.1f, 10.0f, 0.01f, 100.0f, 0.001f };
    float best = candidates[0];
    float bestCost = 1e9f;
    for (float s : candidates) {
      float muT = mag_norm_mean_raw * s;
      float cost = 0.0f;
      if (muT < 15.0f) cost += (15.0f - muT) * (15.0f - muT);
      if (muT > 100.0f) cost += (muT - 100.0f) * (muT - 100.0f);
      cost += 0.015f * (muT - 50.0f) * (muT - 50.0f);
      if (cost < bestCost) { bestCost = cost; best = s; }
    }
    return best;
  }

  float choose_gyro_scale_radps_(float heading_unwrap_rad, float gyro_int_raw) const {
    const float DEG2RAD = (float)M_PI / 180.0f;

    if (std::isfinite(heading_unwrap_rad) && std::isfinite(gyro_int_raw) && std::fabs(gyro_int_raw) > 1e-6f) {
      float s = std::fabs(heading_unwrap_rad / gyro_int_raw);
      if (s > 1e-4f && s < 10.0f) {
        float d0 = std::fabs(s - 1.0f);
        float d1 = std::fabs(s - DEG2RAD);
        if (d1 < 0.5f * d0) return DEG2RAD;
        return s;
      }
    }

    auto cost_for = [&](float scale)->float {
      float x = std::fabs(gyro_int_raw) * scale;
      if (!(x > 1e-6f)) return 1e9f;
      float k = std::round(x / (2.0f*(float)M_PI));
      if (k < 1.0f) k = 1.0f;
      return std::fabs(x - k * 2.0f*(float)M_PI);
    };

    float c_rad = cost_for(1.0f);
    float c_deg = cost_for(DEG2RAD);
    return (c_deg < c_rad) ? DEG2RAD : 1.0f;
  }

  // ------------------------------ Results print ------------------------------
  void print_results_(float heading_total_rad, float mag_norm_mean_raw, float corr_abs, float gyro_int_raw) {
    AxisMap accMap  = map_to_axis_map_(map_raw_to_ned_);
    AxisMap magMap  = map_to_axis_map_(map_mag_raw_to_ned_);

    Serial.println();
    Serial.println("########################### RESULTS ###########################");
    Serial.println("Frame: NED (screen-up reference): N=top, E=right, D=down into table");
    Serial.printf("ACC_SCALE_MPS2   = %.9g\n", acc_scale_mps2_);
    Serial.printf("GYRO_SCALE_RADPS = %.9g\n", gyro_scale_radps_);
    if (have_mag_) Serial.printf("MAG_SCALE_UT     = %.9g\n", mag_scale_uT_);

    print_ned_map_("ACC_MAP  (raw->NED)", accMap);
    print_ned_map_("GYRO_MAP (raw->NED)", accMap);

    if (have_mag_) {
      print_ned_map_("MAG_MAP  (raw->NED)", magMap);
      Serial.println("\nDiagnostics:");
      Serial.printf("  mag corr |corr| ~ %.3f\n", corr_abs);
      Serial.printf("  heading unwrap ~ %.2f rad (%.1f deg)\n", heading_total_rad, heading_total_rad*180.0f/(float)M_PI);
      Serial.printf("  mag norm mean raw=%.3f => scaled=%.2f uT\n", mag_norm_mean_raw, mag_norm_mean_raw*mag_scale_uT_);
      Serial.printf("  gyro integral raw (NED D) = %.6f (raw_units*s)\n", gyro_int_raw);
    }

    Serial.println("\n=== Paste-friendly constants ===");
    Serial.println("struct AxisMap { int8_t idx[3]; int8_t sgn[3]; }; // outputs are {N,E,D}");
    Serial.printf("static constexpr AxisMap ACC_MAP  = {{%d,%d,%d},{%d,%d,%d}}; // N,E,D\n",
                  accMap.idx[0],accMap.idx[1],accMap.idx[2], accMap.sgn[0],accMap.sgn[1],accMap.sgn[2]);
    Serial.printf("static constexpr AxisMap GYRO_MAP = {{%d,%d,%d},{%d,%d,%d}}; // N,E,D\n",
                  accMap.idx[0],accMap.idx[1],accMap.idx[2], accMap.sgn[0],accMap.sgn[1],accMap.sgn[2]);
    if (have_mag_) {
      Serial.printf("static constexpr AxisMap MAG_MAP  = {{%d,%d,%d},{%d,%d,%d}}; // N,E,D\n",
                    magMap.idx[0],magMap.idx[1],magMap.idx[2], magMap.sgn[0],magMap.sgn[1],magMap.sgn[2]);
    }
    Serial.printf("static constexpr float ACC_SCALE_MPS2   = %.9g;\n", acc_scale_mps2_);
    Serial.printf("static constexpr float GYRO_SCALE_RADPS = %.9g;\n", gyro_scale_radps_);
    if (have_mag_) Serial.printf("static constexpr float MAG_SCALE_UT     = %.9g;\n", mag_scale_uT_);
    Serial.println("###############################################################");
  }
};

// ------------------------------ Global wizard ------------------------------
static IMUWizard g_wiz;

void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);
  delay(350);
  g_wiz.begin();
}

void loop() {
  g_wiz.update();
}
