/*
  AtomS3R (M5Unified) â€” IMU Auto-detect Wizard (poses + robust 8s rotation)

  Commands:
    r = restart
    v = verbose
    a = force arm (rotation step)
    c = force capture (rotation step)

  Output:
    ACC_SCALE_MPS2, GYRO_SCALE_RADPS, MAG_SCALE_UT
    ACC_MAP/GYRO_MAP/MAG_MAP in "Y, X, -Z" style (RAW -> BODY_NED-like)
*/

#include <Arduino.h>
#include <M5Unified.h>
#include <cmath>
#include <cstdint>
#include <algorithm>
#include <cstdio>

#ifdef EIGEN_NON_ARDUINO
  #include <Eigen/Dense>
#else
  #include <ArduinoEigenDense.h>
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

class IMUWizard {
public:
  using Vec3 = Eigen::Matrix<float,3,1>;

  // ---------------- Config ----------------
  static constexpr float     G_STD              = 9.80665f;

  static constexpr float     ACC_GYR_RATE_HZ    = 200.0f;
  static constexpr float     MAG_RATE_HZ        = 50.0f;

  static constexpr uint32_t  SETTLE_MS          = 1500;
  static constexpr uint32_t  MATCH_HOLD_MS      = 350;
  static constexpr uint32_t  POSE_STABLE_MS     = 1400;
  static constexpr uint32_t  POSE_TIMEOUT_MS    = 45000;

  static constexpr float     DOWN_DOT_MAX       = -0.75f; // down pose: dot(up,cur) < this
  static constexpr float     ORTHO_ABS_DOT_MAX  =  0.70f; // edge poses: |dot(up,cur)| < this
  static constexpr float     EDGE_DISTINCT_MAX  =  0.85f; // top edge distinct from right edge: |dot(right,cur)| < this

  static constexpr uint32_t  ROT_CAPTURE_MS     = 8000;
  static constexpr int       MAX_ROT_SAMPLES    = 2200;

  static constexpr uint32_t  ROT_ARM_HOLD_MS    = 250;
  static constexpr float     ROT_UPISH_DOT_MIN  = 0.80f;   // screen-up-ish
  static constexpr float     ROT_FLAT_COS_MIN   = 0.985f;  // flat-ish

  static constexpr uint32_t  ROT_MOTION_HOLD_MS = 150;
  static constexpr float     ROT_GYRO_START_RAW = 0.08f;   // forgiving motion start

  // ---------------- Types ----------------
  struct SignedPerm {
    int8_t idx[3] = {0,1,2};
    int8_t sgn[3] = {+1,+1,+1};
    int8_t det    = +1;
  };

  struct IMUSample {
    uint32_t t_ms = 0;
    Vec3 acc = Vec3::Zero();
    Vec3 gyr = Vec3::Zero();
    Vec3 mag = Vec3::Zero();
    bool have_mag = false;
  };

  struct PoseAvg {
    Vec3 acc_sum = Vec3::Zero();
    Vec3 gyr_sum = Vec3::Zero();
    Vec3 mag_sum = Vec3::Zero();
    int n = 0;
    int nmag = 0;

    void reset() { acc_sum.setZero(); gyr_sum.setZero(); mag_sum.setZero(); n=0; nmag=0; }
    void add(const IMUSample& s) {
      acc_sum += s.acc;
      gyr_sum += s.gyr;
      n++;
      if (s.have_mag) { mag_sum += s.mag; nmag++; }
    }
    Vec3 acc_mean() const { return (n > 0) ? (acc_sum / (float)n) : Vec3(0,0,0); }
    Vec3 mag_mean() const { return (nmag > 0) ? (mag_sum / (float)nmag) : Vec3(0,0,0); }
  };

  struct PoseInfo {
    PoseAvg avg;
    Vec3 acc_unit = Vec3(0,0,1);
    bool valid = false;

    void reset() { avg.reset(); acc_unit = Vec3(0,0,1); valid=false; }
    void finalize_unit(const Vec3& fallback) {
      Vec3 am = avg.acc_mean();
      float n = am.norm();
      acc_unit = (std::isfinite(n) && n > 1e-9f) ? (am / n) : fallback;
      valid = true;
    }
  };

  struct RotCap {
    IMUSample s[MAX_ROT_SAMPLES];
    int n = 0;
    void reset() { n = 0; }
    void push(const IMUSample& x) { if (n < MAX_ROT_SAMPLES) s[n++] = x; }
  };

  // ---------------- Public ----------------
  void begin() {
    setup_rates_();
    restart_();
    print_banner_();
  }

  void update() {
    handle_serial_();
    if (want_restart_) { want_restart_ = false; restart_(); print_banner_(); return; }

    IMUSample s;
    bool got_acc=false, got_mag=false;
    if (!scheduled_poll_(s, got_acc, got_mag)) { delay(1); return; }
    if (!got_acc) return;

    switch (stage_) {
      case ST_POSES:        tick_pose_stage_(s); break;
      case ST_SOLVE_ACCEL:  if (!solve_accel_()) { Serial.println("\n[FAIL] Accel solve failed. Send 'r'."); stage_=ST_WAIT_RESTART; }
                            else { stage_=ST_ROTATE; enter_rotation_(); }
                            break;
      case ST_ROTATE:       if (tick_rotation_(s)) stage_ = ST_SOLVE_MAG_GYRO; break;
      case ST_SOLVE_MAG_GYRO: solve_mag_gyro_and_print_(); stage_=ST_DONE; break;
      case ST_WAIT_RESTART:
      case ST_DONE:         delay(15); break;
    }
  }

private:
  // ---------------- Enums/specs ----------------
  enum Stage { ST_POSES=0, ST_SOLVE_ACCEL, ST_ROTATE, ST_SOLVE_MAG_GYRO, ST_WAIT_RESTART, ST_DONE };
  enum PoseId : uint8_t { POSE_UP=0, POSE_DOWN=1, POSE_RIGHT=2, POSE_TOP=3, POSE_COUNT=4 };
  enum PoseCond : uint8_t { COND_NONE=0, COND_OPPOSITE_UP, COND_ORTHO_UP, COND_ORTHO_UP_DISTINCT };
  struct PoseSpec { const char* step; const char* prompt; PoseCond cond; };

  static constexpr PoseSpec POSE_SPECS_[POSE_COUNT] = {
    {"STEP 1/5", "Place device SCREEN UP (flat). Wait for settle, then hold still...", COND_NONE},
    {"STEP 2/5", "Flip device SCREEN DOWN (flat). Wait for settle, then hold still...", COND_OPPOSITE_UP},
    {"STEP 3/5", "Stand on RIGHT EDGE (screen facing you). Wait for settle, then hold still...", COND_ORTHO_UP},
    {"STEP 4/5", "Stand on TOP EDGE (screen facing you). Wait for settle, then hold still...", COND_ORTHO_UP_DISTINCT},
  };

  enum PoseSub : uint8_t { PS_PROMPT=0, PS_SETTLE, PS_WAIT_MATCH, PS_STABLE };
  enum RotSub  : uint8_t { RS_PROMPT=0, RS_WAIT_ARM, RS_WAIT_MOTION, RS_CAPTURE };

  // ---------------- State ----------------
  Stage stage_ = ST_POSES;
  PoseId pose_idx_ = POSE_UP;
  PoseSub pose_sub_ = PS_PROMPT;

  PoseInfo poses_[POSE_COUNT];
  RotCap rot_;

  SignedPerm map_acc_screen_;
  SignedPerm map_mag_screen_;

  float acc_scale_mps2_    = 1.0f;
  float gyro_scale_radps_  = 1.0f;
  float mag_scale_uT_      = 1.0f;
  bool  have_mag_          = false;

  uint32_t pose_t0_ms_=0, settle_until_ms_=0, match_start_ms_=0, stable_start_ms_=0, last_pose_print_ms_=0;

  RotSub rot_sub_ = RS_PROMPT;
  uint32_t rot_arm_start_ms_=0, rot_motion_start_ms_=0, rot_capture_t0_ms_=0, rot_last_print_ms_=0;
  Vec3 rot_flat_ref_ = Vec3(0,0,1);
  bool rot_have_flat_ref_ = false;

  bool verbose_ = false;
  bool want_restart_ = false;
  bool force_arm_ = false;
  bool force_capture_ = false;

  uint32_t next_acc_ms_=0, next_mag_ms_=0;
  uint32_t acc_period_ms_=5, mag_period_ms_=20;

  uint32_t rate_t0_ms_=0, rate_last_print_ms_=0;
  uint32_t acc_ticks_=0, mag_valid_ticks_=0;

  IMUSample last_sample_;

  // ---------------- Small helpers ----------------
  static inline float clampf(float x, float a, float b) { return std::max(a, std::min(b, x)); }
  static inline float safe_norm(const Vec3& v) {
    float n = v.norm();
    return (std::isfinite(n) && n > 1e-12f) ? n : 0.0f;
  }
  static inline Vec3 safe_unit(const Vec3& v, const Vec3& fb = Vec3(0,0,1)) {
    float n = safe_norm(v);
    return (n > 0.0f) ? (v / n) : fb;
  }
  static inline float wrap_pi_(float a) {
    while (a >  (float)M_PI) a -= 2.0f * (float)M_PI;
    while (a < -(float)M_PI) a += 2.0f * (float)M_PI;
    return a;
  }
  static inline char axis_char_(int idx) { return (idx==0)?'X':(idx==1)?'Y':'Z'; }

  void perm_to_triplet_(const SignedPerm& p, char* out, size_t outsz) const {
    const char c0 = axis_char_(p.idx[0]);
    const char c1 = axis_char_(p.idx[1]);
    const char c2 = axis_char_(p.idx[2]);
    const char* s0 = (p.sgn[0] < 0) ? "-" : "";
    const char* s1 = (p.sgn[1] < 0) ? "-" : "";
    const char* s2 = (p.sgn[2] < 0) ? "-" : "";
    snprintf(out, outsz, "%s%c, %s%c, %s%c", s0, c0, s1, c1, s2, c2);
  }

  Vec3 apply_perm_(const SignedPerm& p, const Vec3& v) const {
    Vec3 o;
    o(0) = (float)p.sgn[0] * v((int)p.idx[0]);
    o(1) = (float)p.sgn[1] * v((int)p.idx[1]);
    o(2) = (float)p.sgn[2] * v((int)p.idx[2]);
    return o;
  }

  int perm_parity3_(int a, int b, int c) const {
    int inv = 0; int arr[3] = {a,b,c};
    for (int i=0;i<3;i++) for (int j=i+1;j<3;j++) if (arr[i] > arr[j]) inv++;
    return (inv % 2 == 0) ? +1 : -1;
  }

  SignedPerm make_perm_(int ix,int sx,int iy,int sy,int iz,int sz) const {
    SignedPerm p;
    p.idx[0]=(int8_t)ix; p.sgn[0]=(int8_t)sx;
    p.idx[1]=(int8_t)iy; p.sgn[1]=(int8_t)sy;
    p.idx[2]=(int8_t)iz; p.sgn[2]=(int8_t)sz;
    int parity = perm_parity3_(ix,iy,iz);
    int sprod  = sx * sy * sz;
    p.det = (int8_t)(parity * sprod);
    return p;
  }

  int enumerate_perms_(SignedPerm* out, int max_out, bool det_pos_only) const {
    int n = 0;
    const int perms[6][3] = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
    const int sgns[8][3] = {
      {+1,+1,+1},{+1,+1,-1},{+1,-1,+1},{+1,-1,-1},
      {-1,+1,+1},{-1,+1,-1},{-1,-1,+1},{-1,-1,-1}
    };
    for (int pi=0; pi<6; ++pi) for (int si=0; si<8; ++si) {
      SignedPerm p = make_perm_(perms[pi][0], sgns[si][0],
                                perms[pi][1], sgns[si][1],
                                perms[pi][2], sgns[si][2]);
      if (det_pos_only && p.det < 0) continue;
      if (n < max_out) out[n++] = p;
    }
    return n;
  }

  SignedPerm screen_to_body_ned_like_(SignedPerm p_screen) const {
    // SCREEN +Z up -> BODY_NED-like +Z down (flip output Z)
    p_screen.sgn[2] = (int8_t)(-p_screen.sgn[2]);
    p_screen.det = (int8_t)(-p_screen.det);
    return p_screen;
  }

  void print_sep_(const char* title) const {
    Serial.println();
    Serial.println("============================================================");
    Serial.println(title);
    Serial.println("============================================================");
  }

  void print_banner_() const {
    print_sep_("IMU Wizard\nCommands: r restart, v verbose, a force arm, c force capture");
  }

  void handle_serial_() {
    while (Serial.available() > 0) {
      char c = (char)Serial.read();
      if (c=='r' || c=='R') want_restart_ = true;
      if (c=='v' || c=='V') { verbose_ = !verbose_; Serial.printf("[UI] verbose=%s\n", verbose_?"ON":"OFF"); }
      if (c=='a' || c=='A') { force_arm_ = true; Serial.println("[ROT] Force ARM requested."); }
      if (c=='c' || c=='C') { force_capture_ = true; Serial.println("[ROT] Force CAPTURE requested."); }
    }
  }

  void restart_() {
    stage_ = ST_POSES;
    pose_idx_ = POSE_UP;
    pose_sub_ = PS_PROMPT;

    for (int i=0;i<POSE_COUNT;i++) poses_[i].reset();

    rot_.reset();
    rot_sub_ = RS_PROMPT;
    rot_have_flat_ref_ = false;

    map_acc_screen_ = make_perm_(0,+1,1,+1,2,+1);
    map_mag_screen_ = make_perm_(0,+1,1,+1,2,+1);

    acc_scale_mps2_   = 1.0f;
    gyro_scale_radps_ = 1.0f;
    mag_scale_uT_     = 1.0f;
    have_mag_         = false;

    pose_t0_ms_ = millis();
    settle_until_ms_ = pose_t0_ms_ + SETTLE_MS;
    match_start_ms_ = 0;
    stable_start_ms_ = 0;
    last_pose_print_ms_ = 0;

    force_arm_ = false;
    force_capture_ = false;
  }

  // -------- IMU poll --------
  bool read_imu_once_(IMUSample& out) {
    M5.update();
    (void)M5.Imu.update();
    auto d = M5.Imu.getImuData();

    out.t_ms = millis();
    out.acc  = Vec3(d.accel.x, d.accel.y, d.accel.z);
    out.gyr  = Vec3(d.gyro.x,  d.gyro.y,  d.gyro.z);
    out.mag  = Vec3(d.mag.x,   d.mag.y,   d.mag.z);

    out.have_mag =
      std::isfinite(out.mag.x()) && std::isfinite(out.mag.y()) && std::isfinite(out.mag.z()) &&
      (std::fabs(out.mag.x()) + std::fabs(out.mag.y()) + std::fabs(out.mag.z()) > 1e-6f);
    return true;
  }

  void setup_rates_() {
    acc_period_ms_ = (uint32_t)std::max(1.0f, std::round(1000.0f / ACC_GYR_RATE_HZ));
    mag_period_ms_ = (uint32_t)std::max(5.0f, std::round(1000.0f / MAG_RATE_HZ));

    uint32_t now = millis();
    next_acc_ms_ = now + acc_period_ms_;
    next_mag_ms_ = now + mag_period_ms_;

    rate_t0_ms_ = now;
    rate_last_print_ms_ = now;
    acc_ticks_ = 0;
    mag_valid_ticks_ = 0;
  }

  void maybe_print_rate_report_(bool have_mag) {
    uint32_t now = millis();
    if ((uint32_t)(now - rate_last_print_ms_) < 1000) return;
    rate_last_print_ms_ = now;

    float dt = (now - rate_t0_ms_) * 1e-3f;
    if (!(dt > 0.01f)) dt = 1.0f;

    float acc_hz = acc_ticks_ / dt;
    float mag_hz = mag_valid_ticks_ / dt;

    Serial.printf("[RATE] acc/gyro observed ~%.1f Hz (target %.1f)\n", acc_hz, ACC_GYR_RATE_HZ);
    Serial.printf("[RATE] mag observed     ~%.1f Hz (target %.1f) %s\n",
                  mag_hz, MAG_RATE_HZ, have_mag ? "" : "(mag may be unavailable)");

    rate_t0_ms_ = now;
    acc_ticks_ = 0;
    mag_valid_ticks_ = 0;
  }

  bool scheduled_poll_(IMUSample& out, bool& got_acc, bool& got_mag) {
    got_acc = false; got_mag = false;
    uint32_t now = millis();

    bool due_acc = ((int32_t)(now - next_acc_ms_) >= 0);
    bool due_mag = ((int32_t)(now - next_mag_ms_) >= 0);
    if (!due_acc && !due_mag) return false;

    if (due_acc) { next_acc_ms_ += acc_period_ms_; got_acc = true; acc_ticks_++; }
    if (due_mag) { next_mag_ms_ += mag_period_ms_; got_mag = true; }

    read_imu_once_(last_sample_);
    out = last_sample_;

    if (got_mag && out.have_mag) mag_valid_ticks_++;
    maybe_print_rate_report_(out.have_mag);
    return true;
  }

  // -------- Pose stage --------
  void enter_pose_prompt_() {
    const PoseSpec& spec = POSE_SPECS_[pose_idx_];
    char title[220];
    snprintf(title, sizeof(title), "%s:\n%s\n(Send 'r' restart, 'v' verbose.)", spec.step, spec.prompt);
    print_sep_(title);

    poses_[pose_idx_].avg.reset();

    pose_t0_ms_ = millis();
    settle_until_ms_ = pose_t0_ms_ + SETTLE_MS;
    match_start_ms_ = 0;
    stable_start_ms_ = 0;
    last_pose_print_ms_ = 0;
    pose_sub_ = PS_SETTLE;
  }

  void tick_pose_stage_(const IMUSample& s) {
    if (pose_sub_ == PS_PROMPT) { enter_pose_prompt_(); return; }

    uint32_t now = s.t_ms;
    if ((uint32_t)(now - pose_t0_ms_) > POSE_TIMEOUT_MS) {
      Serial.printf("\n[POSE] TIMEOUT on pose %u. Send 'r' to restart.\n", (unsigned)pose_idx_);
      stage_ = ST_WAIT_RESTART;
      return;
    }

    Vec3 au = safe_unit(s.acc, Vec3(0,0,1));
    const PoseSpec& spec = POSE_SPECS_[pose_idx_];

    float dot_up = 0.0f;
    if (poses_[POSE_UP].valid) dot_up = clampf(poses_[POSE_UP].acc_unit.dot(au), -1.0f, 1.0f);

    bool cond_ok = false;
    switch (spec.cond) {
      case COND_NONE: cond_ok = true; break;
      case COND_OPPOSITE_UP: cond_ok = poses_[POSE_UP].valid && (dot_up < DOWN_DOT_MAX); break;
      case COND_ORTHO_UP: cond_ok = poses_[POSE_UP].valid && (std::fabs(dot_up) < ORTHO_ABS_DOT_MAX); break;
      case COND_ORTHO_UP_DISTINCT: {
        if (!poses_[POSE_UP].valid || !poses_[POSE_RIGHT].valid) { cond_ok = false; break; }
        float dot_right = clampf(poses_[POSE_RIGHT].acc_unit.dot(au), -1.0f, 1.0f);
        cond_ok = (std::fabs(dot_up) < ORTHO_ABS_DOT_MAX) && (std::fabs(dot_right) < EDGE_DISTINCT_MAX);
      } break;
    }

    if (pose_sub_ == PS_SETTLE) {
      if ((int32_t)(now - settle_until_ms_) < 0) {
        if ((uint32_t)(now - last_pose_print_ms_) > 800) {
          last_pose_print_ms_ = now;
          Serial.printf("[POSE] %s  settling... %ums remaining  a_unit=[%.3f %.3f %.3f]\n",
                        spec.step, (unsigned)(settle_until_ms_ - now), au.x(), au.y(), au.z());
        }
        return;
      }
      pose_sub_ = PS_WAIT_MATCH;
      match_start_ms_ = 0;
      stable_start_ms_ = 0;
      poses_[pose_idx_].avg.reset();
    }

    if (pose_sub_ == PS_WAIT_MATCH) {
      if (!cond_ok) match_start_ms_ = 0;
      else {
        if (match_start_ms_ == 0) match_start_ms_ = now;
        if ((uint32_t)(now - match_start_ms_) >= MATCH_HOLD_MS) {
          pose_sub_ = PS_STABLE;
          stable_start_ms_ = 0;
          poses_[pose_idx_].avg.reset();
        }
      }

      if ((uint32_t)(now - last_pose_print_ms_) > 900) {
        last_pose_print_ms_ = now;
        if (spec.cond == COND_OPPOSITE_UP)
          Serial.printf("[POSE] %s  waiting_pose_change  dot_up=%.3f (need < %.2f)\n", spec.step, dot_up, DOWN_DOT_MAX);
        else if (spec.cond == COND_ORTHO_UP)
          Serial.printf("[POSE] %s  waiting_pose_change  |dot_up|=%.3f (need < %.2f)\n", spec.step, std::fabs(dot_up), ORTHO_ABS_DOT_MAX);
        else if (spec.cond == COND_ORTHO_UP_DISTINCT) {
          float dot_right = poses_[POSE_RIGHT].valid ? clampf(poses_[POSE_RIGHT].acc_unit.dot(au), -1.0f, 1.0f) : 0.0f;
          Serial.printf("[POSE] %s  waiting_pose_change  |dot_up|=%.3f<%.2f and |dot_right|=%.3f<%.2f\n",
                        spec.step, std::fabs(dot_up), ORTHO_ABS_DOT_MAX, std::fabs(dot_right), EDGE_DISTINCT_MAX);
        } else {
          Serial.printf("[POSE] %s  waiting\n", spec.step);
        }
      }
      return;
    }

    // Stable capture (forgiving)
    float gyro_n = safe_norm(s.gyr);
    bool stable_ok = (gyro_n < 2.0f);
    if (!stable_ok) { stable_start_ms_ = 0; poses_[pose_idx_].avg.reset(); }
    else {
      if (stable_start_ms_ == 0) stable_start_ms_ = now;
      poses_[pose_idx_].avg.add(s);

      uint32_t stable_ms = now - stable_start_ms_;
      if ((uint32_t)(now - last_pose_print_ms_) > 800) {
        last_pose_print_ms_ = now;
        Serial.printf("[POSE] %s  stable=%ums/%u  gyro_norm=%.3f  n=%d\n",
                      spec.step, stable_ms, (unsigned)POSE_STABLE_MS, gyro_n, poses_[pose_idx_].avg.n);
      }

      if (stable_ms >= POSE_STABLE_MS && poses_[pose_idx_].avg.n > 40) {
        poses_[pose_idx_].finalize_unit(Vec3(0,0,1));
        Serial.printf("[POSE] OK: pose %u captured  samples=%d (mag_samples=%d)\n",
                      (unsigned)pose_idx_, poses_[pose_idx_].avg.n, poses_[pose_idx_].avg.nmag);

        pose_idx_ = (PoseId)(pose_idx_ + 1);
        pose_sub_ = PS_PROMPT;

        if (pose_idx_ >= POSE_COUNT) stage_ = ST_SOLVE_ACCEL;
      }
    }
  }

  // -------- Accel solve --------
  float score_dir_(const Vec3& v, const Vec3& target_unit) const { return safe_unit(v).dot(target_unit); }

  bool build_mapping_from_poses_(SignedPerm& out_map, float& out_best, float& out_second) const {
    Vec3 aZu = poses_[POSE_UP].avg.acc_mean();
    Vec3 aZd = poses_[POSE_DOWN].avg.acc_mean();
    Vec3 aX  = poses_[POSE_RIGHT].avg.acc_mean();
    Vec3 aY  = poses_[POSE_TOP].avg.acc_mean();

    const Vec3 tZu(0,0, 1), tZd(0,0,-1);
    const Vec3 tX (-1,0,0), tY (0,-1,0); // right-edge-down -> -X, top-edge-down -> -Y

    SignedPerm perms[64];
    int nperm = enumerate_perms_(perms, 64, false);

    float best = -1e9f, second = -1e9f;
    SignedPerm bestp = perms[0];

    for (int i=0;i<nperm;i++) {
      Vec3 mZu = apply_perm_(perms[i], aZu);
      Vec3 mZd = apply_perm_(perms[i], aZd);
      Vec3 mX  = apply_perm_(perms[i], aX);
      Vec3 mY  = apply_perm_(perms[i], aY);

      float sc = 0.0f;
      sc += 2.8f * score_dir_(mZu, tZu);
      sc += 2.3f * score_dir_(mZd, tZd);
      sc += 2.0f * score_dir_(mX,  tX);
      sc += 2.0f * score_dir_(mY,  tY);

      if (sc > best) { second = best; best = sc; bestp = perms[i]; }
      else if (sc > second) { second = sc; }
    }

    out_map = bestp;
    out_best = best;
    out_second = second;
    return (best > 6.0f) && ((best - second) > 0.12f);
  }

  float choose_acc_scale_mps2_(const SignedPerm& map_screen) const {
    float mags[4] = {
      safe_norm(apply_perm_(map_screen, poses_[POSE_UP].avg.acc_mean())),
      safe_norm(apply_perm_(map_screen, poses_[POSE_DOWN].avg.acc_mean())),
      safe_norm(apply_perm_(map_screen, poses_[POSE_RIGHT].avg.acc_mean())),
      safe_norm(apply_perm_(map_screen, poses_[POSE_TOP].avg.acc_mean()))
    };
    float m = 0.25f*(mags[0]+mags[1]+mags[2]+mags[3]);

    if (m > 0.35f && m < 2.3f) return G_STD; // g -> m/s^2
    if (m > 4.0f  && m < 15.0f) return 1.0f; // already m/s^2
    return (m > 1e-6f) ? (G_STD / m) : 1.0f;
  }

  bool solve_accel_() {
    float best=0, second=0;
    SignedPerm map_screen;
    bool ok = build_mapping_from_poses_(map_screen, best, second);
    Serial.printf("\n[ACCEL] solve score best=%.3f second=%.3f margin=%.3f\n", best, second, best-second);
    if (!ok) return false;

    map_acc_screen_ = map_screen;
    acc_scale_mps2_ = choose_acc_scale_mps2_(map_acc_screen_);
    Serial.println("[ACCEL] Solved mapping + scale. Proceeding to rotation...");
    return true;
  }

  // -------- Rotation step (robust) --------
  void enter_rotation_() {
    print_sep_(
      "STEP 5/5:\n"
      "Place device SCREEN UP (flat).\n"
      "Rotate CLOCKWISE slowly for ~8 seconds.\n"
      "You may start rotating immediately.\n"
      "(r restart, v verbose, a force arm, c force capture.)"
    );

    rot_.reset();
    rot_sub_ = RS_WAIT_ARM;
    rot_arm_start_ms_ = 0;
    rot_motion_start_ms_ = 0;
    rot_capture_t0_ms_ = 0;
    rot_last_print_ms_ = 0;
    rot_have_flat_ref_ = false;
    force_arm_ = false;
    force_capture_ = false;

    Serial.printf("[ROT] Will capture for FULL %u ms once started.\n", (unsigned)ROT_CAPTURE_MS);
    Serial.println("[ROT] Waiting: flat-ish + screen-up-ish OR motion...");
  }

  bool tick_rotation_(const IMUSample& s) {
    const uint32_t now = s.t_ms;
    Vec3 au = safe_unit(s.acc, Vec3(0,0,1));
    float gyro_norm = safe_norm(s.gyr);

    if (!rot_have_flat_ref_) { rot_flat_ref_ = au; rot_have_flat_ref_ = true; }
    float cos_flat = clampf(au.dot(rot_flat_ref_), -1.0f, 1.0f);

    float dot_up = poses_[POSE_UP].valid ? clampf(poses_[POSE_UP].acc_unit.dot(au), -1.0f, 1.0f) : 1.0f;
    bool upish = (dot_up > ROT_UPISH_DOT_MIN);
    bool flatish = (cos_flat > ROT_FLAT_COS_MIN);
    bool moving = (gyro_norm > ROT_GYRO_START_RAW);

    if (force_capture_) {
      force_capture_ = false;
      rot_sub_ = RS_CAPTURE;
      rot_capture_t0_ms_ = now;
      rot_.reset();
      rot_flat_ref_ = au;
      rot_have_flat_ref_ = true;
      Serial.println("[ROT] Forced capture start. Capturing for full 8 seconds now...");
    }

    if (rot_sub_ == RS_WAIT_ARM) {
      // If already rotating while up+flat, start quickly
      if (moving && upish && flatish) {
        if (rot_motion_start_ms_ == 0) rot_motion_start_ms_ = now;
        if ((uint32_t)(now - rot_motion_start_ms_) >= ROT_MOTION_HOLD_MS) {
          rot_sub_ = RS_CAPTURE;
          rot_capture_t0_ms_ = now;
          rot_.reset();
          rot_flat_ref_ = au;
          rot_have_flat_ref_ = true;
          Serial.println("[ROT] Rotation detected. Capturing for full 8 seconds now...");
        }
      } else {
        rot_motion_start_ms_ = 0;
        bool arm_ok = upish && flatish;
        if (!arm_ok) rot_arm_start_ms_ = 0;
        else {
          if (rot_arm_start_ms_ == 0) rot_arm_start_ms_ = now;
          if ((uint32_t)(now - rot_arm_start_ms_) >= ROT_ARM_HOLD_MS || force_arm_) {
            force_arm_ = false;
            rot_sub_ = RS_WAIT_MOTION;
            rot_motion_start_ms_ = 0;
            Serial.println("[ROT] ARMED. Start rotating now (clockwise, keep it flat-ish)...");
          }
        }
      }

      if ((uint32_t)(now - rot_last_print_ms_) > 900) {
        rot_last_print_ms_ = now;
        Serial.printf("[ROT] arming... up_dot=%.3f(%s) cos_flat=%.4f(%s) gyro=%.3f(%s)\n",
                      dot_up, upish?"ok":"no",
                      cos_flat, flatish?"ok":"no",
                      gyro_norm, moving?"moving":"still");
      }
      return false;
    }

    if (rot_sub_ == RS_WAIT_MOTION) {
      if (moving && upish && flatish) {
        if (rot_motion_start_ms_ == 0) rot_motion_start_ms_ = now;
        if ((uint32_t)(now - rot_motion_start_ms_) >= ROT_MOTION_HOLD_MS) {
          rot_sub_ = RS_CAPTURE;
          rot_capture_t0_ms_ = now;
          rot_.reset();
          rot_flat_ref_ = au;
          rot_have_flat_ref_ = true;
          Serial.println("[ROT] Motion confirmed. Capturing for full 8 seconds now...");
        }
      } else rot_motion_start_ms_ = 0;

      if ((uint32_t)(now - rot_last_print_ms_) > 900) {
        rot_last_print_ms_ = now;
        Serial.printf("[ROT] waiting motion... up_dot=%.3f cos_flat=%.4f gyro=%.3f (need > %.2f)\n",
                      dot_up, cos_flat, gyro_norm, ROT_GYRO_START_RAW);
      }
      return false;
    }

    // CAPTURE: strictly time-based
    const uint32_t elapsed = now - rot_capture_t0_ms_;
    const uint32_t left = (elapsed >= ROT_CAPTURE_MS) ? 0 : (ROT_CAPTURE_MS - elapsed);

    bool flat_enough = (cos_flat > 0.975f);
    if (flat_enough) rot_.push(s);

    if ((uint32_t)(now - rot_last_print_ms_) > 900) {
      rot_last_print_ms_ = now;
      Serial.printf("[ROT] t_left=%ums stored=%d cos_flat=%.4f gyro=%.3f mag=%s\n",
                    (unsigned)left, rot_.n, cos_flat, gyro_norm, s.have_mag?"yes":"no");
    }

    if (elapsed >= ROT_CAPTURE_MS) {
      Serial.printf("[ROT] Done. Duration=%ums. Stored %d samples.\n", (unsigned)elapsed, rot_.n);
      return (rot_.n >= 160);
    }
    return false;
  }

  // -------- Mag mapping + final report (kept concise) --------
  float corrcoef_(const float* x, const float* y, int n) const {
    if (n < 16) return 0.0f;
    double sx=0, sy=0, sxx=0, syy=0, sxy=0;
    for (int i=0;i<n;i++) { sx += x[i]; sy += y[i]; }
    double mx = sx / n, my = sy / n;
    for (int i=0;i<n;i++) {
      double dx = x[i]-mx, dy = y[i]-my;
      sxx += dx*dx; syy += dy*dy; sxy += dx*dy;
    }
    if (sxx <= 1e-12 || syy <= 1e-12) return 0.0f;
    return (float)(sxy / std::sqrt(sxx*syy));
  }

  bool compute_heading_(const SignedPerm& mag_perm, const IMUSample& s, float& out_psi, float& out_mh) const {
    if (!s.have_mag) return false;
    Vec3 z_up = safe_unit(apply_perm_(map_acc_screen_, s.acc), Vec3(0,0,1));
    Vec3 m_scr = apply_perm_(mag_perm, s.mag);
    float mz = m_scr.dot(z_up);
    Vec3 m_h = m_scr - mz * z_up;
    out_mh = safe_norm(m_h);
    if (!(out_mh > 1e-6f)) return false;
    out_psi = std::atan2(m_h.y(), m_h.x());
    return std::isfinite(out_psi);
  }

  SignedPerm find_best_mag_(float& out_corr, float& out_span, float& out_unwrap, float& out_mhmean, int& out_k) const {
    SignedPerm perms[64];
    int nperm = enumerate_perms_(perms, 64, true);

    static float wz[MAX_ROT_SAMPLES];
    static float hrate[MAX_ROT_SAMPLES];

    float bestScore = -1e9f;
    SignedPerm bestP = perms[0];

    out_corr=0; out_span=0; out_unwrap=0; out_mhmean=0; out_k=0;

    for (int pi=0; pi<nperm; ++pi) {
      bool init=false;
      float psi_prev=0, psi_unwrap=0, psi_min=1e9f, psi_max=-1e9f;
      double mh_sum=0; int mh_n=0;
      int k=0;

      for (int i=1;i<rot_.n;i++) {
        const auto& s1 = rot_.s[i];
        const auto& s0 = rot_.s[i-1];
        float dt = (float)(s1.t_ms - s0.t_ms)*1e-3f;
        if (!(dt>0.001f && dt<0.1f)) continue;

        Vec3 g_scr = apply_perm_(map_acc_screen_, s1.gyr);
        wz[k] = g_scr.z();

        float psi=0, mh=0;
        if (!compute_heading_(perms[pi], s1, psi, mh)) continue;
        if (mh < 1e-3f) continue;
        mh_sum += mh; mh_n++;

        if (!init) { init=true; psi_prev=psi; psi_unwrap=psi; psi_min=psi; psi_max=psi; continue; }
        float dpsi = wrap_pi_(psi - psi_prev);
        psi_prev = psi;
        psi_unwrap += dpsi;
        psi_min = std::min(psi_min, psi_unwrap);
        psi_max = std::max(psi_max, psi_unwrap);
        hrate[k] = dpsi / dt;

        k++; if (k>=MAX_ROT_SAMPLES) break;
      }

      if (k < 140 || mh_n < 140) continue;

      float corr = corrcoef_(wz, hrate, k);
      float span = psi_max - psi_min;
      float mhmean = (float)(mh_sum / std::max(1, mh_n));

      float score = 3.5f*std::fabs(corr) + 0.12f*span;
      if (span < 1.2f) score -= 2.0f;

      if (score > bestScore) {
        bestScore = score;
        bestP = perms[pi];
        out_corr = corr;
        out_span = span;
        out_unwrap = psi_unwrap;
        out_mhmean = mhmean;
        out_k = k;
      }
    }
    return bestP;
  }

  float choose_mag_scale_uT_(float mh_raw) const {
    const float cand[] = {1.0f, 0.1f, 10.0f, 0.01f, 100.0f};
    float best=cand[0], bestCost=1e9f;
    for (float s : cand) {
      float uT = mh_raw*s;
      float cost=0;
      if (uT < 5.0f)  cost += (5.0f-uT)*(5.0f-uT);
      if (uT > 80.0f) cost += (uT-80.0f)*(uT-80.0f);
      cost += 0.01f*(uT-25.0f)*(uT-25.0f);
      if (cost < bestCost) { bestCost=cost; best=s; }
    }
    return best;
  }

  float choose_gyro_scale_radps_(float heading_unwrap, float gyro_int_raw) const {
    const float DEG2RAD = (float)M_PI / 180.0f;
    if (std::isfinite(heading_unwrap) && std::isfinite(gyro_int_raw) && std::fabs(gyro_int_raw) > 1e-6f) {
      float s = std::fabs(heading_unwrap / gyro_int_raw);
      float d0 = std::fabs(s - 1.0f);
      float d1 = std::fabs(s - DEG2RAD);
      return (d1 < 0.5f*d0) ? DEG2RAD : s;
    }
    return DEG2RAD;
  }

  void solve_mag_gyro_and_print_() {
    int magCount=0;
    for (int i=0;i<rot_.n;i++) if (rot_.s[i].have_mag) magCount++;
    have_mag_ = (magCount > 150);

    float corr=0, span=0, unwrap=0, mh_raw=0;
    int pairs=0;

    if (have_mag_) {
      map_mag_screen_ = find_best_mag_(corr, span, unwrap, mh_raw, pairs);
      mag_scale_uT_ = choose_mag_scale_uT_(mh_raw);
    } else {
      map_mag_screen_ = make_perm_(0,+1,1,+1,2,+1);
      mag_scale_uT_ = 1.0f;
    }

    double gyro_int=0;
    for (int i=1;i<rot_.n;i++) {
      float dt = (float)(rot_.s[i].t_ms - rot_.s[i-1].t_ms)*1e-3f;
      if (!(dt>0.001f && dt<0.1f)) continue;
      Vec3 g_scr = apply_perm_(map_acc_screen_, rot_.s[i].gyr);
      gyro_int += (double)g_scr.z() * (double)dt;
    }
    gyro_scale_radps_ = choose_gyro_scale_radps_(unwrap, (float)gyro_int);

    SignedPerm acc_body = screen_to_body_ned_like_(map_acc_screen_);
    SignedPerm gyr_body = acc_body;
    SignedPerm mag_body = screen_to_body_ned_like_(map_mag_screen_);

    char acc_map[32], gyr_map[32], mag_map[32];
    perm_to_triplet_(acc_body, acc_map, sizeof(acc_map));
    perm_to_triplet_(gyr_body, gyr_map, sizeof(gyr_map));
    perm_to_triplet_(mag_body, mag_map, sizeof(mag_map));

    Serial.println();
    Serial.println("============================================================");
    Serial.println("                 IMU MAPPING (REPORT)");
    Serial.println(" BODY_NED-like output: +X right, +Y top, +Z down");
    Serial.println("============================================================");

    Serial.println("\nSCALE FACTORS (multiply RAW):");
    Serial.printf("  ACC_SCALE_MPS2   = %.9g    // raw_acc  * this => m/s^2\n", acc_scale_mps2_);
    Serial.printf("  GYRO_SCALE_RADPS = %.9g    // raw_gyro * this => rad/s\n", gyro_scale_radps_);
    if (have_mag_) Serial.printf("  MAG_SCALE_UT     = %.9g    // raw_mag  * this => uT\n", mag_scale_uT_);
    else           Serial.println("  MAG_SCALE_UT     = (mag unavailable)");

    Serial.println("\nAXIS MAPS (RAW -> BODY_NED-like):");
    Serial.printf("  ACC_MAP  = [ %s ]\n", acc_map);
    Serial.printf("  GYRO_MAP = [ %s ]\n", gyr_map);
    if (have_mag_) Serial.printf("  MAG_MAP  = [ %s ]\n", mag_map);

    if (have_mag_) {
      Serial.println("\nMAG RELIABILITY:");
      Serial.printf("  pairs_used=%d  mag_samples=%d\n", pairs, magCount);
      Serial.printf("  corr_signed=%.3f  |corr|=%.3f\n", corr, std::fabs(corr));
      Serial.printf("  heading_span=%.2f rad (%.1f deg)\n", span, span*180.0f/(float)M_PI);
      Serial.printf("  magH_mean_raw=%.3f -> scaled=%.2f uT\n", mh_raw, mh_raw*mag_scale_uT_);
      if (span < 1.2f || std::fabs(corr) < 0.30f)
        Serial.println("  WARNING: weak rotation signal; MAG_MAP may be ambiguous.");
    }

    Serial.println("\nSend 'r' to restart.");
    Serial.println("============================================================");
  }
};

constexpr IMUWizard::PoseSpec IMUWizard::POSE_SPECS_[IMUWizard::POSE_COUNT];

static IMUWizard g_wiz;

void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);
  delay(350);
  g_wiz.begin();
}

void loop() {
  g_wiz.update();
}
