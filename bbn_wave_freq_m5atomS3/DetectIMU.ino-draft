/*
  AtomS3R (M5Unified) â€” Pose Wizard (PROMPT -> CHANGE POSE -> STEADY -> CAPTURE)

  What it does (exactly as you asked):
    1) Prompts for SCREEN UP first
    2) Waits until you ACTUALLY change pose appropriately
    3) Requires that new pose stays steady for SETTLE_MS
    4) Captures stable samples for CAPTURE_MS
    5) Only then advances to next pose

  Important:
    - Step labels are instructions, not classification.
    - Press BtnA anytime to restart to STEP 1 (helpful if you opened Serial late).
*/

#include <M5Unified.h>
#include <cmath>
#include <cstdint>
#include <algorithm>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
#define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif
#ifdef EIGEN_NON_ARDUINO
  #include <Eigen/Dense>
#else
  #include <ArduinoEigenDense.h>
#endif

#ifdef ARDUINO_ARCH_ESP32
  #include "esp_timer.h"
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

class IMUWizard {
public:
  using Vec3 = Eigen::Matrix<float,3,1>;

  // ----------- Config -----------
  static constexpr float    ACC_GYR_RATE_HZ = 200.0f;
  static constexpr float    MAG_RATE_HZ     = 50.0f;

  static constexpr uint32_t SETTLE_MS       = 2500;   // must be steady this long after pose-change detected
  static constexpr uint32_t CAPTURE_MS      = 1400;   // capture duration once settled
  static constexpr uint32_t STEP_TIMEOUT_MS = 60000;  // per-step timeout
  static constexpr uint32_t PROMPT_REPRINT_MS = 2500; // keep repeating prompt so you never "miss" step 1

  // Pose-change relation thresholds vs previous captured gravity direction (unit accel)
  static constexpr float DOT_OPPOSITE_MAX   = -0.92f;  // must be <= this to count as "flipped"
  static constexpr float DOT_ORTHO_ABS_MAX  = 0.35f;   // must be <= this to count as "edge/orthogonal"

  // "hold still" gating
  static constexpr float HOLD_COS_MIN       = 0.9992f; // ~2.3 deg
  static constexpr float ACC_NORM_REL_MAX   = 0.03f;   // 3%
  static constexpr float GYRO_ABS_MAX_RAW   = 8.0f;
  static constexpr float GYRO_FLOOR_RAW     = 0.35f;

  // ----------- Types -----------
  enum PoseRel { REL_ANY=0, REL_OPPOSITE, REL_ORTHO };

  struct IMUSample {
    int64_t t_us = 0;
    Vec3 acc = Vec3::Zero();
    Vec3 gyr = Vec3::Zero();
    Vec3 mag = Vec3::Zero();
    bool have_mag = false;
  };

  struct PoseAvg {
    Vec3 acc_sum = Vec3::Zero();
    Vec3 gyr_sum = Vec3::Zero();
    Vec3 mag_sum = Vec3::Zero();
    int n = 0;
    int nmag = 0;

    void reset() { acc_sum.setZero(); gyr_sum.setZero(); mag_sum.setZero(); n=0; nmag=0; }
    void add(const IMUSample& s) {
      acc_sum += s.acc;
      gyr_sum += s.gyr;
      n++;
      if (s.have_mag) { mag_sum += s.mag; nmag++; }
    }
    Vec3 acc_mean() const { return (n>0) ? (acc_sum / (float)n) : Vec3(0,0,0); }
  };

  // Mapping types (kept to stay close to your wizard flow)
  struct SignedPerm {
    int8_t idx[3] = {0,1,2};
    int8_t sgn[3] = {+1,+1,+1};
    int8_t det    = +1;
  };

  // ----------- Public API -----------
  void begin() {
    setup_rates_();
    stage_ = ST_STEP1;
    prev_pose_valid_ = false;

    Serial.println();
    Serial.println("============================================================");
    Serial.println("IMU Pose Wizard");
    Serial.println("STEP 1 is ALWAYS SCREEN UP first.");
    Serial.println("It will NOT advance until you change pose correctly + hold steady.");
    Serial.println("Press BtnA anytime to restart to STEP 1.");
    Serial.println("============================================================");

    enter_step_(1,
      "Place device SCREEN UP on a flat surface.\n"
      "Wait for pose detection, then hold still...",
      "SCREEN UP (flat)", REL_ANY);
  }

  void update() {
    M5.update();
    if (M5.BtnA.wasPressed()) {
      Serial.println("[USER] BtnA pressed -> Restarting to STEP 1.");
      restart_();
      return;
    }

    IMUSample s;
    bool got_acc=false, got_mag=false;
    if (!scheduled_poll_(s, got_acc, got_mag)) { delay(1); return; }
    if (!got_acc) return;

    update_step_(s);
  }

private:
  // ----------- Stage enum -----------
  enum Stage { ST_STEP1=0, ST_STEP2, ST_STEP3, ST_STEP4, ST_SOLVE, ST_DONE };
  Stage stage_ = ST_STEP1;

  // ----------- Step context -----------
  int step_idx_ = 1;
  const char* step_pose_name_ = nullptr;
  PoseRel step_rel_ = REL_ANY;

  int64_t step_start_us_    = 0;
  int64_t settle_start_us_  = 0;
  int64_t capture_start_us_ = 0;

  int64_t last_prompt_reprint_us_ = 0;
  int64_t last_status_print_us_   = 0;

  Vec3 hold_ref_unit_ = Vec3(0,0,1);
  bool hold_ref_valid_ = false;

  PoseAvg step_avg_;
  PoseAvg pose1_, pose2_, pose3_, pose4_;

  // Previous captured pose gravity direction (unit accel)
  Vec3 prev_pose_unit_ = Vec3(0,0,1);
  bool prev_pose_valid_ = false;

  // ----------- Scheduler -----------
  int64_t next_acc_us_ = 0;
  int64_t next_mag_us_ = 0;
  int64_t acc_period_us_ = 0;
  int64_t mag_period_us_ = 0;

  uint32_t acc_ticks_ = 0;
  uint32_t mag_valid_ticks_ = 0;
  int64_t rate_t0_us_ = 0;
  int64_t rate_last_print_us_ = 0;

  IMUSample last_sample_;
  int64_t last_sample_us_ = 0;

  // ----------- Solve outputs (minimal) -----------
  SignedPerm map_acc_screen_;
  float acc_scale_mps2_ = 1.0f;

  // ----------- Utilities -----------
  static inline int64_t now_us_() {
  #ifdef ARDUINO_ARCH_ESP32
    return (int64_t)esp_timer_get_time();
  #else
    return (int64_t)micros();
  #endif
  }
  static inline float clampf(float x, float a, float b) { return std::max(a, std::min(b, x)); }

  static inline float safe_norm_(const Vec3& v) {
    float n = v.norm();
    return (std::isfinite(n) && n > 1e-12f) ? n : 0.0f;
  }
  static inline Vec3 safe_unit_(const Vec3& v, const Vec3& fallback=Vec3(0,0,1)) {
    float n = safe_norm_(v);
    return (n > 0.0f) ? (v / n) : fallback;
  }

  void enter_step_(int idx, const char* prompt, const char* pose_name, PoseRel rel) {
    step_idx_ = idx;
    step_pose_name_ = pose_name;
    step_rel_ = rel;

    step_start_us_ = now_us_();
    settle_start_us_ = 0;
    capture_start_us_ = 0;
    hold_ref_valid_ = false;
    step_avg_.reset();

    last_prompt_reprint_us_ = 0;
    last_status_print_us_ = 0;

    Serial.println();
    Serial.println("============================================================");
    Serial.printf("STEP %d/5:\n%s\n", idx, prompt);
    Serial.println("============================================================");
  }

  void restart_() {
    stage_ = ST_STEP1;
    prev_pose_valid_ = false;
    last_sample_us_ = 0;
    enter_step_(1,
      "Place device SCREEN UP on a flat surface.\n"
      "Wait for pose detection, then hold still...",
      "SCREEN UP (flat)", REL_ANY);
  }

  // ----------- IMU read -----------
  bool read_imu_once_(IMUSample& out) {
    (void)M5.Imu.update();
    auto d = M5.Imu.getImuData();
    out.t_us = now_us_();
    out.acc  = Vec3(d.accel.x, d.accel.y, d.accel.z);
    out.gyr  = Vec3(d.gyro.x,  d.gyro.y,  d.gyro.z);
    out.mag  = Vec3(d.mag.x,   d.mag.y,   d.mag.z);
    out.have_mag =
      std::isfinite(out.mag.x()) && std::isfinite(out.mag.y()) && std::isfinite(out.mag.z()) &&
      (std::fabs(out.mag.x()) + std::fabs(out.mag.y()) + std::fabs(out.mag.z()) > 1e-6f);
    return true;
  }

  void setup_rates_() {
    auto hz_to_period = [](float hz)->int64_t {
      if (!(hz > 0.1f)) hz = 1.0f;
      double p = 1000000.0 / (double)hz;
      if (p < 1000.0) p = 1000.0;
      return (int64_t)llround(p);
    };

    acc_period_us_ = hz_to_period(ACC_GYR_RATE_HZ);
    mag_period_us_ = hz_to_period(MAG_RATE_HZ);

    int64_t now = now_us_();
    next_acc_us_ = now + acc_period_us_;
    next_mag_us_ = now + mag_period_us_;

    rate_t0_us_ = now;
    rate_last_print_us_ = now;
    acc_ticks_ = mag_valid_ticks_ = 0;
  }

  void maybe_print_rate_(bool have_mag) {
    int64_t now = now_us_();
    if (now - rate_last_print_us_ < 1000000) return;
    rate_last_print_us_ = now;

    double dt = (now - rate_t0_us_) * 1e-6;
    if (dt <= 0.0) dt = 1.0;

    float acc_hz = (float)(acc_ticks_ / dt);
    float mag_hz = (float)(mag_valid_ticks_ / dt);

    Serial.printf("[RATE] acc/gyro observed ~%.1f Hz (target %.1f)\n", acc_hz, ACC_GYR_RATE_HZ);
    Serial.printf("[RATE] mag observed     ~%.1f Hz (target %.1f) %s\n",
                  mag_hz, MAG_RATE_HZ, have_mag ? "" : "(mag may be unavailable)");

    rate_t0_us_ = now;
    acc_ticks_ = mag_valid_ticks_ = 0;
  }

  bool scheduled_poll_(IMUSample& out, bool& got_acc, bool& got_mag) {
    got_acc = false; got_mag = false;
    int64_t now = now_us_();

    bool due_acc = (now >= next_acc_us_);
    bool due_mag = (now >= next_mag_us_);
    if (!due_acc && !due_mag) return false;

    if (due_acc) {
      int64_t late = now - next_acc_us_;
      next_acc_us_ = (late > 2*acc_period_us_) ? (now + acc_period_us_) : (next_acc_us_ + acc_period_us_);
      got_acc = true;
      acc_ticks_++;
    }
    if (due_mag) {
      int64_t late = now - next_mag_us_;
      next_mag_us_ = (late > 2*mag_period_us_) ? (now + mag_period_us_) : (next_mag_us_ + mag_period_us_);
      got_mag = true;
    }

    read_imu_once_(last_sample_);
    out = last_sample_;
    if (got_mag && out.have_mag) mag_valid_ticks_++;
    maybe_print_rate_(out.have_mag);
    return true;
  }

  // ----------- Simple EWMAs for steadiness -----------
  struct Ema {
    float v = 0.0f;
    bool init = false;
    void reset(){ v=0; init=false; }
    float update(float x, float a){
      if (!init){ v=x; init=true; return v; }
      v = (1.0f-a)*v + a*x;
      return v;
    }
  };
  Ema acc_norm_ema_;
  Ema gyro_norm_ema_;

  bool steady_enough_(const IMUSample& s, const Vec3& unit_now, float dt_s,
                      float* out_cos_ref, float* out_gn, float* out_th, float* out_an_rel)
  {
    const float alpha = clampf(dt_s / 0.35f, 0.01f, 0.25f);

    float an = safe_norm_(s.acc);
    float gn = safe_norm_(s.gyr);
    float an_ema = acc_norm_ema_.update(an, alpha);
    float gn_ema = gyro_norm_ema_.update(gn, alpha);

    float gyro_th = std::max(GYRO_FLOOR_RAW, 3.0f * gn_ema + GYRO_FLOOR_RAW);
    float an_rel  = (an_ema > 1e-6f) ? std::fabs(an - an_ema) / an_ema : 0.0f;

    if (!hold_ref_valid_) {
      hold_ref_unit_ = unit_now;
      hold_ref_valid_ = true;
    }

    float cos_ref = clampf(unit_now.dot(hold_ref_unit_), -1.0f, 1.0f);

    bool ok = (cos_ref > HOLD_COS_MIN) &&
              (gn < gyro_th) &&
              (gn < GYRO_ABS_MAX_RAW) &&
              (an_rel < ACC_NORM_REL_MAX);

    if (out_cos_ref) *out_cos_ref = cos_ref;
    if (out_gn) *out_gn = gn;
    if (out_th) *out_th = gyro_th;
    if (out_an_rel) *out_an_rel = an_rel;

    // If it drifted, reset reference so "steady" means steady *now*
    if (cos_ref < HOLD_COS_MIN) {
      hold_ref_unit_ = unit_now;
      hold_ref_valid_ = true;
    }
    return ok;
  }

  bool relation_ok_(PoseRel rel, const Vec3& unit_now, float* out_dotPrev, float* out_absDotPrev) {
    float dotPrev = 0.0f, absDotPrev = 0.0f;
    if (prev_pose_valid_) {
      dotPrev = clampf(unit_now.dot(prev_pose_unit_), -1.0f, 1.0f);
      absDotPrev = std::fabs(dotPrev);
    }
    if (out_dotPrev) *out_dotPrev = dotPrev;
    if (out_absDotPrev) *out_absDotPrev = absDotPrev;

    if (rel == REL_ANY) return true;
    if (!prev_pose_valid_) return false;

    if (rel == REL_OPPOSITE) return (dotPrev <= DOT_OPPOSITE_MAX);
    return (absDotPrev <= DOT_ORTHO_ABS_MAX);
  }

  void maybe_reprint_prompt_() {
    int64_t t = now_us_();
    if (last_prompt_reprint_us_ == 0) { last_prompt_reprint_us_ = t; return; }
    if ((t - last_prompt_reprint_us_) < (int64_t)PROMPT_REPRINT_MS * 1000) return;
    last_prompt_reprint_us_ = t;

    Serial.println();
    Serial.println("------------------------------------------------------------");
    Serial.printf("CURRENT STEP %d/5: %s\n", step_idx_, step_pose_name_);
    if (step_idx_ == 1) Serial.println("Instruction: Put it SCREEN UP and hold still.");
    if (step_idx_ == 2) Serial.println("Instruction: Flip to SCREEN DOWN (must be opposite of Step 1).");
    if (step_idx_ == 3) Serial.println("Instruction: Stand on RIGHT EDGE (must be orthogonal to Step 2).");
    if (step_idx_ == 4) Serial.println("Instruction: Stand on TOP EDGE (must be orthogonal to Step 3).");
    Serial.println("Press BtnA to restart if you missed Step 1.");
    Serial.println("------------------------------------------------------------");
  }

  void update_step_(const IMUSample& s) {
    maybe_reprint_prompt_();

    int64_t now = s.t_us;
    float dt_s = 0.01f;
    if (last_sample_us_ != 0) {
      dt_s = (float)((now - last_sample_us_) * 1e-6);
      if (!(dt_s > 0.0f && dt_s < 0.5f)) dt_s = 0.01f;
    }
    last_sample_us_ = now;

    Vec3 unit_now = safe_unit_(s.acc, Vec3(0,0,1));

    float dotPrev=0, absDotPrev=0;
    bool rel_ok = relation_ok_(step_rel_, unit_now, &dotPrev, &absDotPrev);

    float cos_ref=0, gn=0, th=0, an_rel=0;
    bool steady_ok = steady_enough_(s, unit_now, dt_s, &cos_ref, &gn, &th, &an_rel);

    // 1) WAIT FOR POSE CHANGE (if required)
    if (!rel_ok) {
      // Hard stop: do not start settle/capture
      settle_start_us_ = 0;
      capture_start_us_ = 0;
      hold_ref_valid_ = false;
      step_avg_.reset();

      if (now_us_() - last_status_print_us_ > 900000) {
        last_status_print_us_ = now_us_();
        if (step_rel_ == REL_OPPOSITE) {
          Serial.printf("[POSE] %s  waiting_pose_change: need dotPrev <= %.2f (flip). dotPrev=%.3f\n",
                        step_pose_name_, DOT_OPPOSITE_MAX, dotPrev);
        } else if (step_rel_ == REL_ORTHO) {
          Serial.printf("[POSE] %s  waiting_pose_change: need |dotPrev| <= %.2f (edge). |dotPrev|=%.3f\n",
                        step_pose_name_, DOT_ORTHO_ABS_MAX, absDotPrev);
        } else {
          Serial.printf("[POSE] %s  waiting_pose_change\n", step_pose_name_);
        }
      }

      if ((now_us_() - step_start_us_) > (int64_t)STEP_TIMEOUT_MS * 1000) {
        Serial.printf("[POSE] TIMEOUT in %s -> restarting.\n", step_pose_name_);
        restart_();
      }
      return;
    }

    // 2) POSE CHANGED ENOUGH; NOW REQUIRE STEADY FOR SETTLE_MS
    if (!steady_ok) {
      settle_start_us_ = 0;
      capture_start_us_ = 0;
      step_avg_.reset();

      if (now_us_() - last_status_print_us_ > 900000) {
        last_status_print_us_ = now_us_();
        Serial.printf("[POSE] %s  pose OK, but moving: cos=%.4f gyro=%.3f<th=%.3f aRel=%.3f\n",
                      step_pose_name_, cos_ref, gn, th, an_rel);
      }
      return;
    }

    if (settle_start_us_ == 0) {
      settle_start_us_ = now_us_();
      capture_start_us_ = 0;
      step_avg_.reset();
      Serial.printf("[POSE] %s  detected. Hold still... (settling %ums)\n",
                    step_pose_name_, (unsigned)SETTLE_MS);
      return;
    }

    uint32_t settle_ms = (uint32_t)((now_us_() - settle_start_us_) / 1000);
    if (settle_ms < SETTLE_MS) {
      if (now_us_() - last_status_print_us_ > 900000) {
        last_status_print_us_ = now_us_();
        Serial.printf("[POSE] %s  settling... %ums/%ums\n",
                      step_pose_name_, settle_ms, (unsigned)SETTLE_MS);
      }
      return;
    }

    // 3) SETTLED; NOW CAPTURE FOR CAPTURE_MS
    if (capture_start_us_ == 0) {
      capture_start_us_ = now_us_();
      step_avg_.reset();
      Serial.printf("[POSE] %s  settled. Capturing %ums...\n",
                    step_pose_name_, (unsigned)CAPTURE_MS);
    }

    // if we lose steadiness during capture, restart capture window
    if (!steady_ok) {
      capture_start_us_ = now_us_();
      step_avg_.reset();
      return;
    }

    step_avg_.add(s);

    uint32_t cap_ms = (uint32_t)((now_us_() - capture_start_us_) / 1000);
    if (cap_ms >= CAPTURE_MS && step_avg_.n > 30) {
      Vec3 a_mean = step_avg_.acc_mean();
      prev_pose_unit_ = safe_unit_(a_mean, unit_now);
      prev_pose_valid_ = true;

      Serial.printf("[POSE] OK: %s  samples=%d (mag_samples=%d)\n",
                    step_pose_name_, step_avg_.n, step_avg_.nmag);

      if (stage_ == ST_STEP1) pose1_ = step_avg_;
      if (stage_ == ST_STEP2) pose2_ = step_avg_;
      if (stage_ == ST_STEP3) pose3_ = step_avg_;
      if (stage_ == ST_STEP4) pose4_ = step_avg_;

      advance_stage_();
      return;
    }

    if ((now_us_() - step_start_us_) > (int64_t)STEP_TIMEOUT_MS * 1000) {
      Serial.printf("[POSE] TIMEOUT in %s -> restarting.\n", step_pose_name_);
      restart_();
    }
  }

  void advance_stage_() {
    acc_norm_ema_.reset();
    gyro_norm_ema_.reset();
    hold_ref_valid_ = false;
    last_status_print_us_ = 0;

    if (stage_ == ST_STEP1) {
      stage_ = ST_STEP2;
      enter_step_(2,
        "Flip device SCREEN DOWN on the same flat surface.\n"
        "It will wait until you actually flipped, then you hold still...",
        "SCREEN DOWN (flat)", REL_OPPOSITE);
      return;
    }
    if (stage_ == ST_STEP2) {
      stage_ = ST_STEP3;
      enter_step_(3,
        "Stand device on its RIGHT EDGE (screen facing you; right edge on table).\n"
        "It will wait until pose is orthogonal, then you hold still...",
        "RIGHT EDGE DOWN", REL_ORTHO);
      return;
    }
    if (stage_ == ST_STEP3) {
      stage_ = ST_STEP4;
      enter_step_(4,
        "Stand device on its TOP EDGE (screen facing you; top edge on table).\n"
        "It will wait until pose is orthogonal, then you hold still...",
        "TOP EDGE DOWN", REL_ORTHO);
      return;
    }
    if (stage_ == ST_STEP4) {
      stage_ = ST_SOLVE;
      solve_accel_mapping_();
      stage_ = ST_DONE;
      Serial.println("[DONE] Press BtnA to restart.");
      return;
    }
  }

  // ----------- Mapping solve (minimal; same concept) -----------
  int perm_parity3_(int a, int b, int c) const {
    int inv=0; int arr[3]={a,b,c};
    for(int i=0;i<3;i++) for(int j=i+1;j<3;j++) if(arr[i]>arr[j]) inv++;
    return (inv%2==0)?+1:-1;
  }
  SignedPerm make_perm_(int ix,int sx,int iy,int sy,int iz,int sz) const {
    SignedPerm p;
    p.idx[0]=(int8_t)ix; p.sgn[0]=(int8_t)sx;
    p.idx[1]=(int8_t)iy; p.sgn[1]=(int8_t)sy;
    p.idx[2]=(int8_t)iz; p.sgn[2]=(int8_t)sz;
    int parity = perm_parity3_(ix,iy,iz);
    int sprod  = sx*sy*sz;
    p.det = (int8_t)(parity*sprod);
    return p;
  }
  int enumerate_perms_(SignedPerm* out, int max_out) const {
    int n=0;
    const int perms[6][3]={{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
    const int sgns[8][3]={
      {+1,+1,+1},{+1,+1,-1},{+1,-1,+1},{+1,-1,-1},
      {-1,+1,+1},{-1,+1,-1},{-1,-1,+1},{-1,-1,-1}
    };
    for(int pi=0;pi<6;pi++) for(int si=0;si<8;si++){
      if(n>=max_out) break;
      out[n++] = make_perm_(perms[pi][0],sgns[si][0], perms[pi][1],sgns[si][1], perms[pi][2],sgns[si][2]);
    }
    return n;
  }
  Vec3 apply_perm_(const SignedPerm& p, const Vec3& v) const {
    Vec3 o;
    o(0) = (float)p.sgn[0] * v((int)p.idx[0]);
    o(1) = (float)p.sgn[1] * v((int)p.idx[1]);
    o(2) = (float)p.sgn[2] * v((int)p.idx[2]);
    return o;
  }
  float score_dir_(const Vec3& v, const Vec3& t_unit) const {
    Vec3 u = safe_unit_(v);
    return u.dot(t_unit);
  }

  void solve_accel_mapping_() {
    Serial.println();
    Serial.println("============================================================");
    Serial.println("STEP 5/5: Solving accel mapping from the 4 captured poses...");
    Serial.println("============================================================");

    Vec3 aZu = pose1_.acc_mean();
    Vec3 aZd = pose2_.acc_mean();
    Vec3 aX  = pose3_.acc_mean();
    Vec3 aY  = pose4_.acc_mean();

    // expected +g in SCREEN frame (your original assumption)
    const Vec3 tZu(0,0, 1);
    const Vec3 tZd(0,0,-1);
    const Vec3 tX (-1,0,0);
    const Vec3 tY (0,-1,0);

    SignedPerm perms[64];
    int nperm = enumerate_perms_(perms, 64);

    float best=-1e9f, second=-1e9f;
    SignedPerm bestp = perms[0];

    for (int i=0;i<nperm;i++) {
      Vec3 mZu = apply_perm_(perms[i], aZu);
      Vec3 mZd = apply_perm_(perms[i], aZd);
      Vec3 mX  = apply_perm_(perms[i], aX);
      Vec3 mY  = apply_perm_(perms[i], aY);

      float sc = 0.0f;
      sc += 2.8f * score_dir_(mZu, tZu);
      sc += 2.3f * score_dir_(mZd, tZd);
      sc += 2.0f * score_dir_(mX,  tX);
      sc += 2.0f * score_dir_(mY,  tY);

      if (sc > best) { second = best; best = sc; bestp = perms[i]; }
      else if (sc > second) { second = sc; }
    }

    float margin = best - second;
    Serial.printf("[ACCEL] solve score best=%.3f second=%.3f margin=%.3f\n", best, second, margin);

    if (!(best > 6.0f && margin > 0.20f)) {
      Serial.println("[ACCEL] Could not solve confidently. Press BtnA to restart.");
      return;
    }

    map_acc_screen_ = bestp;

    float m = 0.25f * (
      safe_norm_(apply_perm_(map_acc_screen_, aZu)) +
      safe_norm_(apply_perm_(map_acc_screen_, aZd)) +
      safe_norm_(apply_perm_(map_acc_screen_, aX)) +
      safe_norm_(apply_perm_(map_acc_screen_, aY))
    );

    const float G_STD = 9.80665f;
    if (m > 0.35f && m < 2.3f) acc_scale_mps2_ = G_STD;
    else if (m > 4.0f && m < 15.0f) acc_scale_mps2_ = 1.0f;
    else acc_scale_mps2_ = (m > 1e-6f) ? (G_STD / m) : 1.0f;

    Serial.println("[ACCEL] Solved mapping (RAW -> SCREEN frame):");
    Serial.printf("idx=[%d %d %d] sgn=[%d %d %d] det=%d\n",
      map_acc_screen_.idx[0], map_acc_screen_.idx[1], map_acc_screen_.idx[2],
      map_acc_screen_.sgn[0], map_acc_screen_.sgn[1], map_acc_screen_.sgn[2],
      map_acc_screen_.det);
    Serial.printf("acc_scale_mps2 = %.9g\n", acc_scale_mps2_);
  }
};

// ----------- Global instance -----------
static IMUWizard g_wiz;

void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);
  delay(350);
  g_wiz.begin();
}

void loop() {
  g_wiz.update();
}
