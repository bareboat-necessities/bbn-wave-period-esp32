/*
  AtomS3R (M5Unified) — Auto-detect IMU axis mappings + unit scales (FIXED)

  What this sketch does (wizard-style over Serial):
    1) Captures 4 still poses (screen-up, screen-down, right-edge-down, top-edge-down)
    2) Solves ACC signed-permutation mapping to a SCREEN frame:
         +X = screen-right, +Y = screen-top, +Z = out-of-screen
       Then converts to BODY_NED-like:
         +X = screen-right, +Y = screen-top, +Z = screen-down  (NED-style body)
    3) Detects accel units and chooses scale to m/s^2
    4) Captures a flat rotation (screen-up) for ~8s
       - If MAG exists: finds MAG mapping by maximizing correlation between gyro yaw-rate and mag heading-rate
       - Chooses MAG scale to microtesla (uT) from plausible Earth-field range
       - Chooses GYRO scale to rad/s (deg/s vs rad/s) using heading-vs-gyro integral or a robust heuristic
    5) Prints a “paste into your project” block for mapping + scales

  FIXES vs your broken version:
    - No blocking “loop rate counts as sensor rate” bug:
        * scheduled_poll() only reads IMU when a scheduler tick is due
        * observed rate counts only scheduled ticks (and prints even inside capture loops)
        * backlog is dropped (no catch-up while loops)
    - Pose capture no longer “hangs silently”:
        * prints progress + live stillness diagnostics
        * stillness gate is robust to unknown gyro units (deg/s or rad/s)
*/

#include <M5Unified.h>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
#define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif

#ifdef EIGEN_NON_ARDUINO
  #include <Eigen/Dense>
#else
  #include <ArduinoEigenDense.h>
#endif

#include <cmath>
#include <cstdint>
#include <algorithm>

#ifdef ARDUINO_ARCH_ESP32
  #include "esp_timer.h"
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

using Vec3 = Eigen::Matrix<float, 3, 1>;

static constexpr float G_STD = 9.80665f;

// ------------------------------ Config ------------------------------
static constexpr float ACC_GYR_RATE_HZ = 200.0f;   // user config
static constexpr float MAG_RATE_HZ     = 50.0f;    // user config (requested mag sampling rate)
static constexpr uint32_t POSE_CAPTURE_MS = 1400;  // stable-hold duration per pose
static constexpr int MAX_ROT_SAMPLES = 300;        // store up to 300 samples for rotation stage

// Stillness gates
static constexpr float STILL_COS_MIN = 0.9992f;    // accel direction stability (≈ 2.3°)
static constexpr float GYRO_ABS_MAX_RAW = 8.0f;    // hard cap in RAW units (works for deg/s or rad/s)
static constexpr float GYRO_FLOOR_RAW   = 0.35f;   // minimum threshold in RAW units
static constexpr float ACC_NORM_REL_MAX = 0.03f;   // accel norm must stay within ~3% of EMA

// Rotation capture
static constexpr uint32_t ROT_CAPTURE_MS = 8000;

// ------------------------------ Time helpers ------------------------------
static inline int64_t now_us64() {
#ifdef ARDUINO_ARCH_ESP32
  return (int64_t)esp_timer_get_time(); // monotonic, 64-bit
#else
  return (int64_t)micros();
#endif
}

static inline float clampf(float x, float a, float b) { return std::max(a, std::min(b, x)); }

static inline float wrap_pi(float a) {
  while (a >  (float)M_PI) a -= 2.0f * (float)M_PI;
  while (a < -(float)M_PI) a += 2.0f * (float)M_PI;
  return a;
}

static inline float safe_norm(const Vec3& v) {
  float n = v.norm();
  return (std::isfinite(n) && n > 1e-12f) ? n : 0.0f;
}

static inline Vec3 safe_unit(const Vec3& v, const Vec3& fallback = Vec3(0,0,1)) {
  float n = safe_norm(v);
  return (n > 0.0f) ? (v / n) : fallback;
}

// ------------------------------ Core Types (MUST be above functions) ------------------------------

// Signed axis permutation: out[i] = sgn[i] * in[idx[i]]
struct SignedPerm {
  int8_t idx[3] = {0,1,2};
  int8_t sgn[3] = {+1,+1,+1};
  int8_t det = +1; // +1 or -1
};

static inline Vec3 apply_perm(const SignedPerm& p, const Vec3& v) {
  Vec3 o;
  o(0) = (float)p.sgn[0] * v((int)p.idx[0]);
  o(1) = (float)p.sgn[1] * v((int)p.idx[1]);
  o(2) = (float)p.sgn[2] * v((int)p.idx[2]);
  return o;
}

// parity of permutation indices: +1 even, -1 odd
static inline int perm_parity3(int a, int b, int c) {
  int inv = 0;
  int arr[3] = {a,b,c};
  for (int i=0;i<3;i++) for (int j=i+1;j<3;j++) if (arr[i] > arr[j]) inv++;
  return (inv % 2 == 0) ? +1 : -1;
}

static inline SignedPerm make_perm(int ix,int sx,int iy,int sy,int iz,int sz) {
  SignedPerm p;
  p.idx[0]= (int8_t)ix; p.sgn[0]= (int8_t)sx;
  p.idx[1]= (int8_t)iy; p.sgn[1]= (int8_t)sy;
  p.idx[2]= (int8_t)iz; p.sgn[2]= (int8_t)sz;
  int parity = perm_parity3(ix,iy,iz);
  int sprod  = sx * sy * sz;
  p.det = (int8_t)(parity * sprod);
  return p;
}

static int enumerate_perms(SignedPerm* out, int max_out, bool det_pos_only) {
  int n = 0;
  const int perms[6][3] = {
    {0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}
  };
  const int sgns[8][3] = {
    {+1,+1,+1},{+1,+1,-1},{+1,-1,+1},{+1,-1,-1},
    {-1,+1,+1},{-1,+1,-1},{-1,-1,+1},{-1,-1,-1}
  };
  for (int pi=0; pi<6; ++pi) {
    for (int si=0; si<8; ++si) {
      SignedPerm p = make_perm(perms[pi][0], sgns[si][0],
                               perms[pi][1], sgns[si][1],
                               perms[pi][2], sgns[si][2]);
      if (det_pos_only && p.det < 0) continue;
      if (n < max_out) out[n++] = p;
    }
  }
  return n;
}

static void print_perm(const char* name, const SignedPerm& p) {
  Serial.printf("%s idx=[%d %d %d] sgn=[%d %d %d] det=%d\n",
                name, p.idx[0],p.idx[1],p.idx[2], p.sgn[0],p.sgn[1],p.sgn[2], p.det);
  int M[3][3] = {{0,0,0},{0,0,0},{0,0,0}};
  M[0][p.idx[0]] = p.sgn[0];
  M[1][p.idx[1]] = p.sgn[1];
  M[2][p.idx[2]] = p.sgn[2];
  Serial.printf("%s M=\n", name);
  for (int r=0;r<3;r++) Serial.printf("  [%2d %2d %2d]\n", M[r][0],M[r][1],M[r][2]);
}

struct IMUSample {
  int64_t t_us = 0;
  Vec3 acc = Vec3::Zero(); // raw
  Vec3 gyr = Vec3::Zero(); // raw
  Vec3 mag = Vec3::Zero(); // raw
  bool have_mag = false;
};

struct Stillness {
  Vec3  a_unit_ema = Vec3(0,0,1);
  float a_norm_ema = 1.0f;
  float gyro_ema   = 0.0f;

  void reset() {
    a_unit_ema = Vec3(0,0,1);
    a_norm_ema = 1.0f;
    gyro_ema   = 0.0f;
  }

  // Robust to unknown gyro units; meant only for "pose capture"
  bool update_and_check(const Vec3& a_raw, const Vec3& g_raw, float dt_s,
                        float* out_cos=nullptr, float* out_gn=nullptr, float* out_th=nullptr, float* out_an_rel=nullptr)
  {
    const float alpha_dir  = clampf(dt_s / 0.25f, 0.01f, 0.25f);
    const float alpha_norm = clampf(dt_s / 0.35f, 0.01f, 0.25f);
    const float alpha_gyro = clampf(dt_s / 0.45f, 0.01f, 0.25f);

    Vec3 au = safe_unit(a_raw, a_unit_ema);
    a_unit_ema = safe_unit((1.0f - alpha_dir) * a_unit_ema + alpha_dir * au, au);

    float an = safe_norm(a_raw);
    if (an > 1e-6f) a_norm_ema = (1.0f - alpha_norm) * a_norm_ema + alpha_norm * an;

    float gn = safe_norm(g_raw);
    gyro_ema = (1.0f - alpha_gyro) * gyro_ema + alpha_gyro * gn;

    float cos_sim = clampf(au.dot(a_unit_ema), -1.0f, 1.0f);
    float gyro_th = std::max(GYRO_FLOOR_RAW, 3.0f * gyro_ema + GYRO_FLOOR_RAW);

    float an_rel = 0.0f;
    if (a_norm_ema > 1e-6f) an_rel = std::fabs(an - a_norm_ema) / a_norm_ema;

    bool ok = (cos_sim > STILL_COS_MIN) &&
              (gn < gyro_th) &&
              (gn < GYRO_ABS_MAX_RAW) &&
              (an_rel < ACC_NORM_REL_MAX);

    if (out_cos) *out_cos = cos_sim;
    if (out_gn)  *out_gn  = gn;
    if (out_th)  *out_th  = gyro_th;
    if (out_an_rel) *out_an_rel = an_rel;
    return ok;
  }
};

struct PoseAvg {
  Vec3 acc_sum = Vec3::Zero();
  Vec3 gyr_sum = Vec3::Zero();
  Vec3 mag_sum = Vec3::Zero();
  int n = 0;
  int nmag = 0;

  void reset() { acc_sum.setZero(); gyr_sum.setZero(); mag_sum.setZero(); n=0; nmag=0; }
  void add(const IMUSample& s) {
    acc_sum += s.acc;
    gyr_sum += s.gyr;
    n++;
    if (s.have_mag) { mag_sum += s.mag; nmag++; }
  }

  Vec3 acc_mean() const { return (n > 0) ? (acc_sum / (float)n) : Vec3::Zero(); }
  Vec3 gyr_mean() const { return (n > 0) ? (gyr_sum / (float)n) : Vec3::Zero(); }
  Vec3 mag_mean() const { return (nmag > 0) ? (mag_sum / (float)nmag) : Vec3::Zero(); }
};

// Rotation capture buffer (flat rotation)
struct RotCap {
  IMUSample s[MAX_ROT_SAMPLES];
  int n = 0;
  void reset() { n = 0; }
  void push(const IMUSample& x) {
    if (n < MAX_ROT_SAMPLES) s[n++] = x;
  }
};

// ------------------------------ Scheduler + rate report (FIXED) ------------------------------
static int64_t g_next_acc_us = 0;
static int64_t g_next_mag_us = 0;

static int64_t g_acc_period_us = 0;
static int64_t g_mag_period_us = 0;

static IMUSample g_last_sample;

static uint32_t g_acc_ticks = 0;
static uint32_t g_mag_ticks = 0;
static int64_t  g_rate_t0_us = 0;
static int64_t  g_rate_last_print_us = 0;

static inline void setup_rates() {
  auto hz_to_period = [](float hz)->int64_t {
    if (!(hz > 0.1f)) hz = 1.0f;
    double p = 1000000.0 / (double)hz;
    if (p < 1000.0) p = 1000.0; // avoid ridiculous sched rates
    return (int64_t)llround(p);
  };
  g_acc_period_us = hz_to_period(ACC_GYR_RATE_HZ);
  g_mag_period_us = hz_to_period(MAG_RATE_HZ);

  int64_t now = now_us64();
  g_next_acc_us = now + g_acc_period_us;
  g_next_mag_us = now + g_mag_period_us;

  g_rate_t0_us = now;
  g_rate_last_print_us = now;
  g_acc_ticks = 0;
  g_mag_ticks = 0;
}

static bool read_imu_once(IMUSample& out) {
  M5.update();
  (void)M5.Imu.update();

  auto d = M5.Imu.getImuData(); // accel/gyro/mag

  out.t_us = now_us64();
  out.acc  = Vec3(d.accel.x, d.accel.y, d.accel.z);
  out.gyr  = Vec3(d.gyro.x,  d.gyro.y,  d.gyro.z);
  out.mag  = Vec3(d.mag.x,   d.mag.y,   d.mag.z);

  out.have_mag =
    std::isfinite(out.mag.x()) && std::isfinite(out.mag.y()) && std::isfinite(out.mag.z()) &&
    (std::fabs(out.mag.x()) + std::fabs(out.mag.y()) + std::fabs(out.mag.z()) > 1e-6f);

  return true;
}

// prints even inside capture loops
static void maybe_print_rate_report(bool have_mag_hint) {
  int64_t now = now_us64();
  if (now - g_rate_last_print_us < 1000000) return; // 1s
  g_rate_last_print_us = now;

  double dt = (now - g_rate_t0_us) * 1e-6;
  if (dt <= 0.0) dt = 1.0;

  float acc_hz = (float)(g_acc_ticks / dt);
  float mag_hz = (float)(g_mag_ticks / dt);

  Serial.printf("[RATE] acc/gyro observed ~%.1f Hz (target %.1f)  period_us=%lld\n",
                acc_hz, ACC_GYR_RATE_HZ, (long long)g_acc_period_us);
  Serial.printf("[RATE] mag observed     ~%.1f Hz (target %.1f)  period_us=%lld %s\n",
                mag_hz, MAG_RATE_HZ, (long long)g_mag_period_us,
                (have_mag_hint ? "" : "(mag may be unavailable)"));

  // reset window
  g_rate_t0_us = now;
  g_acc_ticks = 0;
  g_mag_ticks = 0;
}

// FIXED: only reads IMU when a scheduler tick is due, and drops backlog
static bool scheduled_poll(IMUSample& out, bool& got_acc, bool& got_mag) {
  got_acc = false;
  got_mag = false;

  int64_t now = now_us64();
  bool due_acc = (now >= g_next_acc_us);
  bool due_mag = (now >= g_next_mag_us);

  if (!due_acc && !due_mag) {
    return false; // no busy spinning that reads IMU repeatedly
  }

  // Drop backlog instead of catching up in a tight loop
  if (due_acc) {
    int64_t late = now - g_next_acc_us;
    if (late > 2 * g_acc_period_us) g_next_acc_us = now + g_acc_period_us;
    else g_next_acc_us += g_acc_period_us;
    got_acc = true;
    g_acc_ticks++;
  }
  if (due_mag) {
    int64_t late = now - g_next_mag_us;
    if (late > 2 * g_mag_period_us) g_next_mag_us = now + g_mag_period_us;
    else g_next_mag_us += g_mag_period_us;
    got_mag = true;
    // we count mag ticks regardless; we’ll annotate if mag is missing
    g_mag_ticks++;
  }

  // One sensor read per tick (even if both due)
  read_imu_once(g_last_sample);
  out = g_last_sample;

  maybe_print_rate_report(out.have_mag);
  return true;
}

// ------------------------------ Pose capture helper (FIXED: progress + robust stillness) ------------------------------
static bool capture_pose_auto(const char* pose_name, PoseAvg& out, Stillness& still, uint32_t capture_ms) {
  out.reset();
  still.reset();

  int64_t t_start = now_us64();
  int64_t stable_start = 0;
  int64_t last_us = now_us64();
  int64_t last_print = now_us64();

  Serial.printf("[POSE] Capturing: %s  (need %u ms stable)\n", pose_name, (unsigned)capture_ms);

  while (true) {
    IMUSample s;
    bool got_acc=false, got_mag=false;
    if (!scheduled_poll(s, got_acc, got_mag)) { delay(1); continue; }
    if (!got_acc) continue; // pose capture needs accel/gyro cadence

    int64_t now = s.t_us;
    float dt_s = (float)((now - last_us) * 1e-6);
    last_us = now;
    if (!(dt_s > 0.0f && dt_s < 0.5f)) dt_s = 0.01f;

    float cos_sim=0, gn=0, th=0, an_rel=0;
    bool ok = still.update_and_check(s.acc, s.gyr, dt_s, &cos_sim, &gn, &th, &an_rel);

    if (!ok) {
      stable_start = 0;
      out.reset();
    } else {
      if (stable_start == 0) stable_start = now_us64();
      out.add(s);
      if ((now_us64() - stable_start) >= (int64_t)capture_ms * 1000 && out.n > 20) {
        Serial.printf("[POSE] OK: %s  samples=%d (mag_samples=%d)\n", pose_name, out.n, out.nmag);
        return true;
      }
    }

    // progress print every ~0.7s
    int64_t tnow = now_us64();
    if (tnow - last_print > 700000) {
      last_print = tnow;
      uint32_t stable_ms = (stable_start == 0) ? 0 : (uint32_t)((tnow - stable_start) / 1000);
      Serial.printf("[POSE] %s  stable=%ums/%u  cos=%.4f  gyro=%.3f<th=%.3f  aRel=%.3f  n=%d\n",
                    pose_name, stable_ms, (unsigned)capture_ms, cos_sim, gn, th, an_rel, out.n);
      Serial.println("       If stuck: move less, wait 1s, then hold still again.");
    }

    // timeout after 35s
    if ((now_us64() - t_start) > 35000000) {
      Serial.printf("[POSE] TIMEOUT: %s  (try again, more stable hold)\n", pose_name);
      return false;
    }
  }
}

// ------------------------------ Solve accel mapping from poses (FIXED signs + uses Z_down for validation) ------------------------------
static float score_dir(const Vec3& v, const Vec3& target_unit) {
  Vec3 u = safe_unit(v);
  return u.dot(target_unit);
}

// Poses expected in SCREEN frame (X right, Y top, Z out-of-screen):
//  - screen UP (flat):        +g along +Z
//  - screen DOWN (flat):      +g along -Z
//  - RIGHT EDGE DOWN (screen facing you): +g along -X   (because +X points down)
//  - TOP EDGE DOWN (screen facing you):   +g along -Y   (because +Y points down)
static bool build_mapping_from_poses(const PoseAvg& pZ_up,
                                    const PoseAvg& pZ_down,
                                    const PoseAvg& pX_rightEdgeDown,
                                    const PoseAvg& pY_topEdgeDown,
                                    SignedPerm& out_map)
{
  Vec3 aZu = pZ_up.acc_mean();
  Vec3 aZd = pZ_down.acc_mean();
  Vec3 aX  = pX_rightEdgeDown.acc_mean();
  Vec3 aY  = pY_topEdgeDown.acc_mean();

  const Vec3 tZu(0,0, 1);
  const Vec3 tZd(0,0,-1);
  const Vec3 tX (-1,0,0);
  const Vec3 tY (0,-1,0);

  SignedPerm perms[64];
  int nperm = enumerate_perms(perms, 64, false);

  float best = -1e9f;
  SignedPerm bestp = perms[0];

  for (int i=0;i<nperm;i++) {
    Vec3 mZu = apply_perm(perms[i], aZu);
    Vec3 mZd = apply_perm(perms[i], aZd);
    Vec3 mX  = apply_perm(perms[i], aX);
    Vec3 mY  = apply_perm(perms[i], aY);

    float sc = 0.0f;
    sc += 2.8f * score_dir(mZu, tZu);
    sc += 2.3f * score_dir(mZd, tZd);
    sc += 2.0f * score_dir(mX,  tX);
    sc += 2.0f * score_dir(mY,  tY);

    // Penalize inconsistent magnitudes across poses (helps reject bad captures)
    float nZu = safe_norm(mZu), nZd = safe_norm(mZd), nX = safe_norm(mX), nY = safe_norm(mY);
    float nmean = 0.25f*(nZu+nZd+nX+nY);
    float nvar  = (nZu-nmean)*(nZu-nmean)+(nZd-nmean)*(nZd-nmean)+(nX-nmean)*(nX-nmean)+(nY-nmean)*(nY-nmean);
    sc -= 0.12f * nvar / (nmean*nmean + 1e-6f);

    if (sc > best) { best = sc; bestp = perms[i]; }
  }

  out_map = bestp;
  return (best > 6.0f); // needs 4 poses; stronger threshold
}

// ------------------------------ Detect accel scale to SI (uses 4 poses) ------------------------------
static float choose_acc_scale_mps2(const SignedPerm& map_screen,
                                  const PoseAvg& pZ_up,
                                  const PoseAvg& pZ_down,
                                  const PoseAvg& pX,
                                  const PoseAvg& pY)
{
  float mags[4] = {
    safe_norm(apply_perm(map_screen, pZ_up.acc_mean())),
    safe_norm(apply_perm(map_screen, pZ_down.acc_mean())),
    safe_norm(apply_perm(map_screen, pX.acc_mean())),
    safe_norm(apply_perm(map_screen, pY.acc_mean()))
  };
  float m = 0.25f*(mags[0]+mags[1]+mags[2]+mags[3]);

  // Typical outcomes:
  //  - raw in "g": m ~ 1
  //  - raw in "m/s^2": m ~ 9.8
  if (m > 0.35f && m < 2.3f) return G_STD; // g -> m/s^2
  if (m > 4.0f  && m < 15.0f) return 1.0f; // already m/s^2
  return (m > 1e-6f) ? (G_STD / m) : 1.0f;  // normalize to g
}

// ------------------------------ Rotation capture (flat) ------------------------------
static bool capture_rotation_auto(RotCap& cap, uint32_t ms_total) {
  cap.reset();

  int64_t t0 = now_us64();
  int64_t last_print = now_us64();

  Vec3 a_ref(0,0,1);
  bool have_ref=false;

  Serial.println("[ROT] Capturing rotation samples...");
  Serial.println("      Keep screen-up and rotate CLOCKWISE (as viewed from above).");

  while ((now_us64() - t0) < (int64_t)ms_total * 1000) {
    IMUSample s;
    bool got_acc=false, got_mag=false;
    if (!scheduled_poll(s, got_acc, got_mag)) { delay(1); continue; }
    if (!got_acc) continue;

    Vec3 au = safe_unit(s.acc, Vec3(0,0,1));
    if (!have_ref) { a_ref = au; have_ref=true; }

    float cos_flat = clampf(au.dot(a_ref), -1.0f, 1.0f);
    bool flat_enough = (cos_flat > 0.995f); // ~5.7 deg

    float gyro_n = safe_norm(s.gyr);
    bool not_crazy = std::isfinite(gyro_n) && (gyro_n < 2000.0f);

    if (flat_enough && not_crazy) cap.push(s);

    int64_t now = now_us64();
    if (now - last_print > 900000) {
      last_print = now;
      Serial.printf("[ROT] n=%d/%d  cos_flat=%.4f  gyro_norm=%.2f  mag=%s\n",
                    cap.n, MAX_ROT_SAMPLES, cos_flat, gyro_n, (s.have_mag?"yes":"no"));
    }
  }

  Serial.printf("[ROT] Done. Stored %d samples.\n", cap.n);
  return cap.n >= 60;
}

// ------------------------------ Correlation utility ------------------------------
static float corrcoef(const float* x, const float* y, int n) {
  if (n < 12) return 0.0f;
  double sx=0, sy=0, sxx=0, syy=0, sxy=0;
  for (int i=0;i<n;i++) { sx += x[i]; sy += y[i]; }
  double mx = sx / n, my = sy / n;
  for (int i=0;i<n;i++) {
    double dx = x[i]-mx, dy = y[i]-my;
    sxx += dx*dx; syy += dy*dy; sxy += dx*dy;
  }
  if (sxx <= 1e-12 || syy <= 1e-12) return 0.0f;
  return (float)(sxy / std::sqrt(sxx*syy));
}

// ------------------------------ Find best mag mapping using gyro↔heading-rate correlation ------------------------------
static SignedPerm find_best_mag_mapping(const RotCap& cap,
                                       const SignedPerm& map_acc_screen,
                                       float& out_heading_unwrap_rad,
                                       float& out_mag_norm_mean_raw,
                                       float& out_corr_abs)
{
  SignedPerm perms[64];
  int nperm = enumerate_perms(perms, 64, true); // prefer right-handed for mag

  int n = cap.n;
  if (n > MAX_ROT_SAMPLES) n = MAX_ROT_SAMPLES;

  // Precompute mapped gyro z and dt
  float wz[MAX_ROT_SAMPLES];
  float dt[MAX_ROT_SAMPLES];

  for (int i=0;i<n;i++) { wz[i]=0.0f; dt[i]=0.0f; }

  for (int i=1;i<n;i++) {
    float dts = (float)((cap.s[i].t_us - cap.s[i-1].t_us) * 1e-6);
    dt[i] = (dts > 1e-6f && dts < 0.2f) ? dts : 0.0f;
    Vec3 g_scr = apply_perm(map_acc_screen, cap.s[i].gyr);
    wz[i] = g_scr.z();
  }

  float bestScore = -1e9f;
  SignedPerm bestP = perms[0];
  float best_corr_abs = 0.0f;
  float best_heading_unwrap = 0.0f;
  float best_mag_norm_mean = 0.0f;

  for (int pi=0; pi<nperm; ++pi) {
    float hrate[MAX_ROT_SAMPLES];
    float wz_use[MAX_ROT_SAMPLES];

    bool psi_init = false;
    float psi_prev = 0.0f;
    float psi_unwrap = 0.0f;
    float psi_total_abs = 0.0f;

    double mag_norm_sum = 0.0;
    int mag_norm_n = 0;

    int k = 0;
    for (int i=1;i<n;i++) {
      if (!cap.s[i].have_mag) continue;
      if (dt[i] <= 0.0f) continue;

      Vec3 m_scr = apply_perm(perms[pi], cap.s[i].mag);
      float mn = safe_norm(m_scr);
      if (mn > 1e-6f) { mag_norm_sum += mn; mag_norm_n++; }

      float psi = std::atan2(m_scr.y(), m_scr.x());

      if (!psi_init) {
        psi_prev = psi;
        psi_unwrap = psi;
        psi_init = true;
        continue;
      }

      float dpsi = wrap_pi(psi - psi_prev);
      psi_prev = psi;
      psi_unwrap += dpsi;
      psi_total_abs += std::fabs(dpsi);

      hrate[k] = dpsi / dt[i];
      wz_use[k] = wz[i];
      k++;
      if (k >= MAX_ROT_SAMPLES) break;
    }

    if (k < 24 || mag_norm_n < 24) continue;

    float c = corrcoef(wz_use, hrate, k);
    float cabs = std::fabs(c);
    float mag_norm_mean = (float)(mag_norm_sum / std::max(1, mag_norm_n));

    // score: correlation + encourage meaningful rotation
    float score = 3.0f * cabs + 0.0015f * psi_total_abs;

    if (score > bestScore) {
      bestScore = score;
      bestP = perms[pi];
      best_corr_abs = cabs;
      best_heading_unwrap = psi_unwrap;
      best_mag_norm_mean = mag_norm_mean;
    }
  }

  out_heading_unwrap_rad = best_heading_unwrap;
  out_mag_norm_mean_raw = best_mag_norm_mean;
  out_corr_abs = best_corr_abs;
  return bestP;
}

// ------------------------------ Choose mag scale to uT ------------------------------
static float choose_mag_scale_uT(float mag_norm_mean_raw) {
  const float candidates[] = { 1.0f, 0.1f, 10.0f, 0.01f, 100.0f, 0.001f };
  float best = candidates[0];
  float bestCost = 1e9f;
  for (float s : candidates) {
    float muT = mag_norm_mean_raw * s;
    float cost = 0.0f;
    if (muT < 15.0f) cost += (15.0f - muT) * (15.0f - muT);
    if (muT > 100.0f) cost += (muT - 100.0f) * (muT - 100.0f);
    cost += 0.015f * (muT - 50.0f) * (muT - 50.0f); // mild preference near ~50 uT
    if (cost < bestCost) { bestCost = cost; best = s; }
  }
  return best;
}

// ------------------------------ Choose gyro scale to rad/s (robust) ------------------------------
static float choose_gyro_scale_radps(float heading_unwrap_rad, float gyro_int_raw) {
  const float DEG2RAD = (float)M_PI / 180.0f;

  // If mag heading is available and usable, use it first:
  if (std::isfinite(heading_unwrap_rad) && std::isfinite(gyro_int_raw) && std::fabs(gyro_int_raw) > 1e-6f) {
    float s = std::fabs(heading_unwrap_rad / gyro_int_raw);
    if (s > 1e-4f && s < 10.0f) {
      // Prefer snapping near {1, DEG2RAD} if close
      float d0 = std::fabs(s - 1.0f);
      float d1 = std::fabs(s - DEG2RAD);
      if (d1 < 0.5f * d0) return DEG2RAD;
      return s;
    }
  }

  // Fallback: decide between rad/s and deg/s using "multiple of 2π" closeness
  auto cost_for = [&](float scale)->float {
    float x = std::fabs(gyro_int_raw) * scale;
    if (!(x > 1e-6f)) return 1e9f;
    float k = std::round(x / (2.0f*(float)M_PI));
    if (k < 1.0f) k = 1.0f;
    return std::fabs(x - k * 2.0f*(float)M_PI);
  };

  float c_rad = cost_for(1.0f);
  float c_deg = cost_for(DEG2RAD);
  return (c_deg < c_rad) ? DEG2RAD : 1.0f;
}

// ------------------------------ Convert screen-frame mapping to BODY_NED-like ------------------------------
// screen frame uses +Z_out. BODY_NED-like wants +Z_down = -Z_out.
static SignedPerm screen_to_body_ned_like(const SignedPerm& p_screen) {
  SignedPerm p = p_screen;
  p.sgn[2] = (int8_t)(-p.sgn[2]); // flip Z
  p.det = (int8_t)(-p.det);
  return p;
}

// ------------------------------ State Machine ------------------------------
enum Stage {
  ST_INTRO = 0,
  ST_POSE_Z_UP,
  ST_POSE_Z_DOWN,
  ST_POSE_X_RIGHT,
  ST_POSE_Y_TOP,
  ST_SOLVE_ACCEL,
  ST_ROTATE_FLAT,
  ST_SOLVE_MAG_GYRO,
  ST_DONE
};

static Stage g_stage = ST_INTRO;

static PoseAvg g_poseZup, g_poseZdown, g_poseX, g_poseY;
static Stillness g_still;
static RotCap g_rot;

// Results:
static SignedPerm g_map_acc_screen;
static SignedPerm g_map_mag_screen;

static float g_acc_scale_mps2    = 1.0f;  // multiply mapped raw accel by this => m/s^2
static float g_mag_scale_uT      = 1.0f;  // multiply mapped raw mag by this => uT
static float g_gyro_scale_radps  = 1.0f;  // multiply mapped raw gyro by this => rad/s
static bool  g_have_mag          = false;

static void print_user_prompt(const char* msg) {
  Serial.println();
  Serial.println("============================================================");
  Serial.println(msg);
  Serial.println("============================================================");
}

static void solve_and_print_final(float heading_total_rad, float mag_norm_mean_raw, float corr_abs, float gyro_int_raw) {
  SignedPerm map_acc_body = screen_to_body_ned_like(g_map_acc_screen);
  SignedPerm map_mag_body = screen_to_body_ned_like(g_map_mag_screen);

  Serial.println();
  Serial.println("########################### RESULTS ###########################");
  Serial.printf("Mag availability: %s\n", g_have_mag ? "YES" : "NO (mag unavailable or always zero)");
  if (g_have_mag) Serial.printf("Mag correlation score |corr| ~ %.3f (higher is better)\n", corr_abs);

  Serial.println("\nAccel mapping (RAW -> SCREEN frame):");
  print_perm("acc_screen", g_map_acc_screen);

  Serial.println("\nAccel mapping (RAW -> BODY_NED-like: X right, Y top, Z down):");
  print_perm("acc_bodyNED", map_acc_body);
  Serial.printf("acc_scale_mps2 = %.9g\n", g_acc_scale_mps2);

  Serial.println("\nGyro mapping: using SAME mapping as accel (common for IMU).");
  Serial.printf("gyro_scale_radps = %.9g\n", g_gyro_scale_radps);
  Serial.printf("gyro_integral_raw (mapped z over rotation) = %.6f (raw units*sec)\n", gyro_int_raw);

  if (g_have_mag) {
    Serial.println("\nMag mapping (RAW -> SCREEN frame):");
    print_perm("mag_screen", g_map_mag_screen);

    Serial.println("\nMag mapping (RAW -> BODY_NED-like):");
    print_perm("mag_bodyNED", map_mag_body);
    Serial.printf("mag_scale_uT = %.9g\n", g_mag_scale_uT);
    Serial.printf("Rotation heading total (mag unwrap) ~ %.2f rad (%.1f deg)\n",
                  heading_total_rad, heading_total_rad * 180.0f / (float)M_PI);
    Serial.printf("Mag norm mean raw=%.3f  => scaled mean=%.2f uT\n",
                  mag_norm_mean_raw, mag_norm_mean_raw * g_mag_scale_uT);
  }

  Serial.println();
  Serial.println("=== Paste this block into your project ===");
  Serial.println("/*");
  Serial.println("  RAW -> BODY_NED-like conversion (tied to device screen):");
  Serial.println("    +X = screen-right, +Y = screen-top, +Z = screen-down");
  Serial.println("*/");
  Serial.println("struct AxisMap { int8_t idx[3]; int8_t sgn[3]; };");
  Serial.println("static inline Eigen::Matrix<float,3,1> apply_map(const AxisMap& m, const Eigen::Matrix<float,3,1>& v){");
  Serial.println("  Eigen::Matrix<float,3,1> o;");
  Serial.println("  o(0) = (float)m.sgn[0]*v((int)m.idx[0]);");
  Serial.println("  o(1) = (float)m.sgn[1]*v((int)m.idx[1]);");
  Serial.println("  o(2) = (float)m.sgn[2]*v((int)m.idx[2]);");
  Serial.println("  return o;");
  Serial.println("}");
  Serial.printf("static constexpr AxisMap ACC_MAP = {{%d,%d,%d},{%d,%d,%d}};\n",
                map_acc_body.idx[0], map_acc_body.idx[1], map_acc_body.idx[2],
                map_acc_body.sgn[0], map_acc_body.sgn[1], map_acc_body.sgn[2]);
  Serial.printf("static constexpr float   ACC_SCALE_MPS2   = %.9g;\n", g_acc_scale_mps2);
  Serial.printf("static constexpr float   GYRO_SCALE_RADPS = %.9g;\n", g_gyro_scale_radps);
  if (g_have_mag) {
    Serial.printf("static constexpr AxisMap MAG_MAP = {{%d,%d,%d},{%d,%d,%d}};\n",
                  map_mag_body.idx[0], map_mag_body.idx[1], map_mag_body.idx[2],
                  map_mag_body.sgn[0], map_mag_body.sgn[1], map_mag_body.sgn[2]);
    Serial.printf("static constexpr float   MAG_SCALE_UT = %.9g;\n", g_mag_scale_uT);
  }
  Serial.println("/*");
  Serial.println("Usage:");
  Serial.println("  Vec3 acc_raw(ax,ay,az), gyr_raw(gx,gy,gz), mag_raw(mx,my,mz);");
  Serial.println("  Vec3 acc_si = apply_map(ACC_MAP, acc_raw) * ACC_SCALE_MPS2;");
  Serial.println("  Vec3 gyr_si = apply_map(ACC_MAP, gyr_raw) * GYRO_SCALE_RADPS;");
  Serial.println("  Vec3 mag_uT = apply_map(MAG_MAP, mag_raw) * MAG_SCALE_UT; // if mag available");
  Serial.println("*/");

  Serial.println();
  Serial.println("DONE.");
  Serial.println("###############################################################");
}

// ------------------------------ Arduino setup/loop ------------------------------
void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);

  Serial.begin(115200);
  delay(350);

  setup_rates();

  print_user_prompt(
    "IMU Auto-Detect Wizard\n"
    "We detect axis mappings + unit scales.\n"
    "Follow prompts. Keep device steady when asked.\n"
    "Rates printed are *scheduler-tick* rates (not CPU loop rate)."
  );

  g_stage = ST_POSE_Z_UP;
  print_user_prompt("STEP 1/5: Place device SCREEN UP on a flat surface. Hold still...");
}

void loop() {
  // non-blocking rate prints still happen during capture via scheduled_poll()

  switch (g_stage) {
    case ST_POSE_Z_UP: {
      if (capture_pose_auto("SCREEN UP (flat)", g_poseZup, g_still, POSE_CAPTURE_MS)) {
        g_stage = ST_POSE_Z_DOWN;
        print_user_prompt("STEP 2/5: Flip device SCREEN DOWN on the same flat surface. Hold still...");
      } else {
        print_user_prompt("Retry STEP 1/5: SCREEN UP. Hold still...");
      }
    } break;

    case ST_POSE_Z_DOWN: {
      if (capture_pose_auto("SCREEN DOWN (flat)", g_poseZdown, g_still, POSE_CAPTURE_MS)) {
        g_stage = ST_POSE_X_RIGHT;
        print_user_prompt(
          "STEP 3/5: Stand device on its RIGHT EDGE (screen facing you; right edge on table).\n"
          "Hold still..."
        );
      } else {
        g_stage = ST_POSE_Z_UP;
        print_user_prompt("Retry STEP 1/5: SCREEN UP. Hold still...");
      }
    } break;

    case ST_POSE_X_RIGHT: {
      if (capture_pose_auto("RIGHT EDGE DOWN", g_poseX, g_still, POSE_CAPTURE_MS)) {
        g_stage = ST_POSE_Y_TOP;
        print_user_prompt(
          "STEP 4/5: Stand device on its TOP EDGE (screen facing you; top edge on table).\n"
          "Hold still..."
        );
      } else {
        g_stage = ST_POSE_Z_UP;
        print_user_prompt("Retry STEP 1/5: SCREEN UP. Hold still...");
      }
    } break;

    case ST_POSE_Y_TOP: {
      if (capture_pose_auto("TOP EDGE DOWN", g_poseY, g_still, POSE_CAPTURE_MS)) {
        g_stage = ST_SOLVE_ACCEL;
      } else {
        g_stage = ST_POSE_Z_UP;
        print_user_prompt("Retry STEP 1/5: SCREEN UP. Hold still...");
      }
    } break;

    case ST_SOLVE_ACCEL: {
      SignedPerm map_screen;
      bool ok = build_mapping_from_poses(g_poseZup, g_poseZdown, g_poseX, g_poseY, map_screen);
      if (!ok) {
        print_user_prompt("Could not confidently solve accel mapping. Poses were inconsistent.\nRestarting.");
        g_stage = ST_POSE_Z_UP;
        print_user_prompt("STEP 1/5: Place device SCREEN UP. Hold still...");
        break;
      }

      g_map_acc_screen = map_screen;
      g_acc_scale_mps2 = choose_acc_scale_mps2(g_map_acc_screen, g_poseZup, g_poseZdown, g_poseX, g_poseY);

      Serial.println("\n[ACCEL] Solved mapping + scale.");
      print_perm("acc_screen", g_map_acc_screen);
      Serial.printf("acc_scale_mps2 = %.9g\n", g_acc_scale_mps2);

      g_stage = ST_ROTATE_FLAT;
      print_user_prompt(
        "STEP 5/5: Place device SCREEN UP (flat).\n"
        "Now ROTATE it CLOCKWISE (viewed from above) slowly for ~8 seconds.\n"
        "Keep it flat while rotating.\n"
        "TIP: If no magnetometer, try to rotate about ~1 full turn."
      );
    } break;

    case ST_ROTATE_FLAT: {
      if (capture_rotation_auto(g_rot, ROT_CAPTURE_MS)) {
        Serial.printf("[OK] Captured rotation samples: %d (max %d)\n", g_rot.n, MAX_ROT_SAMPLES);
        g_stage = ST_SOLVE_MAG_GYRO;
      } else {
        print_user_prompt("Rotation capture failed (not enough usable samples). Try again.");
        g_stage = ST_ROTATE_FLAT;
      }
    } break;

    case ST_SOLVE_MAG_GYRO: {
      // mag presence check
      int magCount = 0;
      for (int i=0;i<g_rot.n;i++) if (g_rot.s[i].have_mag) magCount++;
      g_have_mag = (magCount > 25);

      float heading_unwrap_rad = 0.0f;
      float mag_norm_mean_raw = 0.0f;
      float corr_abs = 0.0f;

      if (g_have_mag) {
        g_map_mag_screen = find_best_mag_mapping(g_rot, g_map_acc_screen,
                                                 heading_unwrap_rad, mag_norm_mean_raw, corr_abs);
        g_mag_scale_uT = choose_mag_scale_uT(mag_norm_mean_raw);
      } else {
        g_map_mag_screen = make_perm(0,+1, 1,+1, 2,+1);
        g_mag_scale_uT = 1.0f;
      }

      // Integrate gyro z (screen frame) over rotation window
      double gyro_int = 0.0;
      for (int i=1;i<g_rot.n;i++) {
        float dt_s = (float)((g_rot.s[i].t_us - g_rot.s[i-1].t_us) * 1e-6);
        if (!(dt_s > 1e-6f && dt_s < 0.2f)) continue;
        Vec3 g_scr = apply_perm(g_map_acc_screen, g_rot.s[i].gyr);
        gyro_int += (double)g_scr.z() * (double)dt_s;
      }

      g_gyro_scale_radps = choose_gyro_scale_radps(heading_unwrap_rad, (float)gyro_int);

      solve_and_print_final(heading_unwrap_rad, mag_norm_mean_raw, corr_abs, (float)gyro_int);
      g_stage = ST_DONE;
    } break;

    case ST_DONE: {
      // idle
      delay(25);
    } break;

    default: {
      delay(10);
    } break;
  }
}
