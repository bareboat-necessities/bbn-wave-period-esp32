/*
  AtomS3R (M5Unified) — IMU Auto-detect Wizard (POSE-CHANGE + SETTLE + CAPTURE)

  Output frame: NED referenced to SCREEN-UP
    N = TOP edge (screen-top)
    E = RIGHT edge (screen-right)
    D = DOWN into table (screen-down)

  Serial:
    'r' restart
    'v' verbose toggle

  Key behavior:
    - For each step after Step1: waits until pose actually changes vs previous,
      then requires settle+stillness, then captures stable window.
    - Rotation test is time-driven: always ~2s ready + 8s capture.

  Stack-safe: mag mapping uses streaming correlation (no big local arrays).
*/

#include <M5Unified.h>
#include <cmath>
#include <cstdint>
#include <algorithm>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
#define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif

#ifdef EIGEN_NON_ARDUINO
  #include <Eigen/Dense>
#else
  #include <ArduinoEigenDense.h>
#endif

#ifdef ARDUINO_ARCH_ESP32
  #include "esp_timer.h"
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

class IMUWizard {
public:
  using Vec3 = Eigen::Matrix<float,3,1>;

  // ===== CONFIG =====
  static constexpr float    G_STD           = 9.80665f;

  static constexpr float    ACC_GYR_RATE_HZ = 200.0f;
  static constexpr float    MAG_RATE_HZ     = 50.0f;

  // Pose workflow
  static constexpr uint32_t POSE_SETTLE_MS  = 2000;  // require a couple seconds settled
  static constexpr uint32_t POSE_STABLE_MS  = 1400;  // stable capture window
  static constexpr uint32_t POSE_TIMEOUT_MS = 45000; // per step timeout

  // Pose-change detection (raw accel unit)
  static constexpr float    CHANGE_DOT_MAX  = 0.92f; // if dot(prev,now) <= this => changed (about >23°)
  static constexpr float    DOM_AXIS_MIN    = 0.80f; // dominant axis must be strong (~>53° from others)

  // Stillness gating (raw gyro magnitude is in unknown units => adaptive threshold)
  static constexpr float STILL_COS_MIN    = 0.9992f;  // ~2.3deg direction stability
  static constexpr float ACC_NORM_REL_MAX = 0.03f;    // 3% accel norm variation
  static constexpr float GYRO_ABS_MAX_RAW = 8.0f;     // hard cap raw
  static constexpr float GYRO_FLOOR_RAW   = 0.35f;

  // Rotation workflow (mag-rate samples)
  static constexpr uint32_t ROT_READY_MS   = 2000;
  static constexpr uint32_t ROT_CAPTURE_MS = 8000;
  static constexpr int      MAX_ROT_SAMPLES = 520;    // ~50Hz*8s=400 mag samples + margin

  // ===== TYPES =====
  struct SignedPerm {
    int8_t idx[3] = {0,1,2};
    int8_t sgn[3] = {+1,+1,+1};
    int8_t det    = +1;
  };

  struct AxisMap { int8_t idx[3]; int8_t sgn[3]; };

  struct IMUSample {
    int64_t t_us = 0;
    Vec3 acc = Vec3::Zero();
    Vec3 gyr = Vec3::Zero();
    Vec3 mag = Vec3::Zero();
    bool have_mag = false;
  };

  struct Stillness {
    Vec3  a_unit_ema = Vec3(0,0,1);
    float a_norm_ema = 1.0f;
    float gyro_ema   = 0.0f;

    void reset() {
      a_unit_ema = Vec3(0,0,1);
      a_norm_ema = 1.0f;
      gyro_ema   = 0.0f;
    }

    static inline float clampf(float x, float a, float b) { return std::max(a, std::min(b, x)); }

    static inline float safe_norm(const Vec3& v) {
      float n = v.norm();
      return (std::isfinite(n) && n > 1e-12f) ? n : 0.0f;
    }

    static inline Vec3 safe_unit(const Vec3& v, const Vec3& fallback = Vec3(0,0,1)) {
      float n = safe_norm(v);
      return (n > 0.0f) ? (v / n) : fallback;
    }

    bool update_and_check(const Vec3& a_raw, const Vec3& g_raw, float dt_s,
                          float* out_cos=nullptr, float* out_gn=nullptr,
                          float* out_th=nullptr, float* out_an_rel=nullptr)
    {
      const float alpha_dir  = clampf(dt_s / 0.25f, 0.01f, 0.25f);
      const float alpha_norm = clampf(dt_s / 0.35f, 0.01f, 0.25f);
      const float alpha_gyro = clampf(dt_s / 0.45f, 0.01f, 0.25f);

      Vec3 au = safe_unit(a_raw, a_unit_ema);
      a_unit_ema = safe_unit((1.0f - alpha_dir) * a_unit_ema + alpha_dir * au, au);

      float an = safe_norm(a_raw);
      if (an > 1e-6f) a_norm_ema = (1.0f - alpha_norm) * a_norm_ema + alpha_norm * an;

      float gn = safe_norm(g_raw);
      gyro_ema = (1.0f - alpha_gyro) * gyro_ema + alpha_gyro * gn;

      float cos_sim = clampf(au.dot(a_unit_ema), -1.0f, 1.0f);
      float gyro_th = std::max(GYRO_FLOOR_RAW, 3.0f * gyro_ema + GYRO_FLOOR_RAW);

      float an_rel = 0.0f;
      if (a_norm_ema > 1e-6f) an_rel = std::fabs(an - a_norm_ema) / a_norm_ema;

      bool ok = (cos_sim > STILL_COS_MIN) &&
                (gn < gyro_th) &&
                (gn < GYRO_ABS_MAX_RAW) &&
                (an_rel < ACC_NORM_REL_MAX);

      if (out_cos) *out_cos = cos_sim;
      if (out_gn)  *out_gn  = gn;
      if (out_th)  *out_th  = gyro_th;
      if (out_an_rel) *out_an_rel = an_rel;
      return ok;
    }
  };

  struct PoseAvg {
    Vec3 acc_sum = Vec3::Zero();
    Vec3 gyr_sum = Vec3::Zero();
    Vec3 mag_sum = Vec3::Zero();
    int n = 0;
    int nmag = 0;

    void reset() { acc_sum.setZero(); gyr_sum.setZero(); mag_sum.setZero(); n=0; nmag=0; }
    void add(const IMUSample& s) {
      acc_sum += s.acc;
      gyr_sum += s.gyr;
      n++;
      if (s.have_mag) { mag_sum += s.mag; nmag++; }
    }

    Vec3 acc_mean() const {
      Vec3 o = Vec3::Zero();
      if (n > 0) o = acc_sum / (float)n;
      return o;
    }
    Vec3 gyr_mean() const {
      Vec3 o = Vec3::Zero();
      if (n > 0) o = gyr_sum / (float)n;
      return o;
    }
    Vec3 mag_mean() const {
      Vec3 o = Vec3::Zero();
      if (nmag > 0) o = mag_sum / (float)nmag;
      return o;
    }
  };

  struct RotCap {
    IMUSample s[MAX_ROT_SAMPLES];
    int n = 0;
    void reset() { n = 0; }
    void push(const IMUSample& x) { if (n < MAX_ROT_SAMPLES) s[n++] = x; }
  };

  // ===== PUBLIC =====
  void begin() {
    setup_rates_();
    verbose_ = false;
    requested_restart_ = false;

    stage_ = ST_INTRO;
    print_banner_();
    go_to_pose_stage_(0); // Step 1
  }

  void update() {
    handle_serial_();
    if (requested_restart_) {
      requested_restart_ = false;
      reset_all_();
      print_banner_();
      go_to_pose_stage_(0);
      return;
    }

    switch (stage_) {
      case ST_POSE: {
        // Run pose machine for current pose index
        PoseResult r = pose_machine_tick_();
        if (r == POSE_DONE) {
          // Store captured pose into the right slot
          poses_[pose_index_] = pose_machine_.avg;
          poses_unit_[pose_index_] = safe_unit_(poses_[pose_index_].acc_mean(), Vec3(0,0,1));
          poses_dom_axis_[pose_index_] = dominant_axis_(poses_unit_[pose_index_]);
          poses_dom_sign_[pose_index_] = dominant_sign_(poses_unit_[pose_index_], poses_dom_axis_[pose_index_]);

          // Validate pose relationship (prevents "all poses identical" ambiguity)
          if (!validate_pose_(pose_index_)) {
            Serial.println("\n[POSE] That capture does not look like the requested pose (too similar to previous).");
            Serial.println("       Re-do this step. (Type 'r' to restart everything.)");
            // stay on same pose, re-arm machine
            go_to_pose_stage_(pose_index_);
            break;
          }

          // Advance
          if (pose_index_ < 3) {
            go_to_pose_stage_(pose_index_ + 1);
          } else {
            stage_ = ST_SOLVE_ACCEL;
            Serial.println("\n[ACCEL] Solving accel mapping from the 4 poses...");
          }
        } else if (r == POSE_FAIL) {
          Serial.println("\n[POSE] Timeout / failed to capture. Type 'r' to restart.");
          stage_ = ST_WAIT_RESTART;
        }
      } break;

      case ST_SOLVE_ACCEL: {
        SignedPerm map_screen;
        float best=0, second=0;
        bool ok = build_mapping_from_poses_(poses_[0], poses_[1], poses_[2], poses_[3], map_screen, &best, &second);

        Serial.printf("[ACCEL] solve score best=%.3f second=%.3f margin=%.3f\n", best, second, best-second);

        if (!ok) {
          Serial.println("\n[ACCEL] Could not solve accel mapping confidently.");
          Serial.println("        Type 'r' to restart and ensure you really do each pose.");
          stage_ = ST_WAIT_RESTART;
          break;
        }

        map_acc_screen_ = map_screen;

        acc_scale_mps2_ = choose_acc_scale_mps2_(map_acc_screen_, poses_[0], poses_[1], poses_[2], poses_[3]);

        Serial.println("\n[ACCEL] Solved mapping + accel scale.");
        print_maps_readable_("ACC", map_acc_screen_);
        Serial.printf("ACC_SCALE_MPS2   = %.9g\n", acc_scale_mps2_);

        stage_ = ST_ROT_READY;
        rot_machine_start_();
      } break;

      case ST_ROT_READY: {
        RotResult rr = rot_machine_tick_();
        if (rr == ROT_READY_DONE) {
          stage_ = ST_ROT_CAPTURE;
          rot_capture_start_us_ = now_us64_();
          rot_.reset();
          Serial.println("[ROT] Capture started. Rotate CLOCKWISE (viewed from above) for ~8s, keep it flat.");
        } else if (rr == ROT_FAIL) {
          Serial.println("\n[ROT] Could not get ready (screen-up + still). Type 'r' to restart.");
          stage_ = ST_WAIT_RESTART;
        }
      } break;

      case ST_ROT_CAPTURE: {
        handle_serial_();
        if (requested_restart_) return;

        IMUSample s;
        bool got_acc=false, got_mag=false;
        if (scheduled_poll_(s, got_acc, got_mag)) {
          // Store at MAG cadence only (keeps memory low, prevents early finish)
          if (got_mag && s.have_mag) rot_.push(s);

          // Progress print
          int64_t now = now_us64_();
          if (verbose_ && (now - rot_last_print_us_ > 900000)) {
            rot_last_print_us_ = now;
            float remain_ms = (float)((int64_t)ROT_CAPTURE_MS * 1000 - (now - rot_capture_start_us_)) / 1000.0f;
            Vec3 a_scr = safe_unit_(apply_perm_(map_acc_screen_, s.acc), Vec3(0,0,1));
            float flat_cos = a_scr.z(); // should be near +1 if screen-up flat in solved SCREEN frame
            Serial.printf("[ROT] capturing... stored=%d/%d  remaining=%.0f ms  flat_cos=%.4f\n",
                          rot_.n, MAX_ROT_SAMPLES, remain_ms, flat_cos);
          }
        }

        int64_t elapsed_us = now_us64_() - rot_capture_start_us_;
        if (elapsed_us >= (int64_t)ROT_CAPTURE_MS * 1000) {
          Serial.printf("[ROT] Done. Stored mag samples: %d (max %d)\n", rot_.n, MAX_ROT_SAMPLES);
          stage_ = ST_SOLVE_MAG_GYRO;
        }
      } break;

      case ST_SOLVE_MAG_GYRO: {
        solve_mag_gyro_and_print_();
        stage_ = ST_DONE;
      } break;

      case ST_WAIT_RESTART: {
        // idle, accept serial
        delay(10);
      } break;

      case ST_DONE: {
        // quiet idle (still accept serial)
        delay(15);
      } break;

      default: break;
    }
  }

private:
  // ===== STAGES =====
  enum Stage {
    ST_INTRO = 0,
    ST_POSE,
    ST_SOLVE_ACCEL,
    ST_ROT_READY,
    ST_ROT_CAPTURE,
    ST_SOLVE_MAG_GYRO,
    ST_WAIT_RESTART,
    ST_DONE
  };
  Stage stage_ = ST_INTRO;

  // ===== Pose machine =====
  enum PoseSub {
    P_WAIT_CHANGE = 0,
    P_SETTLING,
    P_CAPTURING
  };
  enum PoseResult {
    POSE_RUNNING = 0,
    POSE_DONE,
    POSE_FAIL
  };
  struct PoseMachine {
    PoseSub sub = P_WAIT_CHANGE;
    PoseAvg avg;
    Stillness still;
    int64_t t_prompt_us = 0;
    int64_t t_sub_us = 0;
    int64_t last_us = 0;
    int64_t last_print_us = 0;

    // previous pose info (raw)
    bool have_prev = false;
    Vec3 prev_unit = Vec3(0,0,1);
    int prev_dom_axis = 2;
    int prev_dom_sign = +1;

    const char* label = "";
    bool printed = false;
  } pose_machine_;

  int pose_index_ = 0;
  PoseAvg poses_[4];
  Vec3    poses_unit_[4];
  int     poses_dom_axis_[4] = {2,2,2,2};
  int     poses_dom_sign_[4] = {+1,+1,+1,+1};

  // ===== Rotation state =====
  enum RotResult { ROT_READY_RUNNING=0, ROT_READY_DONE, ROT_FAIL };
  int64_t rot_ready_start_us_ = 0;
  int64_t rot_last_print_us_ = 0;
  int64_t rot_capture_start_us_ = 0;
  Stillness rot_still_;
  RotCap rot_;

  // ===== Solved outputs =====
  SignedPerm map_acc_screen_;
  SignedPerm map_mag_screen_;
  float acc_scale_mps2_   = 1.0f;
  float gyro_scale_radps_ = 1.0f;
  float mag_scale_uT_     = 1.0f;
  bool  have_mag_         = false;

  // ===== Scheduler =====
  int64_t next_acc_us_ = 0;
  int64_t next_mag_us_ = 0;
  int64_t acc_period_us_ = 0;
  int64_t mag_period_us_ = 0;
  IMUSample last_sample_;

  // ===== UI =====
  bool verbose_ = false;
  bool requested_restart_ = false;

  // ===== time/util =====
  static inline int64_t now_us64_() {
  #ifdef ARDUINO_ARCH_ESP32
    return (int64_t)esp_timer_get_time();
  #else
    return (int64_t)micros();
  #endif
  }

  static inline float clampf_(float x, float a, float b) { return std::max(a, std::min(b, x)); }

  static inline float safe_norm_(const Vec3& v) {
    float n = v.norm();
    return (std::isfinite(n) && n > 1e-12f) ? n : 0.0f;
  }

  static inline Vec3 safe_unit_(const Vec3& v, const Vec3& fallback = Vec3(0,0,1)) {
    float n = safe_norm_(v);
    return (n > 0.0f) ? (v / n) : fallback;
  }

  static inline float wrap_pi_(float a) {
    while (a >  (float)M_PI) a -= 2.0f * (float)M_PI;
    while (a < -(float)M_PI) a += 2.0f * (float)M_PI;
    return a;
  }

  // ===== serial/buttons =====
  void handle_serial_() {
    M5.update();
    if (M5.BtnA.wasPressed()) {
      // optional: treat BtnA as restart
      requested_restart_ = true;
    }
    while (Serial.available() > 0) {
      char c = (char)Serial.read();
      if (c == 'r' || c == 'R') requested_restart_ = true;
      if (c == 'v' || c == 'V') {
        verbose_ = !verbose_;
        Serial.printf("[UI] verbose=%s\n", verbose_ ? "ON" : "OFF");
      }
    }
  }

  void reset_all_() {
    pose_index_ = 0;
    for (int i=0;i<4;i++) { poses_[i].reset(); poses_unit_[i]=Vec3(0,0,1); poses_dom_axis_[i]=2; poses_dom_sign_[i]=+1; }
    pose_machine_ = PoseMachine();
    rot_.reset();
    rot_still_.reset();

    map_acc_screen_ = make_perm_(0,+1, 1,+1, 2,+1);
    map_mag_screen_ = make_perm_(0,+1, 1,+1, 2,+1);

    acc_scale_mps2_ = 1.0f;
    gyro_scale_radps_ = 1.0f;
    mag_scale_uT_ = 1.0f;
    have_mag_ = false;

    setup_rates_();
    stage_ = ST_POSE;
  }

  void print_banner_() const {
    Serial.println();
    Serial.println("============================================================");
    Serial.println("IMU Auto-Detect Wizard");
    Serial.println("OUTPUT FRAME: NED (screen-up reference)");
    Serial.println("  N = TOP edge, E = RIGHT edge, D = down into table (screen up)");
    Serial.println("Serial commands: 'r' restart, 'v' verbose toggle");
    Serial.println("============================================================");
  }

  // ===== IMU read + scheduler =====
  bool read_imu_once_(IMUSample& out) {
    (void)M5.Imu.update();
    auto d = M5.Imu.getImuData();
    out.t_us = now_us64_();
    out.acc  = Vec3(d.accel.x, d.accel.y, d.accel.z);
    out.gyr  = Vec3(d.gyro.x,  d.gyro.y,  d.gyro.z);
    out.mag  = Vec3(d.mag.x,   d.mag.y,   d.mag.z);

    out.have_mag =
      std::isfinite(out.mag.x()) && std::isfinite(out.mag.y()) && std::isfinite(out.mag.z()) &&
      (std::fabs(out.mag.x()) + std::fabs(out.mag.y()) + std::fabs(out.mag.z()) > 1e-6f);
    return true;
  }

  void setup_rates_() {
    auto hz_to_period = [](float hz)->int64_t {
      if (!(hz > 0.1f)) hz = 1.0f;
      double p = 1000000.0 / (double)hz;
      if (p < 1000.0) p = 1000.0;
      return (int64_t)llround(p);
    };
    acc_period_us_ = hz_to_period(ACC_GYR_RATE_HZ);
    mag_period_us_ = hz_to_period(MAG_RATE_HZ);
    int64_t now = now_us64_();
    next_acc_us_ = now + acc_period_us_;
    next_mag_us_ = now + mag_period_us_;
  }

  // reads IMU only when tick due; drops backlog
  bool scheduled_poll_(IMUSample& out, bool& got_acc, bool& got_mag) {
    got_acc = false; got_mag = false;
    int64_t now = now_us64_();

    bool due_acc = (now >= next_acc_us_);
    bool due_mag = (now >= next_mag_us_);
    if (!due_acc && !due_mag) return false;

    if (due_acc) {
      int64_t late = now - next_acc_us_;
      next_acc_us_ = (late > 2*acc_period_us_) ? (now + acc_period_us_) : (next_acc_us_ + acc_period_us_);
      got_acc = true;
    }
    if (due_mag) {
      int64_t late = now - next_mag_us_;
      next_mag_us_ = (late > 2*mag_period_us_) ? (now + mag_period_us_) : (next_mag_us_ + mag_period_us_);
      got_mag = true;
    }

    read_imu_once_(last_sample_);
    out = last_sample_;
    return true;
  }

  // ===== pose change helpers =====
  static int dominant_axis_(const Vec3& u) {
    float ax = std::fabs(u.x()), ay = std::fabs(u.y()), az = std::fabs(u.z());
    if (ax >= ay && ax >= az) return 0;
    if (ay >= ax && ay >= az) return 1;
    return 2;
  }

  static int dominant_sign_(const Vec3& u, int axis) {
    float v = u(axis);
    return (v >= 0.0f) ? +1 : -1;
  }

  static float max_abs_(const Vec3& u) {
    return std::max(std::fabs(u.x()), std::max(std::fabs(u.y()), std::fabs(u.z())));
  }

  bool pose_changed_vs_prev_(const Vec3& now_unit) const {
    // changed if dot drops OR dominant axis/sign changes
    float dot = clampf_(pose_machine_.prev_unit.dot(now_unit), -1.0f, 1.0f);
    int da = dominant_axis_(now_unit);
    int ds = dominant_sign_(now_unit, da);

    bool dom_strong = (max_abs_(now_unit) > DOM_AXIS_MIN);
    bool dom_changed = (da != pose_machine_.prev_dom_axis) || (ds != pose_machine_.prev_dom_sign);

    return (dot <= CHANGE_DOT_MAX) || (dom_strong && dom_changed);
  }

  void go_to_pose_stage_(int idx) {
    pose_index_ = idx;
    stage_ = ST_POSE;

    // init pose machine
    pose_machine_ = PoseMachine();
    pose_machine_.avg.reset();
    pose_machine_.still.reset();
    pose_machine_.t_prompt_us = now_us64_();
    pose_machine_.t_sub_us = now_us64_();
    pose_machine_.last_us = now_us64_();
    pose_machine_.last_print_us = now_us64_();
    pose_machine_.printed = false;

    // set label and prev
    if (idx == 0) {
      pose_machine_.label = "SCREEN UP (flat)";
      pose_machine_.have_prev = false;
      pose_machine_.sub = P_SETTLING; // first pose doesn't need change detection
    } else if (idx == 1) {
      pose_machine_.label = "SCREEN DOWN (flat)";
      pose_machine_.have_prev = true;
      pose_machine_.prev_unit = poses_unit_[0];
      pose_machine_.prev_dom_axis = poses_dom_axis_[0];
      pose_machine_.prev_dom_sign = poses_dom_sign_[0];
      pose_machine_.sub = P_WAIT_CHANGE;
    } else if (idx == 2) {
      pose_machine_.label = "RIGHT EDGE DOWN (screen facing you)";
      pose_machine_.have_prev = true;
      pose_machine_.prev_unit = poses_unit_[1];
      pose_machine_.prev_dom_axis = poses_dom_axis_[1];
      pose_machine_.prev_dom_sign = poses_dom_sign_[1];
      pose_machine_.sub = P_WAIT_CHANGE;
    } else {
      pose_machine_.label = "TOP EDGE DOWN (screen facing you)";
      pose_machine_.have_prev = true;
      pose_machine_.prev_unit = poses_unit_[2];
      pose_machine_.prev_dom_axis = poses_dom_axis_[2];
      pose_machine_.prev_dom_sign = poses_dom_sign_[2];
      pose_machine_.sub = P_WAIT_CHANGE;
    }

    print_pose_prompt_(idx);
  }

  void print_pose_prompt_(int idx) const {
    Serial.println();
    Serial.println("============================================================");
    if (idx == 0) {
      Serial.println("STEP 1/5: Place device SCREEN UP on a flat surface.");
    } else if (idx == 1) {
      Serial.println("STEP 2/5: Flip device SCREEN DOWN on the same flat surface.");
    } else if (idx == 2) {
      Serial.println("STEP 3/5: Stand device on its RIGHT EDGE (screen facing you; right edge on table).");
    } else {
      Serial.println("STEP 4/5: Stand device on its TOP EDGE (screen facing you; top edge on table).");
    }
    Serial.println("Wait for pose change, then settle, then hold still...");
    Serial.println("(Send 'r' to restart, 'v' verbose toggle.)");
    Serial.println("============================================================");
  }

  bool validate_pose_(int idx) const {
    // Ensure we didn’t accidentally capture essentially the previous pose again.
    if (idx <= 0) return true;

    float dot_prev = clampf_(poses_unit_[idx].dot(poses_unit_[idx-1]), -1.0f, 1.0f);

    if (idx == 1) {
      // screen down should be ~ opposite of screen up
      return (dot_prev < -0.70f);
    }

    // edge poses should be roughly orthogonal to previous (not flat)
    return (std::fabs(dot_prev) < 0.60f);
  }

  PoseResult pose_machine_tick_() {
    handle_serial_();
    if (requested_restart_) return POSE_FAIL;

    int64_t now_us = now_us64_();
    int64_t step_elapsed_ms = (now_us - pose_machine_.t_prompt_us) / 1000;
    if (step_elapsed_ms > (int64_t)POSE_TIMEOUT_MS) return POSE_FAIL;

    IMUSample s;
    bool got_acc=false, got_mag=false;
    if (!scheduled_poll_(s, got_acc, got_mag)) { delay(1); return POSE_RUNNING; }
    if (!got_acc) return POSE_RUNNING;

    Vec3 au = safe_unit_(s.acc, Vec3(0,0,1));
    int da = dominant_axis_(au);
    int ds = dominant_sign_(au, da);
    float dotPrev = pose_machine_.have_prev ? clampf_(pose_machine_.prev_unit.dot(au), -1.0f, 1.0f) : 0.0f;

    // state machine
    if (pose_machine_.sub == P_WAIT_CHANGE) {
      if (!pose_machine_.printed) {
        Serial.printf("[POSE] %s: waiting for pose change...\n", pose_machine_.label);
        pose_machine_.printed = true;
      }

      bool changed = pose_changed_vs_prev_(au);
      if (changed) {
        pose_machine_.sub = P_SETTLING;
        pose_machine_.t_sub_us = now_us64_();
        pose_machine_.still.reset();
        pose_machine_.avg.reset();
        if (verbose_) Serial.printf("[POSE] %s: pose change detected. Settling...\n", pose_machine_.label);
      } else {
        if (verbose_ && (now_us64_() - pose_machine_.last_print_us > 900000)) {
          pose_machine_.last_print_us = now_us64_();
          Serial.printf("[POSE] %s  waiting_change  dotPrev=%.3f  dom=%c%s  maxAbs=%.3f\n",
                        pose_machine_.label,
                        dotPrev,
                        (da==0?'X':(da==1?'Y':'Z')),
                        (ds>0?"+":"-"),
                        max_abs_(au));
        } else if (!verbose_ && (now_us64_() - pose_machine_.last_print_us > 2500000)) {
          pose_machine_.last_print_us = now_us64_();
          Serial.printf("[POSE] %s  waiting for you to change pose... (dotPrev=%.3f)\n",
                        pose_machine_.label, dotPrev);
        }
      }
      return POSE_RUNNING;
    }

    // settling and capturing require stillness
    float dt_s = (float)((s.t_us - pose_machine_.last_us) * 1e-6);
    pose_machine_.last_us = s.t_us;
    if (!(dt_s > 0.0f && dt_s < 0.5f)) dt_s = 0.01f;

    float cos_sim=0, gn=0, th=0, an_rel=0;
    bool still_ok = pose_machine_.still.update_and_check(s.acc, s.gyr, dt_s, &cos_sim, &gn, &th, &an_rel);

    if (pose_machine_.sub == P_SETTLING) {
      uint32_t settled_ms = (uint32_t)((now_us64_() - pose_machine_.t_sub_us) / 1000);
      if (!still_ok) {
        // reset settle timer if moving
        pose_machine_.t_sub_us = now_us64_();
      }
      if (verbose_ && (now_us64_() - pose_machine_.last_print_us > 900000)) {
        pose_machine_.last_print_us = now_us64_();
        Serial.printf("[POSE] %s  settling %ums/%u  still=%s  cos=%.4f  gyro=%.3f<th=%.3f  aRel=%.3f\n",
                      pose_machine_.label,
                      settled_ms, (unsigned)POSE_SETTLE_MS,
                      (still_ok?"yes":"no"), cos_sim, gn, th, an_rel);
      }
      if (settled_ms >= POSE_SETTLE_MS) {
        pose_machine_.sub = P_CAPTURING;
        pose_machine_.t_sub_us = now_us64_();
        pose_machine_.avg.reset();
        pose_machine_.still.reset();
        if (!verbose_) Serial.printf("[POSE] %s: now hold still... capturing\n", pose_machine_.label);
      }
      return POSE_RUNNING;
    }

    // Capturing: require continuous stillness for POSE_STABLE_MS
    if (!still_ok) {
      pose_machine_.t_sub_us = now_us64_();
      pose_machine_.avg.reset();
    } else {
      pose_machine_.avg.add(s);
    }

    uint32_t stable_ms = (uint32_t)((now_us64_() - pose_machine_.t_sub_us) / 1000);
    if (verbose_ && (now_us64_() - pose_machine_.last_print_us > 900000)) {
      pose_machine_.last_print_us = now_us64_();
      Serial.printf("[POSE] %s  stable=%ums/%u  cos=%.4f  gyro=%.3f<th=%.3f  aRel=%.3f  n=%d\n",
                    pose_machine_.label,
                    stable_ms, (unsigned)POSE_STABLE_MS,
                    cos_sim, gn, th, an_rel, pose_machine_.avg.n);
    }

    if (stable_ms >= POSE_STABLE_MS && pose_machine_.avg.n > 30) {
      Serial.printf("[POSE] OK: %s  samples=%d (mag_samples=%d)\n",
                    pose_machine_.label, pose_machine_.avg.n, pose_machine_.avg.nmag);
      return POSE_DONE;
    }

    return POSE_RUNNING;
  }

  // ===== signed perm utilities =====
  int perm_parity3_(int a, int b, int c) const {
    int inv = 0;
    int arr[3] = {a,b,c};
    for (int i=0;i<3;i++) for (int j=i+1;j<3;j++) if (arr[i] > arr[j]) inv++;
    return (inv % 2 == 0) ? +1 : -1;
  }

  SignedPerm make_perm_(int ix,int sx,int iy,int sy,int iz,int sz) const {
    SignedPerm p;
    p.idx[0]=(int8_t)ix; p.sgn[0]=(int8_t)sx;
    p.idx[1]=(int8_t)iy; p.sgn[1]=(int8_t)sy;
    p.idx[2]=(int8_t)iz; p.sgn[2]=(int8_t)sz;
    int parity = perm_parity3_(ix,iy,iz);
    int sprod  = sx * sy * sz;
    p.det = (int8_t)(parity * sprod);
    return p;
  }

  int enumerate_perms_(SignedPerm* out, int max_out, bool det_pos_only) const {
    int n = 0;
    const int perms[6][3] = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
    const int sgns[8][3] = {
      {+1,+1,+1},{+1,+1,-1},{+1,-1,+1},{+1,-1,-1},
      {-1,+1,+1},{-1,+1,-1},{-1,-1,+1},{-1,-1,-1}
    };
    for (int pi=0; pi<6; ++pi) for (int si=0; si<8; ++si) {
      SignedPerm p = make_perm_(perms[pi][0], sgns[si][0],
                                perms[pi][1], sgns[si][1],
                                perms[pi][2], sgns[si][2]);
      if (det_pos_only && p.det < 0) continue;
      if (n < max_out) out[n++] = p;
    }
    return n;
  }

  Vec3 apply_perm_(const SignedPerm& p, const Vec3& v) const {
    Vec3 o;
    o(0) = (float)p.sgn[0] * v((int)p.idx[0]);
    o(1) = (float)p.sgn[1] * v((int)p.idx[1]);
    o(2) = (float)p.sgn[2] * v((int)p.idx[2]);
    return o;
  }

  // ===== mapping solve =====
  float score_dir_(const Vec3& v, const Vec3& target_unit) const {
    Vec3 u = safe_unit_(v, Vec3(0,0,1));
    return u.dot(target_unit);
  }

  // Expected +g in SCREEN frame:
  //  - screen up:       +Z
  //  - screen down:     -Z
  //  - right edge down: -X
  //  - top edge down:   -Y
  bool build_mapping_from_poses_(const PoseAvg& pZ_up,
                                const PoseAvg& pZ_down,
                                const PoseAvg& pX_rightEdgeDown,
                                const PoseAvg& pY_topEdgeDown,
                                SignedPerm& out_map,
                                float* out_best=nullptr,
                                float* out_second=nullptr) const
  {
    Vec3 aZu = pZ_up.acc_mean();
    Vec3 aZd = pZ_down.acc_mean();
    Vec3 aX  = pX_rightEdgeDown.acc_mean();
    Vec3 aY  = pY_topEdgeDown.acc_mean();

    const Vec3 tZu(0,0, 1);
    const Vec3 tZd(0,0,-1);
    const Vec3 tX (-1,0,0);
    const Vec3 tY (0,-1,0);

    SignedPerm perms[64];
    int nperm = enumerate_perms_(perms, 64, false);

    float best = -1e9f, second = -1e9f;
    SignedPerm bestp = perms[0];

    for (int i=0;i<nperm;i++) {
      Vec3 mZu = apply_perm_(perms[i], aZu);
      Vec3 mZd = apply_perm_(perms[i], aZd);
      Vec3 mX  = apply_perm_(perms[i], aX);
      Vec3 mY  = apply_perm_(perms[i], aY);

      float sc = 0.0f;
      sc += 2.8f * score_dir_(mZu, tZu);
      sc += 2.3f * score_dir_(mZd, tZd);
      sc += 2.0f * score_dir_(mX,  tX);
      sc += 2.0f * score_dir_(mY,  tY);

      // penalize inconsistent magnitudes a bit
      float nZu = safe_norm_(mZu), nZd = safe_norm_(mZd), nX = safe_norm_(mX), nY = safe_norm_(mY);
      float nmean = 0.25f*(nZu+nZd+nX+nY);
      float nvar  = (nZu-nmean)*(nZu-nmean)+(nZd-nmean)*(nZd-nmean)+(nX-nmean)*(nX-nmean)+(nY-nmean)*(nY-nmean);
      sc -= 0.12f * nvar / (nmean*nmean + 1e-6f);

      if (sc > best) { second = best; best = sc; bestp = perms[i]; }
      else if (sc > second) { second = sc; }
    }

    if (out_best) *out_best = best;
    if (out_second) *out_second = second;

    out_map = bestp;

    // require decent score and margin
    float margin = best - second;
    return (best > 7.0f) && (margin > 0.20f);
  }

  float choose_acc_scale_mps2_(const SignedPerm& map_screen,
                              const PoseAvg& pZ_up,
                              const PoseAvg& pZ_down,
                              const PoseAvg& pX,
                              const PoseAvg& pY) const
  {
    float mags[4] = {
      safe_norm_(apply_perm_(map_screen, pZ_up.acc_mean())),
      safe_norm_(apply_perm_(map_screen, pZ_down.acc_mean())),
      safe_norm_(apply_perm_(map_screen, pX.acc_mean())),
      safe_norm_(apply_perm_(map_screen, pY.acc_mean()))
    };
    float m = 0.25f*(mags[0]+mags[1]+mags[2]+mags[3]);

    // typical: either ~1 (g units) or ~9.8 (m/s^2)
    if (m > 0.35f && m < 2.3f) return G_STD; // g -> m/s^2
    if (m > 4.0f  && m < 15.0f) return 1.0f; // already m/s^2
    return (m > 1e-6f) ? (G_STD / m) : 1.0f;
  }

  // ===== Rotation ready machine =====
  void rot_machine_start_() {
    Serial.println();
    Serial.println("============================================================");
    Serial.println("STEP 5/5: Rotation test");
    Serial.println("1) Place device SCREEN UP (flat).");
    Serial.println("2) Hold still for ~2 seconds.");
    Serial.println("3) Rotate CLOCKWISE (viewed from above) for ~8 seconds, keep it flat.");
    Serial.println("(Send 'r' to restart, 'v' verbose. BtnA also restarts.)");
    Serial.println("============================================================");

    rot_ready_start_us_ = now_us64_();
    rot_last_print_us_ = now_us64_();
    rot_still_.reset();
    stage_ = ST_ROT_READY;
  }

  RotResult rot_machine_tick_() {
    handle_serial_();
    if (requested_restart_) return ROT_FAIL;

    IMUSample s;
    bool got_acc=false, got_mag=false;
    if (!scheduled_poll_(s, got_acc, got_mag)) { delay(1); return ROT_READY_RUNNING; }
    if (!got_acc) return ROT_READY_RUNNING;

    // Use solved accel mapping to define SCREEN frame (E,N,D) and require screen-up flat:
    // For screen-up at rest, accel should be +Z in that SCREEN frame (by our solve convention).
    Vec3 a_scr_u = safe_unit_(apply_perm_(map_acc_screen_, s.acc), Vec3(0,0,1));
    float flat_cos = a_scr_u.z();

    // stillness check
    static int64_t last_us = 0;
    if (last_us == 0) last_us = s.t_us;
    float dt_s = (float)((s.t_us - last_us) * 1e-6);
    last_us = s.t_us;
    if (!(dt_s > 0.0f && dt_s < 0.5f)) dt_s = 0.01f;

    float cos_sim=0, gn=0, th=0, an_rel=0;
    bool still_ok = rot_still_.update_and_check(s.acc, s.gyr, dt_s, &cos_sim, &gn, &th, &an_rel);

    bool flat_ok = (flat_cos > 0.97f);
    if (!flat_ok || !still_ok) {
      rot_ready_start_us_ = now_us64_(); // reset ready timer
    }

    int64_t now = now_us64_();
    if (verbose_ && (now - rot_last_print_us_ > 900000)) {
      rot_last_print_us_ = now;
      uint32_t remain_ms = (uint32_t)std::max<int64_t>(0, (int64_t)ROT_READY_MS*1000 - (now - rot_ready_start_us_)) / 1000;
      Serial.printf("[ROT] get ready... %u ms  flat_cos=%.4f(%s)  still=%s\n",
                    (unsigned)remain_ms, flat_cos, (flat_ok?"ok":"no"), (still_ok?"yes":"no"));
    } else if (!verbose_ && (now - rot_last_print_us_ > 1300000)) {
      rot_last_print_us_ = now;
      uint32_t remain_ms = (uint32_t)std::max<int64_t>(0, (int64_t)ROT_READY_MS*1000 - (now - rot_ready_start_us_)) / 1000;
      Serial.printf("[ROT] get ready... %u ms\n", (unsigned)remain_ms);
    }

    if ((now - rot_ready_start_us_) >= (int64_t)ROT_READY_MS * 1000) {
      return ROT_READY_DONE;
    }
    return ROT_READY_RUNNING;
  }

  // ===== Mag + gyro solve (stack-safe) =====
  struct CorrAcc {
    double sx=0, sy=0, sxx=0, syy=0, sxy=0;
    int n=0;
    void reset(){ sx=sy=sxx=syy=sxy=0; n=0; }
    void add(double x, double y){
      sx += x; sy += y;
      sxx += x*x; syy += y*y;
      sxy += x*y;
      n++;
    }
    float corr() const {
      if (n < 12) return 0.0f;
      const double mx = sx / (double)n;
      const double my = sy / (double)n;
      const double vx = sxx - (double)n * mx * mx;
      const double vy = syy - (double)n * my * my;
      const double c  = sxy - (double)n * mx * my;
      const double denom = std::sqrt(std::max(0.0, vx) * std::max(0.0, vy));
      if (!(denom > 1e-12)) return 0.0f;
      return (float)(c / denom);
    }
  };

  SignedPerm find_best_mag_mapping_(const RotCap& cap,
                                   const SignedPerm& map_acc_screen,
                                   float& out_heading_unwrap_rad,
                                   float& out_mag_norm_mean_raw,
                                   float& out_corr_abs) const
  {
    SignedPerm perms[64];
    const int nperm = enumerate_perms_(perms, 64, true);

    const int n = std::min(cap.n, MAX_ROT_SAMPLES);
    if (n < 30) {
      out_heading_unwrap_rad = 0.0f;
      out_mag_norm_mean_raw  = 0.0f;
      out_corr_abs           = 0.0f;
      return make_perm_(0,+1, 1,+1, 2,+1);
    }

    float bestScore = -1e9f;
    SignedPerm bestP = perms[0];
    float best_corr_abs = 0.0f;
    float best_heading_unwrap = 0.0f;
    float best_mag_norm_mean = 0.0f;

    for (int pi=0; pi<nperm; ++pi) {
      bool psi_init = false;
      float psi_prev = 0.0f;
      float psi_unwrap = 0.0f;
      float psi_total_abs = 0.0f;

      double mag_norm_sum = 0.0;
      int mag_norm_n = 0;

      CorrAcc acc;
      acc.reset();

      for (int i=1;i<n;i++) {
        const IMUSample& s0 = cap.s[i-1];
        const IMUSample& s1 = cap.s[i];

        const float dt = (float)((s1.t_us - s0.t_us) * 1e-6);
        if (!(dt > 1e-6f && dt < 0.2f)) continue;
        if (!s1.have_mag) continue;

        const Vec3 g_scr = apply_perm_(map_acc_screen, s1.gyr);
        const float wz = g_scr.z();

        const Vec3 m_scr = apply_perm_(perms[pi], s1.mag);

        const float mn = safe_norm_(m_scr);
        if (mn > 1e-6f) { mag_norm_sum += (double)mn; mag_norm_n++; }

        const float psi = std::atan2(m_scr.y(), m_scr.x());

        if (!psi_init) {
          psi_prev = psi;
          psi_unwrap = psi;
          psi_init = true;
          continue;
        }

        const float dpsi = wrap_pi_(psi - psi_prev);
        psi_prev = psi;
        psi_unwrap += dpsi;
        psi_total_abs += std::fabs(dpsi);

        const float hrate = dpsi / dt; // rad/s
        acc.add((double)wz, (double)hrate);
      }

      if (acc.n < 24 || mag_norm_n < 24) continue;

      const float c = acc.corr();
      const float cabs = std::fabs(c);
      const float mag_norm_mean = (float)(mag_norm_sum / (double)mag_norm_n);

      const float score = 3.0f * cabs + 0.0015f * psi_total_abs;

      if (score > bestScore) {
        bestScore = score;
        bestP = perms[pi];
        best_corr_abs = cabs;
        best_heading_unwrap = psi_unwrap;
        best_mag_norm_mean = mag_norm_mean;
      }
    }

    out_heading_unwrap_rad = best_heading_unwrap;
    out_mag_norm_mean_raw  = best_mag_norm_mean;
    out_corr_abs           = best_corr_abs;
    return bestP;
  }

  float choose_mag_scale_uT_(float mag_norm_mean_raw) const {
    const float candidates[] = { 1.0f, 0.1f, 10.0f, 0.01f, 100.0f, 0.001f };
    float best = candidates[0];
    float bestCost = 1e9f;
    for (float s : candidates) {
      float muT = mag_norm_mean_raw * s;
      float cost = 0.0f;
      if (muT < 15.0f) cost += (15.0f - muT) * (15.0f - muT);
      if (muT > 100.0f) cost += (muT - 100.0f) * (muT - 100.0f);
      cost += 0.015f * (muT - 50.0f) * (muT - 50.0f);
      if (cost < bestCost) { bestCost = cost; best = s; }
    }
    return best;
  }

  float choose_gyro_scale_radps_(float heading_unwrap_rad, float gyro_int_raw) const {
    const float DEG2RAD = (float)M_PI / 180.0f;

    if (std::isfinite(heading_unwrap_rad) && std::isfinite(gyro_int_raw) && std::fabs(gyro_int_raw) > 1e-6f) {
      float s = std::fabs(heading_unwrap_rad / gyro_int_raw);
      if (s > 1e-4f && s < 10.0f) {
        float d0 = std::fabs(s - 1.0f);
        float d1 = std::fabs(s - DEG2RAD);
        if (d1 < 0.5f * d0) return DEG2RAD;
        return s;
      }
    }

    auto cost_for = [&](float scale)->float {
      float x = std::fabs(gyro_int_raw) * scale;
      if (!(x > 1e-6f)) return 1e9f;
      float k = std::round(x / (2.0f*(float)M_PI));
      if (k < 1.0f) k = 1.0f;
      return std::fabs(x - k * 2.0f*(float)M_PI);
    };

    float c_rad = cost_for(1.0f);
    float c_deg = cost_for(DEG2RAD);
    return (c_deg < c_rad) ? DEG2RAD : 1.0f;
  }

  // ===== readable mapping output =====
  void print_axis_expr_(int idx, int sgn) const {
    char axis = (idx==0?'X':(idx==1?'Y':'Z'));
    Serial.print(sgn >= 0 ? "+" : "-");
    Serial.print(axis);
  }

  void print_map_triplet_(const SignedPerm& p, bool ned_order) const {
    // p is raw->SCREEN where SCREEN axes are (E,N,D) = (X,Y,Z)
    // NED order output should be (N,E,D) = (Y,X,Z)
    int o_idx[3];
    int o_sgn[3];
    if (!ned_order) {
      o_idx[0]=p.idx[0]; o_sgn[0]=p.sgn[0]; // E (X)
      o_idx[1]=p.idx[1]; o_sgn[1]=p.sgn[1]; // N (Y)
      o_idx[2]=p.idx[2]; o_sgn[2]=p.sgn[2]; // D (Z)
      Serial.print("[E,N,D] = [");
    } else {
      o_idx[0]=p.idx[1]; o_sgn[0]=p.sgn[1]; // N
      o_idx[1]=p.idx[0]; o_sgn[1]=p.sgn[0]; // E
      o_idx[2]=p.idx[2]; o_sgn[2]=p.sgn[2]; // D
      Serial.print("[N,E,D] = [");
    }

    print_axis_expr_(o_idx[0], o_sgn[0]); Serial.print(", ");
    print_axis_expr_(o_idx[1], o_sgn[1]); Serial.print(", ");
    print_axis_expr_(o_idx[2], o_sgn[2]); Serial.print("]");
  }

  AxisMap map_to_axisMapNED_(const SignedPerm& p_screen) const {
    // SignedPerm p_screen is raw->SCREEN (E,N,D) in (X,Y,Z)
    AxisMap m;
    m.idx[0] = p_screen.idx[1]; m.sgn[0] = p_screen.sgn[1]; // N
    m.idx[1] = p_screen.idx[0]; m.sgn[1] = p_screen.sgn[0]; // E
    m.idx[2] = p_screen.idx[2]; m.sgn[2] = p_screen.sgn[2]; // D
    return m;
  }

  void print_maps_readable_(const char* name, const SignedPerm& p_screen) const {
    Serial.printf("%s_MAP raw->SCREEN ", name);
    print_map_triplet_(p_screen, false);
    Serial.println();

    Serial.printf("%s_MAP raw->NED(screen-up) ", name);
    print_map_triplet_(p_screen, true);
    Serial.println();
  }

  // ===== final solve =====
  void solve_mag_gyro_and_print_() {
    // Decide if we have mag samples
    int magCount = 0;
    for (int i=0;i<rot_.n;i++) if (rot_.s[i].have_mag) magCount++;
    have_mag_ = (magCount > 60);

    float heading_unwrap_rad = 0.0f;
    float mag_norm_mean_raw  = 0.0f;
    float corr_abs           = 0.0f;

    if (have_mag_) {
      map_mag_screen_ = find_best_mag_mapping_(rot_, map_acc_screen_, heading_unwrap_rad, mag_norm_mean_raw, corr_abs);
      mag_scale_uT_ = choose_mag_scale_uT_(mag_norm_mean_raw);
    } else {
      map_mag_screen_ = make_perm_(0,+1, 1,+1, 2,+1);
      mag_scale_uT_ = 1.0f;
    }

    // integrate gyro z in SCREEN frame over rotation window (use stored mag samples)
    double gyro_int = 0.0;
    for (int i=1;i<rot_.n;i++) {
      float dt_s = (float)((rot_.s[i].t_us - rot_.s[i-1].t_us) * 1e-6);
      if (!(dt_s > 1e-6f && dt_s < 0.2f)) continue;
      Vec3 g_scr = apply_perm_(map_acc_screen_, rot_.s[i].gyr);
      gyro_int += (double)g_scr.z() * (double)dt_s;
    }

    gyro_scale_radps_ = choose_gyro_scale_radps_(heading_unwrap_rad, (float)gyro_int);

    Serial.println();
    Serial.println("########################### RESULTS ###########################");
    Serial.printf("Mag availability: %s\n", have_mag_ ? "YES" : "NO (mag unavailable or always zero)");

    Serial.println("\nScales (multiply RAW by these):");
    Serial.printf("ACC_SCALE_MPS2   = %.9g\n", acc_scale_mps2_);
    Serial.printf("GYRO_SCALE_RADPS = %.9g\n", gyro_scale_radps_);
    Serial.printf("MAG_SCALE_UT     = %.9g\n", mag_scale_uT_);

    Serial.println("\nAxis maps (RAW -> NED, screen-up reference):");
    print_maps_readable_("ACC", map_acc_screen_);
    Serial.println("GYRO uses the SAME map as ACC.");
    if (have_mag_) print_maps_readable_("MAG", map_mag_screen_);

    if (have_mag_) {
      Serial.println("\nDiagnostics:");
      Serial.printf("  mag corr |corr| ~ %.3f  (higher is better; <0.40 is unreliable)\n", corr_abs);
      Serial.printf("  heading unwrap ~ %.2f rad (%.1f deg)\n", heading_unwrap_rad, heading_unwrap_rad * 180.0f / (float)M_PI);
      Serial.printf("  mag norm mean raw=%.3f => scaled=%.2f uT\n",
                    mag_norm_mean_raw, mag_norm_mean_raw * mag_scale_uT_);
      Serial.printf("  gyro integral raw (screen z) = %.6f (raw_units*s)\n", (float)gyro_int);
    }

    Serial.println("\n=== Paste-friendly constants (NED order: N,E,D) ===");
    Serial.println("struct AxisMap { int8_t idx[3]; int8_t sgn[3]; };");
    Serial.println("static inline Eigen::Matrix<float,3,1> apply_map(const AxisMap& m, const Eigen::Matrix<float,3,1>& v){");
    Serial.println("  Eigen::Matrix<float,3,1> o;");
    Serial.println("  o(0) = (float)m.sgn[0]*v((int)m.idx[0]); // N");
    Serial.println("  o(1) = (float)m.sgn[1]*v((int)m.idx[1]); // E");
    Serial.println("  o(2) = (float)m.sgn[2]*v((int)m.idx[2]); // D");
    Serial.println("  return o;");
    Serial.println("}");

    AxisMap accNED = map_to_axisMapNED_(map_acc_screen_);
    Serial.printf("static constexpr AxisMap ACC_MAP_NED  = {{%d,%d,%d},{%d,%d,%d}};\n",
                  accNED.idx[0], accNED.idx[1], accNED.idx[2],
                  accNED.sgn[0], accNED.sgn[1], accNED.sgn[2]);

    Serial.printf("static constexpr AxisMap GYRO_MAP_NED = {{%d,%d,%d},{%d,%d,%d}};\n",
                  accNED.idx[0], accNED.idx[1], accNED.idx[2],
                  accNED.sgn[0], accNED.sgn[1], accNED.sgn[2]);

    if (have_mag_) {
      AxisMap magNED = map_to_axisMapNED_(map_mag_screen_);
      Serial.printf("static constexpr AxisMap MAG_MAP_NED  = {{%d,%d,%d},{%d,%d,%d}};\n",
                    magNED.idx[0], magNED.idx[1], magNED.idx[2],
                    magNED.sgn[0], magNED.sgn[1], magNED.sgn[2]);
    }

    Serial.printf("static constexpr float ACC_SCALE_MPS2   = %.9g;\n", acc_scale_mps2_);
    Serial.printf("static constexpr float GYRO_SCALE_RADPS = %.9g;\n", gyro_scale_radps_);
    Serial.printf("static constexpr float MAG_SCALE_UT     = %.9g;\n", mag_scale_uT_);
    Serial.println("###############################################################");

    if (have_mag_ && corr_abs < 0.40f) {
      Serial.println("\n[WARN] Mag axis solve looks unreliable (low correlation).");
      Serial.println("       Re-run rotation: keep it flat, rotate smoothly, away from metal.");
      Serial.println("       Type 'r' to restart.");
    }
  }
};

// ===== Global instance =====
static IMUWizard g_wiz;

void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);
  delay(350);
  g_wiz.begin();
}

void loop() {
  g_wiz.update();
}
