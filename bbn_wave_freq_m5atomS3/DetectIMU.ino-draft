/*
  AtomS3R (M5Unified) â€” IMU Auto-detect Wizard (single-file .ino)

  OUTPUT FRAME (NED, screen-up reference):
    N = TOP edge of screen
    E = RIGHT edge of screen
    D = DOWN into table when screen is up

  Serial commands: 'r' restart, 'v' verbose toggle. BtnA restarts.
*/

#include <Arduino.h>
#include <M5Unified.h>
#include <stdint.h>
#include <stddef.h>
#include <math.h>

// ---------------------------- constants ----------------------------
static constexpr float kGStd = 9.80665f;
static constexpr float kPi   = 3.14159265358979323846f;

// ---------------------------- tiny vector ----------------------------
struct Vec3 {
  float x=0, y=0, z=0;
  Vec3() = default;
  Vec3(float X,float Y,float Z):x(X),y(Y),z(Z){}
  Vec3 operator+(const Vec3& o) const { return {x+o.x,y+o.y,z+o.z}; }
  Vec3 operator-(const Vec3& o) const { return {x-o.x,y-o.y,z-o.z}; }
  Vec3 operator*(float s) const { return {x*s,y*s,z*s}; }
};

static inline float dot3(const Vec3& a, const Vec3& b){ return a.x*b.x + a.y*b.y + a.z*b.z; }
static inline float norm3(const Vec3& a){ return sqrtf(dot3(a,a)); }

static inline Vec3 normalize3(const Vec3& a){
  float n = norm3(a);
  if (!(n > 1e-12f) || !isfinite(n)) return {0,0,0};
  return a * (1.0f/n);
}

static inline float clampf(float v, float lo, float hi){ return (v<lo)?lo:((v>hi)?hi:v); }

static inline float wrap_pi(float a){
  while (a >  kPi) a -= 2.0f*kPi;
  while (a < -kPi) a += 2.0f*kPi;
  return a;
}

// ---------------------------- axis map (MUST be defined before helpers) ----------------------------
struct AxisMap { uint8_t idx[3]; int8_t sgn[3]; };

// out[k] = sgn[k] * raw[idx[k]]
static inline Vec3 apply_map3(const AxisMap& m, const Vec3& raw){
  float r[3] = {raw.x, raw.y, raw.z};
  return Vec3{
    (float)m.sgn[0] * r[m.idx[0]],
    (float)m.sgn[1] * r[m.idx[1]],
    (float)m.sgn[2] * r[m.idx[2]]
  };
}

static inline void map_to_str(const AxisMap& m, char* out, size_t outN){
  const char* ax[3] = {"X","Y","Z"};
  auto fmt1 = [&](int k, char* tmp, size_t n){
    snprintf(tmp, n, "%c%s", (m.sgn[k]>=0?'+':'-'), ax[m.idx[k]]);
  };
  char a0[8], a1[8], a2[8];
  fmt1(0,a0,sizeof(a0)); fmt1(1,a1,sizeof(a1)); fmt1(2,a2,sizeof(a2));
  snprintf(out, outN, "[%s, %s, %s]", a0,a1,a2);
}

static inline AxisMap make_map_(int ix,int sx,int iy,int sy,int iz,int sz){
  AxisMap m;
  m.idx[0]=(uint8_t)ix; m.sgn[0]=(int8_t)sx;
  m.idx[1]=(uint8_t)iy; m.sgn[1]=(int8_t)sy;
  m.idx[2]=(uint8_t)iz; m.sgn[2]=(int8_t)sz;
  return m;
}

// ---------------------------- wizard ----------------------------
class IMUWizard {
public:
  void begin(){ restart_(); }

  void update(){
    M5.update();
    if (M5.BtnA.wasPressed()) restart_();
    handle_serial_();

    read_sample_();
    maybe_rate_report_();

    switch (state_) {
      case State::POSES:   update_pose_steps_(); break;
      case State::SOLVE_A: solve_accel_();       break;
      case State::ROT:     update_rotation_();   break;
      case State::SOLVE_M: solve_mag_gyro_();    break;
      case State::DONE:    break;
    }
  }

private:
  // ---------- config ----------
  static constexpr uint32_t SETTLE_MS       = 2500;
  static constexpr uint32_t STABLE_NEED_MS  = 1400;

  static constexpr float    POSE_CHANGE_DOT_TH  = 0.75f;
  static constexpr uint32_t POSE_CHANGE_HOLD_MS = 250;

  static constexpr float    STILL_COS_TH   = 0.9985f;
  static constexpr float    ACC_REL_TH     = 0.0100f; // 1%
  static constexpr float    GYRO_ABS_MAX   = 8.0f;
  static constexpr float    GYRO_FLOOR     = 0.35f;
  static constexpr float    EMA_TAU_DIR_S  = 0.25f;
  static constexpr float    EMA_TAU_NORM_S = 0.35f;
  static constexpr float    EMA_TAU_GYR_S  = 0.45f;

  static constexpr uint32_t ROT_READY_MS   = 2000;
  static constexpr uint32_t ROT_CAPTURE_MS = 8000;
  static constexpr uint32_t ROT_STORE_MS   = 20;   // ~50 Hz store
  static constexpr int      ROT_MAX        = 520;

  static constexpr float    ROT_UP_DOT_TH_READY = 0.985f;
  static constexpr float    ROT_UP_DOT_TH_CAP   = 0.970f;

  static constexpr float    MAG_CORR_MIN   = 0.35f;
  static constexpr float    MAG_ROTABS_MIN = 3.0f;

  // ---------- data ----------
  enum class State : uint8_t { POSES, SOLVE_A, ROT, SOLVE_M, DONE };
  State state_ = State::POSES;

  struct PoseAvg {
    uint32_t n=0, nmag=0;
    Vec3 acc_sum{0,0,0}, gyr_sum{0,0,0}, mag_sum{0,0,0};
    float acc_norm_sum=0;

    void reset(){ n=0; nmag=0; acc_sum=gyr_sum=mag_sum={0,0,0}; acc_norm_sum=0; }
    void add(const Vec3& a, const Vec3& g, const Vec3& m, bool haveMag){
      n++;
      acc_sum = acc_sum + a;
      gyr_sum = gyr_sum + g;
      acc_norm_sum += norm3(a);
      if (haveMag){ nmag++; mag_sum = mag_sum + m; }
    }
    Vec3 acc_mean() const { return n? (acc_sum*(1.0f/(float)n)) : Vec3{0,0,0}; }
    Vec3 gyr_mean() const { return n? (gyr_sum*(1.0f/(float)n)) : Vec3{0,0,0}; }
    Vec3 mag_mean() const { return nmag? (mag_sum*(1.0f/(float)nmag)) : Vec3{0,0,0}; }
  };

  PoseAvg pose_[4];
  const char* pose_name_[4] = {
    "SCREEN UP (flat)",
    "SCREEN DOWN (flat)",
    "RIGHT EDGE DOWN (screen facing you; right edge on table)",
    "TOP EDGE DOWN (screen facing you; top edge on table)"
  };

  int pose_i_ = 0;
  enum class PosePhase : uint8_t { WAIT_CHANGE, SETTLE, CAPTURE };
  PosePhase pose_phase_ = PosePhase::SETTLE;
  bool entered_step_ = true;
  uint32_t phase_t0_ms_ = 0;

  bool prev_pose_valid_ = false;
  Vec3 prev_pose_u_raw_{0,0,0};
  uint32_t change_hold_t0_ms_ = 0;
  bool change_hold_active_ = false;

  Vec3  a_unit_ema_{0,0,1};
  float a_norm_ema_ = 1.0f;
  float gyro_ema_   = 0.0f;
  uint32_t stable_ms_ = 0;

  float dt_s_ = 0.01f;
  Vec3 acc_raw_{0,0,0}, gyr_raw_{0,0,0}, mag_raw_{0,0,0};
  bool have_mag_ = false;

  // rotation buffers (global storage, not stack)
  Vec3  rot_mag_[ROT_MAX];
  Vec3  rot_gyr_[ROT_MAX];
  float rot_dt_[ROT_MAX];
  bool  rot_haveMag_[ROT_MAX];
  int   rot_n_ = 0;

  enum class RotPhase : uint8_t { WAIT_SCREENUP, READY_STILL, CAPTURE };
  RotPhase rot_phase_ = RotPhase::WAIT_SCREENUP;
  uint32_t rot_phase_t0_ms_ = 0;
  uint32_t rot_t0_ms_ = 0;
  uint32_t rot_last_store_ms_ = 0;

  bool verbose_ = false;
  uint32_t last_status_ms_ = 0;

  // rate reporting
  uint32_t rate_t0_ms_ = 0;
  uint32_t rate_acc_n_ = 0;
  uint32_t rate_mag_n_ = 0;

  // solutions
  bool accel_ok_=false, gyro_ok_=false, mag_ok_=false;
  AxisMap acc_map_screen_{{0,1,2},{+1,+1,+1}};
  AxisMap gyr_map_screen_{{0,1,2},{+1,+1,+1}};
  AxisMap mag_map_screen_{{0,1,2},{+1,+1,+1}};
  AxisMap acc_map_ned_{{1,0,2},{+1,+1,+1}};
  AxisMap gyr_map_ned_{{1,0,2},{+1,+1,+1}};
  AxisMap mag_map_ned_{{1,0,2},{+1,+1,+1}};
  float acc_scale_mps2_=1.0f, gyro_scale_radps_=1.0f, mag_scale_ut_=1.0f;

private:
  void banner_(){
    Serial.println();
    Serial.println("============================================================");
    Serial.println("IMU Auto-Detect Wizard");
    Serial.println("OUTPUT FRAME: NED (screen-up reference)");
    Serial.println("  N = TOP edge, E = RIGHT edge, D = down into table (screen up)");
    Serial.println("Commands: 'r' restart, 'v' verbose. BtnA restarts.");
    Serial.println("============================================================");
  }

  void print_pose_prompt_(int i){
    Serial.println();
    Serial.println("============================================================");
    Serial.printf("STEP %d/5: %s\n", i+1, pose_name_[i]);
    if (i == 0) {
      Serial.println("Wait for settle, then hold still...");
    } else {
      Serial.println("MOVE to the new pose now.");
      Serial.println("Code will WAIT until it detects pose changed, then settle+capture.");
    }
    Serial.println("(Send 'r' to restart, 'v' verbose.)");
    Serial.println("============================================================");
  }

  void print_rot_prompt_(){
    Serial.println();
    Serial.println("============================================================");
    Serial.println("STEP 5/5: Rotation test");
    Serial.println("1) Place device SCREEN UP (flat).");
    Serial.println("2) Hold still for ~2 seconds.");
    Serial.println("3) Rotate CLOCKWISE (viewed from above) for ~8 seconds, keep it flat.");
    Serial.println("Tip: aim for ~270-360 degrees total rotation for best mag solve.");
    Serial.println("(Send 'r' to restart, 'v' verbose. BtnA also restarts.)");
    Serial.println("============================================================");
  }

  void restart_(){
    for (auto &p: pose_) p.reset();
    pose_i_ = 0;
    pose_phase_ = PosePhase::SETTLE;
    entered_step_ = true;

    prev_pose_valid_ = false;
    prev_pose_u_raw_ = {0,0,0};
    change_hold_active_ = false;
    change_hold_t0_ms_ = 0;

    reset_stability_();

    rot_n_ = 0;
    rot_phase_ = RotPhase::WAIT_SCREENUP;
    rot_phase_t0_ms_ = millis();
    rot_t0_ms_ = 0;
    rot_last_store_ms_ = 0;

    accel_ok_=gyro_ok_=mag_ok_=false;
    acc_map_screen_ = {{0,1,2},{+1,+1,+1}};
    gyr_map_screen_ = {{0,1,2},{+1,+1,+1}};
    mag_map_screen_ = {{0,1,2},{+1,+1,+1}};
    rebuild_ned_maps_();

    acc_scale_mps2_=gyro_scale_radps_=mag_scale_ut_=1.0f;

    rate_t0_ms_ = millis();
    rate_acc_n_ = rate_mag_n_ = 0;

    banner_();
    print_pose_prompt_(0);
  }

  void handle_serial_(){
    while (Serial.available() > 0) {
      char c = (char)Serial.read();
      if (c=='r' || c=='R') restart_();
      if (c=='v' || c=='V') {
        verbose_ = !verbose_;
        Serial.printf("[VERBOSE] %s\n", verbose_ ? "ON" : "OFF");
      }
    }
  }

  void maybe_rate_report_(){
    uint32_t now = millis();
    if (now - rate_t0_ms_ < 1000) return;
    float dt = (now - rate_t0_ms_) * 1e-3f;
    if (!(dt > 0)) dt = 1.0f;
    Serial.printf("[RATE] acc/gyro observed ~%.1f Hz\n", rate_acc_n_/dt);
    Serial.printf("[RATE] mag observed     ~%.1f Hz %s\n", rate_mag_n_/dt, have_mag_ ? "" : "(mag unavailable?)");
    rate_t0_ms_ = now;
    rate_acc_n_ = rate_mag_n_ = 0;
  }

  void read_sample_(){
    static uint32_t last_us = 0;
    uint32_t now_us = (uint32_t)micros();
    if (last_us == 0) last_us = now_us;
    uint32_t du = now_us - last_us;
    last_us = now_us;

    float dt = du * 1e-6f;
    if (!(dt > 0.0005f && dt < 0.2f)) dt = 0.01f;
    dt_s_ = dt;

    (void)M5.Imu.update();
    auto d = M5.Imu.getImuData();

    acc_raw_ = Vec3(d.accel.x, d.accel.y, d.accel.z);
    gyr_raw_ = Vec3(d.gyro.x,  d.gyro.y,  d.gyro.z);
    mag_raw_ = Vec3(d.mag.x,   d.mag.y,   d.mag.z);

    have_mag_ =
      isfinite(mag_raw_.x) && isfinite(mag_raw_.y) && isfinite(mag_raw_.z) &&
      (fabsf(mag_raw_.x) + fabsf(mag_raw_.y) + fabsf(mag_raw_.z) > 1e-6f);

    rate_acc_n_++;
    if (have_mag_) rate_mag_n_++;
  }

  void reset_stability_(){
    a_unit_ema_ = Vec3(0,0,1);
    a_norm_ema_ = 1.0f;
    gyro_ema_   = 0.0f;
    stable_ms_  = 0;
  }

  bool update_stable_(const Vec3& a_raw, const Vec3& g_raw,
                      float* out_cos=nullptr, float* out_gn=nullptr,
                      float* out_th=nullptr, float* out_arel=nullptr)
  {
    float alpha_dir  = clampf(dt_s_ / EMA_TAU_DIR_S,  0.01f, 0.25f);
    float alpha_norm = clampf(dt_s_ / EMA_TAU_NORM_S, 0.01f, 0.25f);
    float alpha_gyr  = clampf(dt_s_ / EMA_TAU_GYR_S,  0.01f, 0.25f);

    Vec3 au = normalize3(a_raw);
    Vec3 mix = a_unit_ema_ * (1.0f - alpha_dir) + au * alpha_dir;
    a_unit_ema_ = normalize3(mix);

    float an = norm3(a_raw);
    if (an > 1e-6f && isfinite(an)) a_norm_ema_ = (1.0f-alpha_norm)*a_norm_ema_ + alpha_norm*an;

    float gn = norm3(g_raw);
    if (!isfinite(gn)) gn = 0.0f;
    gyro_ema_ = (1.0f-alpha_gyr)*gyro_ema_ + alpha_gyr*gn;

    float cos_sim = clampf(dot3(au, a_unit_ema_), -1.0f, 1.0f);
    float gyro_th = fmaxf(GYRO_FLOOR, 3.0f*gyro_ema_ + GYRO_FLOOR);

    float arel = 0.0f;
    if (a_norm_ema_ > 1e-6f) arel = fabsf(an - a_norm_ema_) / a_norm_ema_;

    bool ok = (cos_sim > STILL_COS_TH) && (gn < gyro_th) && (gn < GYRO_ABS_MAX) && (arel < ACC_REL_TH);

    if (ok) stable_ms_ += (uint32_t)(dt_s_ * 1000.0f);
    else stable_ms_ = 0;

    if (out_cos) *out_cos = cos_sim;
    if (out_gn)  *out_gn  = gn;
    if (out_th)  *out_th  = gyro_th;
    if (out_arel)*out_arel= arel;
    return ok;
  }

  bool should_status_(uint32_t now, uint32_t period){
    if (last_status_ms_ == 0 || now - last_status_ms_ >= period) {
      last_status_ms_ = now;
      return true;
    }
    return false;
  }

  void update_pose_steps_(){
    if (entered_step_) {
      entered_step_ = false;
      phase_t0_ms_ = millis();
      last_status_ms_ = 0;
      reset_stability_();
      if (pose_i_ == 0) pose_phase_ = PosePhase::SETTLE;
      else pose_phase_ = PosePhase::WAIT_CHANGE;
      change_hold_active_ = false;
    }

    uint32_t now = millis();
    Vec3 au = normalize3(acc_raw_);

    if (pose_phase_ == PosePhase::WAIT_CHANGE) {
      float dotPrev = prev_pose_valid_ ? dot3(au, prev_pose_u_raw_) : 1.0f;
      bool changed = (!prev_pose_valid_) ? true : (dotPrev < POSE_CHANGE_DOT_TH);

      if (changed) {
        if (!change_hold_active_) { change_hold_active_=true; change_hold_t0_ms_=now; }
        if ((now - change_hold_t0_ms_) >= POSE_CHANGE_HOLD_MS) {
          pose_phase_ = PosePhase::SETTLE;
          phase_t0_ms_ = now;
          reset_stability_();
          if (verbose_) Serial.println("[POSE] change detected -> settling");
        }
      } else {
        change_hold_active_ = false;
      }

      if (should_status_(now, 700)) {
        Serial.printf("[POSE] %s  waiting_pose_change  dotPrev=%.3f\n", pose_name_[pose_i_], dotPrev);
      }
      return;
    }

    if (pose_phase_ == PosePhase::SETTLE) {
      uint32_t elapsed = now - phase_t0_ms_;
      if (elapsed >= SETTLE_MS) {
        pose_phase_ = PosePhase::CAPTURE;
        phase_t0_ms_ = now;
        reset_stability_();
        pose_[pose_i_].reset();
        if (verbose_) Serial.println("[POSE] settle done -> capture");
      } else {
        if (should_status_(now, 800)) {
          Serial.printf("[POSE] %s  settling... %ums remaining\n", pose_name_[pose_i_], (unsigned)(SETTLE_MS - elapsed));
        }
      }
      return;
    }

    float cos_sim=0, gn=0, th=0, arel=0;
    bool ok = update_stable_(acc_raw_, gyr_raw_, &cos_sim, &gn, &th, &arel);

    if (ok) {
      pose_[pose_i_].add(acc_raw_, gyr_raw_, mag_raw_, have_mag_);
      if (stable_ms_ >= STABLE_NEED_MS && pose_[pose_i_].n > 60) {
        Serial.printf("[POSE] OK: %s  samples=%u (mag_samples=%u)\n",
                      pose_name_[pose_i_], (unsigned)pose_[pose_i_].n, (unsigned)pose_[pose_i_].nmag);
        prev_pose_u_raw_ = normalize3(pose_[pose_i_].acc_mean());
        prev_pose_valid_ = true;

        pose_i_++;
        entered_step_ = true;

        if (pose_i_ < 4) {
          print_pose_prompt_(pose_i_);
        } else {
          state_ = State::SOLVE_A;
        }
        return;
      }
    } else {
      pose_[pose_i_].reset();
    }

    if (should_status_(now, 700)) {
      Serial.printf("[POSE] %s  stable=%ums/%u  cos=%.4f  gyro=%.3f<th=%.3f  aRel=%.3f  n=%u\n",
                    pose_name_[pose_i_], (unsigned)stable_ms_, (unsigned)STABLE_NEED_MS,
                    cos_sim, gn, th, arel, (unsigned)pose_[pose_i_].n);
    }
  }

  void rebuild_ned_maps_(){
    acc_map_ned_.idx[0] = acc_map_screen_.idx[1]; acc_map_ned_.sgn[0] = acc_map_screen_.sgn[1]; // N
    acc_map_ned_.idx[1] = acc_map_screen_.idx[0]; acc_map_ned_.sgn[1] = acc_map_screen_.sgn[0]; // E
    acc_map_ned_.idx[2] = acc_map_screen_.idx[2]; acc_map_ned_.sgn[2] = acc_map_screen_.sgn[2]; // D

    gyr_map_ned_.idx[0] = gyr_map_screen_.idx[1]; gyr_map_ned_.sgn[0] = gyr_map_screen_.sgn[1];
    gyr_map_ned_.idx[1] = gyr_map_screen_.idx[0]; gyr_map_ned_.sgn[1] = gyr_map_screen_.sgn[0];
    gyr_map_ned_.idx[2] = gyr_map_screen_.idx[2]; gyr_map_ned_.sgn[2] = gyr_map_screen_.sgn[2];

    mag_map_ned_.idx[0] = mag_map_screen_.idx[1]; mag_map_ned_.sgn[0] = mag_map_screen_.sgn[1];
    mag_map_ned_.idx[1] = mag_map_screen_.idx[0]; mag_map_ned_.sgn[1] = mag_map_screen_.sgn[0];
    mag_map_ned_.idx[2] = mag_map_screen_.idx[2]; mag_map_ned_.sgn[2] = mag_map_screen_.sgn[2];
  }

  void solve_accel_(){
    // Targets in SCREEN frame [E,N,D]
    const Vec3 t0(0,0, 1);
    const Vec3 t1(0,0,-1);
    const Vec3 t2(1,0, 0); // RIGHT EDGE DOWN => +E
    const Vec3 t3(0,1, 0); // TOP EDGE DOWN   => +N

    Vec3 a0 = pose_[0].acc_mean();
    Vec3 a1 = pose_[1].acc_mean();
    Vec3 a2 = pose_[2].acc_mean();
    Vec3 a3 = pose_[3].acc_mean();

    const int perms[6][3] = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
    const int sgns[8][3]  = {
      {+1,+1,+1},{+1,+1,-1},{+1,-1,+1},{+1,-1,-1},
      {-1,+1,+1},{-1,+1,-1},{-1,-1,+1},{-1,-1,-1}
    };

    float best=-1e9f, second=-1e9f;
    AxisMap bestM = make_map_(0,+1,1,+1,2,+1);

    auto score_dir = [&](const Vec3& v, const Vec3& tgt){
      Vec3 u = normalize3(v);
      return dot3(u, tgt);
    };

    for(int pi=0; pi<6; ++pi){
      for(int si=0; si<8; ++si){
        AxisMap m = make_map_(perms[pi][0], sgns[si][0],
                              perms[pi][1], sgns[si][1],
                              perms[pi][2], sgns[si][2]);

        Vec3 m0 = apply_map3(m, a0);
        Vec3 m1 = apply_map3(m, a1);
        Vec3 m2 = apply_map3(m, a2);
        Vec3 m3 = apply_map3(m, a3);

        float sc = 0.0f;
        sc += 2.8f * score_dir(m0,t0);
        sc += 2.3f * score_dir(m1,t1);
        sc += 2.0f * score_dir(m2,t2);
        sc += 2.0f * score_dir(m3,t3);

        if (sc > best) { second = best; best = sc; bestM = m; }
        else if (sc > second) { second = sc; }
      }
    }

    float margin = best - second;
    Serial.println();
    Serial.printf("[ACCEL] solve score best=%.3f second=%.3f margin=%.3f\n", best, second, margin);

    if (!(best > 6.0f && margin > 0.25f)) {
      Serial.println("[ACCEL] FAILED: mapping ambiguous. Type 'r' to restart.");
      state_ = State::DONE;
      return;
    }

    accel_ok_ = true;
    acc_map_screen_ = bestM;

    // detect accel scale (g vs m/s^2)
    float m0 = norm3(apply_map3(acc_map_screen_, a0));
    float m1 = norm3(apply_map3(acc_map_screen_, a1));
    float m2 = norm3(apply_map3(acc_map_screen_, a2));
    float m3 = norm3(apply_map3(acc_map_screen_, a3));
    float m = 0.25f*(m0+m1+m2+m3);

    if (m > 0.35f && m < 2.3f)      acc_scale_mps2_ = kGStd;  // g -> m/s^2
    else if (m > 4.0f && m < 15.0f) acc_scale_mps2_ = 1.0f;   // already m/s^2
    else                           acc_scale_mps2_ = (m>1e-6f)? (kGStd/m) : 1.0f;

    rebuild_ned_maps_();

    Serial.println("[ACCEL] Solved accel mapping.");
    char buf[48];
    map_to_str(acc_map_screen_, buf, sizeof(buf));
    Serial.printf("  ACC_MAP raw->SCREEN [E,N,D] = %s\n", buf);
    map_to_str(acc_map_ned_, buf, sizeof(buf));
    Serial.printf("  ACC_MAP raw->NED    [N,E,D] = %s\n", buf);
    Serial.printf("  ACC_SCALE_MPS2 = %.9g\n", acc_scale_mps2_);

    state_ = State::ROT;
    rot_phase_ = RotPhase::WAIT_SCREENUP;
    rot_phase_t0_ms_ = millis();
    rot_n_ = 0;
    print_rot_prompt_();
  }

  void update_rotation_(){
    if (!accel_ok_) { state_ = State::DONE; return; }

    Vec3 up_ref_raw = normalize3(pose_[0].acc_mean());
    Vec3 au = normalize3(acc_raw_);
    float up_dot = dot3(au, up_ref_raw);
    uint32_t now = millis();

    if (rot_phase_ == RotPhase::WAIT_SCREENUP) {
      if (should_status_(now, 700))
        Serial.printf("[ROT] waiting SCREEN UP flat... up_dot=%.3f (need > %.3f)\n", up_dot, ROT_UP_DOT_TH_READY);
      if (up_dot > ROT_UP_DOT_TH_READY) {
        rot_phase_ = RotPhase::READY_STILL;
        rot_phase_t0_ms_ = now;
        reset_stability_();
      }
      return;
    }

    if (rot_phase_ == RotPhase::READY_STILL) {
      if (up_dot < 0.92f) { rot_phase_ = RotPhase::WAIT_SCREENUP; return; }
      update_stable_(acc_raw_, gyr_raw_);
      uint32_t elapsed = now - rot_phase_t0_ms_;
      if (should_status_(now, 700))
        Serial.printf("[ROT] get ready... %ums\n", (elapsed >= ROT_READY_MS) ? 0u : (unsigned)(ROT_READY_MS - elapsed));

      if (elapsed >= ROT_READY_MS && stable_ms_ >= (ROT_READY_MS - 200)) {
        rot_phase_ = RotPhase::CAPTURE;
        rot_t0_ms_ = now;
        rot_last_store_ms_ = now;
        rot_n_ = 0;
        Serial.println("[ROT] Capture started. Rotate CLOCKWISE now (8s), keep it flat.");
      }
      return;
    }

    // CAPTURE for FULL 8 seconds
    uint32_t elapsed = now - rot_t0_ms_;
    if (elapsed >= ROT_CAPTURE_MS) {
      Serial.printf("[ROT] Done. Stored samples: %d (max %d)\n", rot_n_, ROT_MAX);
      state_ = State::SOLVE_M;
      return;
    }

    if (now - rot_last_store_ms_ >= ROT_STORE_MS) {
      rot_last_store_ms_ += ROT_STORE_MS;
      if (up_dot > ROT_UP_DOT_TH_CAP && rot_n_ < ROT_MAX) {
        rot_gyr_[rot_n_] = gyr_raw_;
        rot_mag_[rot_n_] = mag_raw_;
        rot_haveMag_[rot_n_] = have_mag_;
        rot_dt_[rot_n_] = dt_s_;
        rot_n_++;
      }
      if (verbose_ && should_status_(now, 900)) {
        Serial.printf("[ROT] capturing... stored=%d/%d remaining=%ums up_dot=%.4f\n",
                      rot_n_, ROT_MAX, (unsigned)(ROT_CAPTURE_MS - elapsed), up_dot);
      }
    }
  }

  void solve_mag_gyro_(){
    if (rot_n_ < 80) {
      Serial.println("[ROT] Not enough samples captured. Type 'r' to restart.");
      state_ = State::DONE;
      return;
    }

    // Solve gyro mapping: rotation should be mostly about SCREEN D-axis (z)
    const int perms[6][3] = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
    const int sgns[8][3]  = {
      {+1,+1,+1},{+1,+1,-1},{+1,-1,+1},{+1,-1,-1},
      {-1,+1,+1},{-1,+1,-1},{-1,-1,+1},{-1,-1,-1}
    };

    AxisMap bestG = {{0,1,2},{+1,+1,+1}};
    float bestScore = -1e9f;

    for(int pi=0; pi<6; ++pi){
      for(int si=0; si<8; ++si){
        AxisMap m = make_map_(perms[pi][0], sgns[si][0],
                              perms[pi][1], sgns[si][1],
                              perms[pi][2], sgns[si][2]);
        double sxx=0, syy=0, szz=0;
        for(int i=0;i<rot_n_;++i){
          Vec3 g = apply_map3(m, rot_gyr_[i]);
          sxx += (double)g.x*(double)g.x;
          syy += (double)g.y*(double)g.y;
          szz += (double)g.z*(double)g.z;
        }
        float rx = sqrtf((float)(sxx/rot_n_));
        float ry = sqrtf((float)(syy/rot_n_));
        float rz = sqrtf((float)(szz/rot_n_));
        float sc = rz - 0.35f*(rx+ry);
        if (sc > bestScore) { bestScore = sc; bestG = m; }
      }
    }

    gyr_map_screen_ = bestG;
    gyro_ok_ = true;

    double gyro_int_raw = 0.0;
    double gyro_sq = 0.0;
    for(int i=0;i<rot_n_;++i){
      Vec3 gS = apply_map3(gyr_map_screen_, rot_gyr_[i]);
      float dt = rot_dt_[i];
      gyro_int_raw += (double)gS.z * (double)dt;
      gyro_sq += (double)gS.z*(double)gS.z;
    }
    float gyro_rms = sqrtf((float)(gyro_sq / (double)rot_n_));

    // gyro scale: decide deg/s vs rad/s
    {
      const float DEG2RAD = kPi / 180.0f;
      float cand0 = 1.0f;
      float cand1 = DEG2RAD;
      auto cost = [&](float s)->float{
        float ang = (float)fabs(gyro_int_raw) * s;
        float c=0;
        if (ang < 2.0f) c += (2.0f-ang)*(2.0f-ang);
        if (ang > 10.0f) c += (ang-10.0f)*(ang-10.0f);
        c += 0.04f*(ang-6.0f)*(ang-6.0f);
        return c;
      };
      gyro_scale_radps_ = (cost(cand1) < cost(cand0)) ? cand1 : cand0;
    }

    // mag solve: correlation between gyro_z and heading rate
    AxisMap bestM = {{0,1,2},{+1,+1,+1}};
    float bestCorrAbs = 0.0f;
    float bestPsiUnwrap = 0.0f;
    float bestAbsSum = 0.0f;
    float bestMagNormMean = 0.0f;

    for(int pi=0; pi<6; ++pi){
      for(int si=0; si<8; ++si){
        AxisMap m = make_map_(perms[pi][0], sgns[si][0],
                              perms[pi][1], sgns[si][1],
                              perms[pi][2], sgns[si][2]);

        bool psi_init=false;
        float psi_prev=0.0f;
        float psi_unwrap=0.0f;
        float absSum=0.0f;

        double sx=0, sy=0, sxx=0, syy=0, sxy=0;
        int n=0;

        double magNormSum=0.0;
        int magNormN=0;

        for(int i=0;i<rot_n_;++i){
          if (!rot_haveMag_[i]) continue;
          float dt = rot_dt_[i];
          if (!(dt > 1e-6f && dt < 0.2f)) continue;

          Vec3 gS = apply_map3(gyr_map_screen_, rot_gyr_[i]);
          Vec3 mS = apply_map3(m, rot_mag_[i]);

          float mn = norm3(mS);
          if (mn > 1e-6f) { magNormSum += mn; magNormN++; }

          float psi = atan2f(mS.y, mS.x);
          if (!psi_init){
            psi_prev = psi;
            psi_unwrap = psi;
            psi_init = true;
            continue;
          }

          float dpsi = wrap_pi(psi - psi_prev);
          psi_prev = psi;
          psi_unwrap += dpsi;
          absSum += fabsf(dpsi);

          float y = dpsi / dt;
          float x = gS.z;

          sx += x; sy += y;
          sxx += (double)x*(double)x;
          syy += (double)y*(double)y;
          sxy += (double)x*(double)y;
          n++;
        }

        if (n < 30 || magNormN < 30) continue;

        double denomx = (n*sxx - sx*sx);
        double denomy = (n*syy - sy*sy);
        if (denomx <= 1e-12 || denomy <= 1e-12) continue;

        double corr = (n*sxy - sx*sy) / sqrt(denomx*denomy);
        float cabs = (float)fabs(corr);
        float magNormMean = (float)(magNormSum / (double)magNormN);

        float score = cabs + 0.06f * (absSum / (2.0f*kPi));
        float bestScore2 = bestCorrAbs + 0.06f * (bestAbsSum / (2.0f*kPi));
        if (score > bestScore2) {
          bestM = m;
          bestCorrAbs = cabs;
          bestPsiUnwrap = psi_unwrap;
          bestAbsSum = absSum;
          bestMagNormMean = magNormMean;
        }
      }
    }

    mag_ok_ = (bestCorrAbs >= MAG_CORR_MIN && bestAbsSum >= MAG_ROTABS_MIN);
    if (mag_ok_) mag_map_screen_ = bestM;

    // mag scale: choose to land 15..100 uT-ish
    auto choose_mag_scale = [&](float magNormRaw)->float{
      const float candidates[] = {1.0f,0.1f,10.0f,0.01f,100.0f,0.001f};
      float bestS = 1.0f, bestCost = 1e9f;
      for(float s: candidates){
        float uT = magNormRaw * s;
        float c=0;
        if (uT < 15.0f) c += (15.0f-uT)*(15.0f-uT);
        if (uT > 100.0f) c += (uT-100.0f)*(uT-100.0f);
        c += 0.015f*(uT-50.0f)*(uT-50.0f);
        if (c < bestCost){ bestCost=c; bestS=s; }
      }
      return bestS;
    };
    mag_scale_ut_ = mag_ok_ ? choose_mag_scale(bestMagNormMean) : 1.0f;

    rebuild_ned_maps_();

    // Print report
    Serial.println();
    Serial.println("########################### RESULTS ###########################");
    Serial.printf("Mag availability: %s\n", have_mag_ ? "YES" : "NO");

    Serial.println("\nScales (multiply RAW by these):");
    Serial.printf("ACC_SCALE_MPS2   = %.9g\n", acc_scale_mps2_);
    Serial.printf("GYRO_SCALE_RADPS = %.9g\n", gyro_scale_radps_);
    Serial.printf("MAG_SCALE_UT     = %.9g\n", mag_scale_ut_);

    char s1[48], s2[48];
    Serial.println("\nAxis maps (RAW -> NED, screen-up reference):");
    map_to_str(acc_map_screen_, s1, sizeof(s1));
    Serial.printf("ACC_MAP raw->SCREEN [E,N,D] = %s\n", s1);
    map_to_str(acc_map_ned_, s2, sizeof(s2));
    Serial.printf("ACC_MAP raw->NED(screen-up) [N,E,D] = %s\n", s2);

    map_to_str(gyr_map_screen_, s1, sizeof(s1));
    Serial.printf("GYRO_MAP raw->SCREEN [E,N,D] = %s\n", s1);
    map_to_str(gyr_map_ned_, s2, sizeof(s2));
    Serial.printf("GYRO_MAP raw->NED(screen-up) [N,E,D] = %s\n", s2);

    if (mag_ok_) {
      map_to_str(mag_map_screen_, s1, sizeof(s1));
      Serial.printf("MAG_MAP  raw->SCREEN [E,N,D] = %s\n", s1);
      map_to_str(mag_map_ned_, s2, sizeof(s2));
      Serial.printf("MAG_MAP  raw->NED(screen-up) [N,E,D] = %s\n", s2);
    } else {
      Serial.println("MAG: **FAILED** (not enough correlation/rotation to solve reliably)");
    }

    Serial.println("\nDiagnostics:");
    Serial.printf("  mag corr |corr| ~ %.3f  (>= %.2f recommended)\n", bestCorrAbs, MAG_CORR_MIN);
    Serial.printf("  abs sum dpsi ~ %.2f rad (>= %.2f rad recommended)\n", bestAbsSum, MAG_ROTABS_MIN);
    Serial.printf("  heading unwrap ~ %.2f rad (%.1f deg)\n", bestPsiUnwrap, bestPsiUnwrap * 180.0f / kPi);
    Serial.printf("  mag norm mean raw=%.3f => scaled=%.2f uT\n", bestMagNormMean, bestMagNormMean * mag_scale_ut_);
    Serial.printf("  gyro integral raw (screen yaw) = %.6f (raw_units*s)\n", (float)gyro_int_raw);
    Serial.printf("  gyro yaw rms raw=%.3f\n", gyro_rms);

    Serial.println("\nType 'r' to restart. (You can re-run rotation until mag passes.)");
    state_ = State::DONE;
  }
};

// ---------------------------- sketch glue ----------------------------
static IMUWizard g_wiz;

void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);
  delay(250);
  g_wiz.begin();
}

void loop() {
  g_wiz.update();
  delay(1);
}
