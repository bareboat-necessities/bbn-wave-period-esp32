/*
  Minimal Q-MEKF yaw/pitch/roll demo, matching the old working code path

  for atomS3R from m5stack
  
*/

#include <M5Unified.h>
#include <Arduino.h>

#include <stdint.h>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
#define EIGEN_STACK_ALLOCATION_LIMIT 0
#endif
#include <ArduinoEigenDense.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

constexpr float g_std = 9.80665f;  // m/s^2

#include "M5_Calibr.h"
#include "KalmanQMEKF.h"
#include "Quaternion.h"  

// Global flags / state
unsigned long now = 0UL, last_refresh = 0UL, start_time = 0UL, last_update = 0UL;
unsigned long got_samples = 0;

const char* imu_name = "unknown";
bool produce_serial_data = true;
float t = 0.0f;

using Vector3f = Eigen::Matrix<float,3,1>;

// Same noise params as old working code:
static Vector3f sigma_a = {0.03f * g_std, 0.03f * g_std, 0.03f * g_std};
static Vector3f sigma_g = {0.12f * M_PI / 180.0f,
                           0.12f * M_PI / 180.0f,
                           0.12f * M_PI / 180.0f};
static Vector3f sigma_m = {9.5f, 9.5f, 9.5f};
float Pq0 = 0.5f;
float Pb0 = 1e-2f;
float b0  = 1e-9f;

QuaternionMEKF<float,true> mekf(sigma_a, sigma_g, sigma_m, Pq0, Pb0, b0);

bool kalm_w_first = true;

// Main IMU processing
void read_and_processIMU_data() {
  auto data = M5.Imu.getImuData();

  float tempC = NAN;
  M5.Imu.getTemp(&tempC);

  drawCalibrGraph(rect_graph_area, data);
  
  now = micros();
  got_samples++;

  m5::imu_3d_t accel = data.accel;
  m5::imu_3d_t gyro  = data.gyro;
  m5::imu_3d_t mag   = data.mag;

  float delta_t = (now - last_update) / 1000000.0f;  // sec
  // clamp dt
  if (delta_t < 0.001f) delta_t = 0.001f;
  if (delta_t > 0.1f)   delta_t = 0.1f;
  last_update = now;

  // Map IMU to BODY NED frame
  Eigen::Vector3f acc_meas_body(
    accel.y * g_std,       // X_body = sensor Y
    accel.x * g_std,       // Y_body = sensor X
    -accel.z * g_std       // Z_body = -sensor Z
  );
  Eigen::Vector3f gyr_meas_body(
    gyro.y * DEG_TO_RAD,
    gyro.x * DEG_TO_RAD,
    -gyro.z * DEG_TO_RAD
  );
  // Mag mapping if you later want it:
  Eigen::Vector3f mag_body(
    mag.y / 10.0f,
    mag.x / 10.0f,
    -mag.z / 10.0f
  );

  if (kalm_w_first) {
    //mekf.initialize_from_acc(acc_meas_body);
    mekf.initialize_from_acc_mag(acc_meas_body, mag_body);
    kalm_w_first = false;
  }

  mekf.time_update(gyr_meas_body, delta_t);
  mekf.measurement_update_acc_only(acc_meas_body);
  mekf.measurement_update_mag_only(mag_body); 

  // Get quaternion from MEKF (Vector4 [x,y,z,w])
  auto qvec = mekf.quaternion();

  // Convert to your Quaternion.h type (w,x,y,z), as before:
  Quaternion q;
  Quaternion_set(qvec.w(), qvec.x(), qvec.y(), qvec.z(), &q);

  // Get ZYX Euler (roll, pitch, yaw) in radians, same as old code:
  float euler[3];
  Quaternion_toEulerZYX(&q, euler);
  float roll_deg  = euler[0] * RAD_TO_DEG;
  float pitch_deg = euler[1] * RAD_TO_DEG;
  float yaw_deg   = euler[2] * RAD_TO_DEG;

  // NMEA / Serial output
  const int serial_report_period_micros = 125000;
  if (now - last_refresh >= (produce_serial_data ? serial_report_period_micros : 1000000)) {
    if (produce_serial_data) {
      Serial.printf(",delta_t:%.6f", delta_t);
      //Serial.printf(",accel.x:%.6f", accel.x);
      //Serial.printf(",accel.y:%.6f", accel.y);
      //Serial.printf(",accel.z:%.6f", accel.z);
      Serial.printf(",roll_deg:%5.2f",  roll_deg);
      Serial.printf(",pitch_deg:%5.2f", pitch_deg);
      Serial.printf(",yaw_deg:%5.2f",   yaw_deg);
      Serial.println();
    }
    last_refresh = now;
    got_samples = 0;
  }
  t = (now - start_time) / 1000000.0f;  // time since start sec
}

// Main loop
void repeatMe() {
  bool pressed = M5.BtnA.wasPressed();
  if (pressed) {
    startCalibration();
  } else {
    auto imu_update = M5.Imu.update();
    if (imu_update) {
      read_and_processIMU_data();
    }
  }
  makeCalibrStep();
}

void setup(void) {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);

  auto imu_type = M5.Imu.getType();
  switch (imu_type) {
    case m5::imu_none:        imu_name = "not found";   break;
    case m5::imu_sh200q:      imu_name = "sh200q";      break;
    case m5::imu_mpu6050:     imu_name = "mpu6050";     break;
    case m5::imu_mpu6886:     imu_name = "mpu6886";     break;
    case m5::imu_mpu9250:     imu_name = "mpu9250";     break;
    case m5::imu_bmi270:      imu_name = "bmi270";      break;
    default:                  imu_name = "unknown";     break;
  };
  disp.fillRect(0, 0, rect_text_area.w, rect_text_area.h, TFT_BLACK);

  if (imu_type == m5::imu_none) {
    for (;;) {
      delay(1);
    }
  }

  initCalibrDisplay();

  // Read calibration values from NVS.
  if (!M5.Imu.loadOffsetFromNVS()) {
    //startCalibration();
  }
  
  start_time  = micros();
  last_update = start_time;
}

void loop(void) {
  unsigned long start = micros();
  M5.update();
  repeatMe();
  long duration = micros() - start + 1;
  long delay_micros = 10000 - duration;  // ~100 Hz
  if (delay_micros > 0) {
    delayMicroseconds(delay_micros);
  }
}
