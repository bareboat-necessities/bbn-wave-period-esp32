/*
  AtomS3R Tilt-Compensated Compass + IMU Calibration Wizard

  - Uses your AtomS3R_ImuCal.h (blob + runtime apply + axis mapping + clearM5UnifiedImuCalibration)
  - Uses your AtomS3R_ImuCalWizard.h (UI + wizard capture/fit/save + Input tap logic)
  - Uses your QuaternionMEKF (q-mekf) implementation (KalmanQMEKF.h) for fused roll/pitch/yaw
  - Runs accel+gyro at ~240 Hz, mag is slower and gated by time+delta (stale-repeat rejection)
  - Shows Heading (deg, 0..360), Roll/Pitch (deg) on screen and prints to Serial

  Taps:
    - 1 tap  : run wizard (save new blob)
    - 3 taps : erase blob (and clear M5Unified calibration)

  Notes:
    - We feed calibrated accel (m/s^2) and gyro (rad/s) to MEKF.
    - We feed *unit* magnetometer direction (calibrated, normalized) to MEKF.
    - If mag isn’t “fresh”, we skip mag update (keeps yaw stable, avoids stale repeats).
*/

#include <Arduino.h>
#include <M5Unified.h>
#include <new>

#include "AtomS3R_ImuCal.h"
#include "AtomS3R_ImuCalWizard.h"

// Your q-mekf header that defines QuaternionMEKF
#include "KalmanQMEKF.h"

using namespace atoms3r_ical;

using Vector3f = Eigen::Matrix<float, 3, 1>;

// ---------- Sampling / gating tuning ----------
static constexpr float    LOOP_HZ                = 240.0f;
static constexpr uint32_t LOOP_PERIOD_US         = (uint32_t)(1000000.0f / LOOP_HZ);

// Mag ODR is slower; also many builds repeat stale values.
// Gate by spacing + delta (wizard-style).
static constexpr uint32_t MAG_SAMPLE_SPACING_MS  = 20;     // ~<=50 Hz mag updates
static constexpr float    MAG_MIN_DELTA_uT       = 0.05f;  // reject repeats (0.02..0.10 typical)

// Display / serial rates
static constexpr uint32_t UI_REFRESH_MS          = 100;    // 10 Hz UI update
static constexpr uint32_t SERIAL_REFRESH_MS      = 200;    // 5 Hz serial update

// ---------- Helpers ----------
static inline float clampf_(float x, float lo, float hi) { return x < lo ? lo : (x > hi ? hi : x); }

static inline float wrap360_(float deg) {
  while (deg < 0.0f)   deg += 360.0f;
  while (deg >= 360.0f) deg -= 360.0f;
  return deg;
}

// ---------- App ----------
class CompassApp {
public:
  CompassApp() : wizard_(ui_, store_) {}

  void begin() {
    Serial.begin(115200);
    delay(150);
    Serial.println();
    Serial.println("[BOOT] AtomS3R Compass + Cal Wizard");

    auto cfg = M5.config();
    M5.begin(cfg);

    // Critical: clear M5Unified’s own cal/offsets so it can’t stack with ours.
    clearM5UnifiedImuCalibration();

    ui_.begin();

    if (!M5.Imu.isEnabled()) {
      Serial.println("[BOOT] IMU not found / not enabled");
      ui_.fail("IMU", "Not found");
      while (true) delay(100);
    }

    reloadBlobAndRuntime_();

    // If missing, immediately run wizard once (matches your requested flow)
    if (!have_blob_) {
      Serial.println("[BOOT] No saved calibration. Starting wizard...");
      ImuCalBlobV1 saved{};
      if (wizard_.runAndSave(saved)) {
        Serial.println("[BOOT] Wizard saved calibration. Loaded:");
        printBlobSummary(Serial, saved);
        printBlobDetail(Serial, saved);
        blob_ = saved;
        have_blob_ = true;
        runtime_.rebuildFromBlob(blob_);
      } else {
        Serial.println("[BOOT] Wizard did not save calibration. Running with raw values.");
      }
    } else {
      Serial.println("[BOOT] Found saved calibration:");
      printBlobSummary(Serial, blob_);
      printBlobDetail(Serial, blob_);
    }

    resetMEKF_();

    // UI
    ui_.setReadRotation();
    ui_.title("COMPASS");
    ui_.line(have_blob_ ? "BLOB: YES" : "BLOB: NO");
    ui_.line("Tap: calibrate");
    ui_.line("Tap x3: erase");
    ui_.line("");
    ui_.line("Move slowly in");
    ui_.line("figure-8 for");
    ui_.line("best heading");

    start_us_ = micros();
    next_tick_us_ = micros();
    last_update_us_ = micros();
  }

  void tick() {
    // Pace loop to ~240 Hz (avoid long blocking; wizard UI will override timing anyway)
    const uint32_t now_us = micros();
    int32_t wait_us = (int32_t)(next_tick_us_ - now_us);
    if (wait_us > 0) {
      // small sleep; do not oversleep too hard
      if (wait_us > 200) delayMicroseconds(200);
      else delayMicroseconds((uint32_t)wait_us);
    }
    next_tick_us_ += LOOP_PERIOD_US;

    M5.update();
    Input::update();

    // Tap handling (same behavior as your cal app)
    if (Input::tapPressed()) {
      tap_count_++;
      tap_deadline_ms_ = millis() + ImuCalWizardCfg::TAP_WINDOW_MS;
      drawHomePending_();
      Serial.printf("[TAP] count=%d\n", tap_count_);
    }

    if (tap_count_ > 0 && (int32_t)(millis() - tap_deadline_ms_) > 0) {
      if (tap_count_ >= 3) handleErase_();
      else                 handleRunWizard_();
      tap_count_ = 0;
      tap_deadline_ms_ = 0;
      // After wizard/erase, re-show top lines; heading lines are updated in updateUI_()
      drawHomeStatic_();
    }

    // Read IMU and update filter
    ImuSample s;
    if (readImuMapped(M5.Imu, s)) {
      updateFilter_(s);
      updateUI_();
      streamSerial_();
    }
  }

private:
  // --- Calibration plumbing ---
  void reloadBlobAndRuntime_() {
    have_blob_ = store_.load(blob_);
    if (!have_blob_) {
      memset(&blob_, 0, sizeof(blob_));
    }
    runtime_.rebuildFromBlob(blob_);
  }

  void handleErase_() {
    Serial.println("[HOME] triple tap => ERASE");

    if (!ui_.eraseConfirm()) {
      Serial.println("[HOME] erase cancelled");
      return;
    }

    store_.erase();
    clearM5UnifiedImuCalibration();

    reloadBlobAndRuntime_();
    resetMEKF_();

    Serial.println("[HOME] erased blob + cleared M5Unified cal");
  }

  void handleRunWizard_() {
    Serial.println("[HOME] single tap => RUN WIZARD");

    ImuCalBlobV1 saved{};
    bool ok = wizard_.runAndSave(saved);
    if (!ok) {
      ui_.notSavedNotice();
      return;
    }

    Serial.println("[HOME] new calibration saved:");
    printBlobSummary(Serial, saved);
    printBlobDetail(Serial, saved);

    blob_ = saved;
    have_blob_ = true;
    runtime_.rebuildFromBlob(blob_);

    resetMEKF_();
  }

  // --- MEKF ---
  void resetMEKF_() {
    // Noise tuning for 240 Hz acc+gyro updates:
    // - sigma_a: accel measurement noise (m/s^2). Larger = less trusting accel under motion.
    // - sigma_g: gyro noise used in process Q.
    // - sigma_m: mag measurement noise for *unit* mag vector updates (dimensionless).
    //
    // These are conservative “works on a boat / handheld” defaults.
    const float g = ImuCalCfg::g_std;

    Vector3f sigma_a; sigma_a << 0.06f * g, 0.06f * g, 0.06f * g;   // ~0.59 m/s^2
    Vector3f sigma_g; sigma_g << 0.0030f, 0.0030f, 0.0030f;         // rad/s
    Vector3f sigma_m; sigma_m << 0.020f, 0.020f, 0.020f;            // unit-vector noise

    const float Pq0 = 0.5f;
    const float Pb0 = 1e-2f;
    const float b0  = 1e-9f;

    if (mekf_) {
      mekf_->~QuaternionMEKF<float, true>();
      mekf_ = nullptr;
    }
    mekf_ = new (mekf_storage_) QuaternionMEKF<float, true>(sigma_a, sigma_g, sigma_m, Pq0, Pb0, b0);

    mekf_inited_ = false;

    last_mag_uT_.setZero();
    last_mag_ms_ = 0;

    Serial.println("[MEKF] reset");
  }

  void updateFilter_(const ImuSample& s) {
    // Calibrate signals (or pass through if missing)
    a_cal_ = runtime_.applyAccel(s.a, s.tempC);
    w_cal_ = runtime_.applyGyro (s.w, s.tempC);
    m_cal_ = runtime_.applyMag  (s.m);

    // dt from micros; clamp sane
    const uint32_t now_us = micros();
    float dt = (now_us - last_update_us_) * 1e-6f;
    last_update_us_ = now_us;

    dt = clampf_(dt, 0.0010f, 0.0200f);

    // Mag validity (magnitude)
    const float mn = m_cal_.norm();
    mag_ok_ = (mn > 5.0f && mn < 200.0f); // very broad in uT
    mag_norm_uT_ = mn;

    // Normalize mag for MEKF (unit direction)
    Vector3f m_u = Vector3f::Zero();
    if (mag_ok_ && mn > 1e-6f) m_u = m_cal_ / mn;

    // Stale-repeat rejection + ODR gating
    const uint32_t now_ms = millis();
    bool mag_fresh = false;
    if (mag_ok_) {
      const uint32_t dtm = now_ms - last_mag_ms_;
      const float dm = (m_cal_ - last_mag_uT_).norm();
      if (dtm >= MAG_SAMPLE_SPACING_MS && dm >= MAG_MIN_DELTA_uT) {
        mag_fresh = true;
        last_mag_ms_ = now_ms;
        last_mag_uT_ = m_cal_;
      }
    }
    mag_fresh_ = mag_fresh;

    // Initialize once: prefer acc+mag if mag looks OK
    if (!mekf_inited_) {
      if (mag_ok_) mekf_->initialize_from_acc_mag(a_cal_, m_u);
      else         mekf_->initialize_from_acc(a_cal_);
      mekf_inited_ = true;
    }

    // Core filter updates at ~240Hz
    mekf_->time_update(w_cal_, dt);
    mekf_->measurement_update_acc_only(a_cal_);

    // Mag update at mag ODR (gated)
    if (mag_ok_ && mag_fresh_) {
      mekf_->measurement_update_mag_only(m_u);
    }

    // Extract Euler from BODY->WORLD quaternion (q_bw)
    const auto qvec = mekf_->quaternion(); // [x,y,z,w]
    Eigen::Quaternionf q_bw(qvec(3), qvec(0), qvec(1), qvec(2));
    Eigen::Matrix3f R = q_bw.toRotationMatrix();

    // ZYX extraction (yaw, pitch, roll)
    float yaw   = atan2f(R(1, 0), R(0, 0));
    float pitch = -asinf(clampf_(R(2, 0), -1.0f, 1.0f));
    float roll  = atan2f(R(2, 1), R(2, 2));

    roll_deg_  = roll  * RAD_TO_DEG;
    pitch_deg_ = pitch * RAD_TO_DEG;
    yaw_deg_   = yaw   * RAD_TO_DEG;

    heading_deg_ = wrap360_(yaw_deg_);
  }

  // --- UI ---
  void drawHomeStatic_() {
    ui_.setReadRotation();
    ui_.title("COMPASS");
    M5.Display.printf("BLOB: %s\n", have_blob_ ? "YES" : "NO");
    M5.Display.printf("A:%d G:%d M:%d\n",
                      (int)runtime_.acc.ok, (int)runtime_.gyr.ok, (int)runtime_.mag.ok);
    ui_.line("Tap: calibrate");
    ui_.line("Tap x3: erase");
    ui_.line("");
  }

  void drawHomePending_() {
    ui_.setReadRotation();
    ui_.title("COMPASS");
    M5.Display.printf("Tap count: %d\n", tap_count_);
    ui_.line("");
    ui_.line("Wait...");
    ui_.line("1 tap=CAL");
    ui_.line("3 taps=ERASE");

    int32_t remain = (int32_t)(tap_deadline_ms_ - millis());
    remain = remain < 0 ? 0 : remain;
    float t01 = 1.0f - (float)remain / (float)ImuCalWizardCfg::TAP_WINDOW_MS;
    ui_.bar01(t01);
  }

  void updateUI_() {
    const uint32_t now_ms = millis();
    if (now_ms - last_ui_ms_ < UI_REFRESH_MS) return;
    last_ui_ms_ = now_ms;

    ui_.setReadRotation();
    ui_.title("COMPASS");

    M5.Display.printf("HDG: %6.1f deg\n", (double)heading_deg_);
    M5.Display.printf("ROL: %6.1f deg\n", (double)roll_deg_);
    M5.Display.printf("PIT: %6.1f deg\n", (double)pitch_deg_);

    M5.Display.printf("MAG: %s  %s\n",
                      mag_ok_ ? "OK " : "BAD",
                      mag_fresh_ ? "NEW" : "OLD");

    M5.Display.printf("|m|: %6.1f uT\n", (double)mag_norm_uT_);
    M5.Display.printf("|aR|:%5.2f |aC|:%5.2f\n",
                      (double)s_last_a_norm_raw_, (double)a_cal_.norm());

    ui_.line("");
    M5.Display.printf("A:%d G:%d M:%d  B:%s\n",
                      (int)runtime_.acc.ok, (int)runtime_.gyr.ok, (int)runtime_.mag.ok,
                      have_blob_ ? "YES" : "NO");
  }

  // --- Serial ---
  void streamSerial_() {
    const uint32_t now_ms = millis();
    if (now_ms - last_serial_ms_ < SERIAL_REFRESH_MS) return;
    last_serial_ms_ = now_ms;

    const float t = (micros() - start_us_) * 1e-6f;

    Serial.printf("t=%.2f ", (double)t);
    Serial.printf("HDG:%6.1f ", (double)heading_deg_);
    Serial.printf("ROLL:%6.1f PITCH:%6.1f ", (double)roll_deg_, (double)pitch_deg_);
    Serial.printf("mag:%s/%s |m|=%.1f ",
                  mag_ok_ ? "OK" : "BAD",
                  mag_fresh_ ? "NEW" : "OLD",
                  (double)mag_norm_uT_);
    Serial.printf("|a_raw|=%.4f |a_cal|=%.4f ",
                  (double)s_last_a_norm_raw_, (double)a_cal_.norm());
    Serial.printf("wC:%+.4f,%+.4f,%+.4f ",
                  (double)w_cal_.x(), (double)w_cal_.y(), (double)w_cal_.z());
    Serial.println();
  }

private:
  // Plumbing
  M5Ui ui_{};
  ImuCalStoreNvs store_{};
  ImuCalWizard wizard_;

  bool have_blob_ = false;
  ImuCalBlobV1 blob_{};
  RuntimeCals runtime_{};

  // Tap state
  int tap_count_ = 0;
  uint32_t tap_deadline_ms_ = 0;

  // Timing
  uint32_t start_us_ = 0;
  uint32_t next_tick_us_ = 0;
  uint32_t last_update_us_ = 0;
  uint32_t last_ui_ms_ = 0;
  uint32_t last_serial_ms_ = 0;

  // MEKF (placement-new because it has const members; assignment is not viable)
  alignas(QuaternionMEKF<float, true>) uint8_t mekf_storage_[sizeof(QuaternionMEKF<float, true>)];
  QuaternionMEKF<float, true>* mekf_ = nullptr;
  bool mekf_inited_ = false;

  // Latest calibrated values
  Vector3f a_cal_ = Vector3f::Zero();
  Vector3f w_cal_ = Vector3f::Zero();
  Vector3f m_cal_ = Vector3f::Zero();
  float s_last_a_norm_raw_ = 0.0f;

  // Attitude / heading
  float roll_deg_ = 0.0f;
  float pitch_deg_ = 0.0f;
  float yaw_deg_ = 0.0f;
  float heading_deg_ = 0.0f;

  // Mag gating
  bool mag_ok_ = false;
  bool mag_fresh_ = false;
  float mag_norm_uT_ = 0.0f;
  Vector3f last_mag_uT_ = Vector3f::Zero();
  uint32_t last_mag_ms_ = 0;

  // Last raw accel norm for UI
  void cacheRawNorm_(const ImuSample& s) { s_last_a_norm_raw_ = s.a.norm(); }

  // Override updateFilter_ to also cache raw norm
  void updateFilter_(ImuSample const& s_in, int /*dummy*/) {}

  void updateFilter_(const ImuSample& s_in) {
    cacheRawNorm_(s_in);
    // (rest is above) — to avoid duplicating, keep actual implementation here:
    const ImuSample& s = s_in;

    a_cal_ = runtime_.applyAccel(s.a, s.tempC);
    w_cal_ = runtime_.applyGyro (s.w, s.tempC);
    m_cal_ = runtime_.applyMag  (s.m);

    const uint32_t now_us = micros();
    float dt = (now_us - last_update_us_) * 1e-6f;
    last_update_us_ = now_us;
    dt = clampf_(dt, 0.0010f, 0.0200f);

    const float mn = m_cal_.norm();
    mag_ok_ = (mn > 5.0f && mn < 200.0f);
    mag_norm_uT_ = mn;

    Vector3f m_u = Vector3f::Zero();
    if (mag_ok_ && mn > 1e-6f) m_u = m_cal_ / mn;

    const uint32_t now_ms = millis();
    bool mag_fresh = false;
    if (mag_ok_) {
      const uint32_t dtm = now_ms - last_mag_ms_;
      const float dm = (m_cal_ - last_mag_uT_).norm();
      if (dtm >= MAG_SAMPLE_SPACING_MS && dm >= MAG_MIN_DELTA_uT) {
        mag_fresh = true;
        last_mag_ms_ = now_ms;
        last_mag_uT_ = m_cal_;
      }
    }
    mag_fresh_ = mag_fresh;

    if (!mekf_inited_) {
      if (mag_ok_) mekf_->initialize_from_acc_mag(a_cal_, m_u);
      else         mekf_->initialize_from_acc(a_cal_);
      mekf_inited_ = true;
    }

    mekf_->time_update(w_cal_, dt);
    mekf_->measurement_update_acc_only(a_cal_);

    if (mag_ok_ && mag_fresh_) {
      mekf_->measurement_update_mag_only(m_u);
    }

    const auto qvec = mekf_->quaternion(); // [x,y,z,w]
    Eigen::Quaternionf q_bw(qvec(3), qvec(0), qvec(1), qvec(2));
    Eigen::Matrix3f R = q_bw.toRotationMatrix();

    float yaw   = atan2f(R(1, 0), R(0, 0));
    float pitch = -asinf(clampf_(R(2, 0), -1.0f, 1.0f));
    float roll  = atan2f(R(2, 1), R(2, 2));

    roll_deg_  = roll  * RAD_TO_DEG;
    pitch_deg_ = pitch * RAD_TO_DEG;
    yaw_deg_   = yaw   * RAD_TO_DEG;

    heading_deg_ = wrap360_(yaw_deg_);
  }
};

static CompassApp g_app;

void setup() {
  g_app.begin();
}

void loop() {
  g_app.tick();
}
