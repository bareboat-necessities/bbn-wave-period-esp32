\documentclass[12pt,letterpaper]{article}
\usepackage{amsmath,amssymb,amsthm,fullpage}
\usepackage{hyperref}
\usepackage{cite}

\title{Comprehensive Analysis of the Monotonic Wedge Algorithm for Sliding Window Extrema}
\date{}

\begin{document}
\maketitle

\begin{abstract}
Sliding-window extrema are critical in real-time financial analysis, sensor networks, and streaming algorithms. Computing the minimum and maximum over a sliding window of length \(W\) in a data stream of length \(N\) is a fundamental operation in signal processing and time-series analysis. The monotonic wedge algorithm maintains two deques (one for minima, one for maxima) in amortized \(O(1)\) time per update, with worst-case \(O(\log W)\) via a hybrid search strategy. This paper presents a comprehensive analysis of its computational and memory-usage complexity, including detailed memory-utilization estimates, and compares it with alternative data structures.
\end{abstract}

\section{Problem Statement}
Given a sequence \(\{x_k\}_{k=1}^N\) and a fixed window size \(W\), define
\[
m_k = \min_{i=k-W+1}^k x_i,
\quad
M_k = \max_{i=k-W+1}^k x_i,
\]
for \(k\ge W\). The goal is to update \(m_k\) and \(M_k\) online in time sublinear in \(W\).

\section{Monotonic Wedge Algorithm}
Maintain two deques:
\[
\mathcal{D}_{\min},\quad \mathcal{D}_{\max},
\]
where each stores pairs \((x_j,j)\) in index-order but with monotonic values:
\[
\mathcal{D}_{\min}: x_{j_1}\le x_{j_2}\le\cdots,
\quad
\mathcal{D}_{\max}: x_{j_1}\ge x_{j_2}\ge\cdots.
\]
At each step \(k\):
\begin{enumerate}
  \item \emph{Prune back:} while the back of \(\mathcal{D}_{\min}\) has value \(>x_k\), call \texttt{pop\_back()}; likewise on \(\mathcal{D}_{\max}\) when its back \(<x_k\).
  \item \emph{Push:} append \((x_k,k)\) via \texttt{push\_back()} to both deques.
  \item \emph{Prune front:} remove front entries whose index \(\le k-W\) via \texttt{pop\_front()}.
  \item \emph{Report:}  
    \[
      m_k = \mathcal{D}_{\min}\!\texttt{.front()}\!.x,
      \quad
      M_k = \mathcal{D}_{\max}\!\texttt{.front()}\!.x.
    \]
\end{enumerate}

\section{Time Complexity}
\subsection{Amortized \(O(1)\) Complexity}
\begin{theorem}
Over \(N\) updates, the total number of deque operations (pushes and pops) is \(O(N)\).
\end{theorem}
\begin{proof}
Each element is pushed exactly once and can be popped (from back or front) at most once. Thus the total operations \(\le4N\), yielding \(O(1)\) amortized time per update.
\end{proof}

\subsection{Worst-case \(O(\log W)\) Comparisons}
When pruning the back, a hybrid linear/binary-search step bounds comparisons per update to \(O(\log W)\)~\cite{Lemire2006}.

\section{Memory Utilization}
\subsection{Per-Element Storage}
Each deque element stores:
\begin{itemize}
  \item A value \(x_j\) (e.g.\ 32-bit float or 64-bit double): \(\beta\) bytes.
  \item An index \(j\) (e.g.\ 32-bit integer): \(\gamma\) bytes.
\end{itemize}
Payload per element is \(\beta+\gamma\) bytes.

\subsection{Container Overhead}
Using a standard \texttt{std::deque} or ring buffer adds overhead:
\begin{itemize}
  \item Two pointer fields for front/back.
  \item Block pointers (assume \(\delta\) bytes per block).
\end{itemize}
If blocks hold \(B\) elements and pointer size is \(p\), overhead per element is \(O(p/B)\).

\subsection{Total Memory}
In the worst case each deque holds \(W\) elements, so
\[
\text{payload} = W(\beta+\gamma), 
\quad
\text{overhead} = O\bigl(p\,\lceil W/B\rceil\bigr).
\]

\section{Comparison to Alternatives}
\begin{itemize}
  \item \textbf{Segment Tree:} \(O(\log W)\) updates, \(O(W)\) space, large pointer overhead.
  \item \textbf{Two-Heap Method:} two heaps with lazy deletion, \(O(\log W)\) updates, \(O(W)\) space.
\end{itemize}
The monotonic wedge achieves \(O(1)\) amortized updates, minimal pointer overhead, and excellent cache locality.

\section{Variants and Extensions}
\begin{itemize}
  \item Combined min–max in one pass.
  \item Fixed-size circular buffer instead of dynamic \texttt{deque}.
  \item \(k\)-th order statistics requiring more complex data structures.
\end{itemize}

\section{Conclusion}
The monotonic wedge algorithm provides a mathematically sound, memory-efficient solution for sliding-window extrema. It achieves \(O(1)\) amortized time, \(O(\log W)\) worst-case comparisons, and \(O(W)\) space—ideal for high-throughput, resource-constrained contexts.

\begin{thebibliography}{9}
\bibitem{Lemire2006}
D.~T. Lemire, “Streaming maximum–minimum filter using no more than three comparisons per element,” \emph{arXiv:cs/0610046}, 2006.

\bibitem{Balster2016}
E.~Balster, “STL compatible monotonic wedge for fast rolling min/max,” GitHub repository, 2016.
\url{https://github.com/EvanBalster/STL_mono_wedge}
\end{thebibliography}

\end{document}
