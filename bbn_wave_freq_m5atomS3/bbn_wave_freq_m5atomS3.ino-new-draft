/*
  Copyright 2024-2025, Mikhail Grushinskiy

  Estimate vessel heave (vertical displacement) in ocean waves using IMU on esp32 (m5atomS3)

  See: https://github.com/bareboat-necessities/bbn-wave-period-esp32

  This version uses SeaStateFusionFilter (Kalman3D_Wave + online tuner + internal
  frequency tracker + KalmanWaveDirection).

  Ref:

  1. Alexey A. Bobtsov, Nikolay A. Nikolaev, Olga V. Slita, Alexander S. Borgul,
     Stanislav V. Aranovskiy
     "The New Algorithm of Sinusoidal Signal Frequency Estimation."
     11th IFAC International Workshop on Adaptation and Learning in Control and
     Signal Processing July 3-5, 2013. Caen, France

  2. R. Ali, T. van Waterschoot
     "A frequency tracker based on a Kalman filter update of a single parameter
      adaptive notch filter. KalmANF"
     Proceedings of the 26th International Conference on Digital Audio Effects
     (DAFx23), Copenhagen, Denmark, September 2023
*/

#include <M5Unified.h>
#include <Arduino.h>

#include <stdint.h>

#ifndef EIGEN_STACK_ALLOCATION_LIMIT
  #define EIGEN_STACK_ALLOCATION_LIMIT 0   // force Eigen's big temporaries to heap
#endif
#include <ArduinoEigenDense.h> // Eigen is used by Kalman3D_Wave / SeaStateFusionFilter

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Local constants

// Standard gravity
constexpr float g_std = 9.80665f;        // m/s^2

// Spike filter parameters (signal is in "g" units here)
constexpr int   ACCEL_SPIKE_FILTER_SIZE      = 8;
constexpr float ACCEL_SPIKE_FILTER_THRESHOLD = 0.4f;  // g
constexpr float ACCEL_CLAMP                  = 2.0f;  // max |a| in g

// Frequency guess used when tracker is not yet valid
constexpr float FREQ_GUESS = 0.3f;        // Hz

// Frequency validity band + relative gating coefficient
constexpr float FREQ_LOWER = 0.1f;        // Hz
constexpr float FREQ_UPPER = 5.0f;        // Hz
constexpr float FREQ_COEF  = 0.25f;       // dimensionless

// Window for min/max wave-height estimate: N periods
constexpr float HEIGHT_WINDOW_PERIODS = 3.0f;

enum class TrackerType { ARANOVSKIY = 0, KALMANF = 1, ZEROCROSS = 2 };

#define ZERO_CROSSINGS_SCALE          1.0f
#define ZERO_CROSSINGS_DEBOUNCE_TIME  0.12f
#define ZERO_CROSSINGS_STEEPNESS_TIME 0.21f

// Clamp helper
template<typename T>
inline T clamp_val(T x, T lo, T hi) {
  if (x < lo) return lo;
  if (x > hi) return hi;
  return x;
}

// Min/max Lemire window length in microseconds from period
inline uint32_t getWindowMicros(double period_sec) {
  if (!(period_sec > 0.0)) return 0;
  double win_sec = HEIGHT_WINDOW_PERIODS * period_sec;
  double us = win_sec * 1e6;
  if (us < 0.0) us = 0.0;
  if (us > static_cast<double>(UINT32_MAX)) us = static_cast<double>(UINT32_MAX);
  return static_cast<uint32_t>(us);
}

// Deep-water wave relations:
//   ω^2 = g k  → k = ω^2 / g
//   λ = 2π / k,  c = ω / k = g / ω
inline float deep_water_wavelength_from_freq(float f_hz) {
  if (!(f_hz > 0.0f)) return NAN;
  float omega = 2.0f * M_PI * f_hz;
  float k = (omega * omega) / g_std;
  if (!(k > 0.0f)) return NAN;
  return 2.0f * M_PI / k;  // meters
}

inline float deep_water_speed_from_freq(float f_hz) {
  if (!(f_hz > 0.0f)) return NAN;
  float omega = 2.0f * M_PI * f_hz;
  return g_std / omega;    // m/s
}

#include "AngleAveraging.h"
#include "MinMaxLemire.h"
#include "TimeAwareSpikeFilter.h"
#include "NmeaXDR.h"
#include "M5_Calibr.h"
#include "Kalman3D_Wave.h"
#include "SeaStateFusionFilter.h"

// Global flags / state
unsigned long now = 0UL, last_refresh = 0UL, start_time = 0UL, last_update = 0UL;
unsigned long got_samples = 0;

// Basic filters
TimeAwareSpikeFilter spikeFilter(ACCEL_SPIKE_FILTER_SIZE, ACCEL_SPIKE_FILTER_THRESHOLD);

// Sliding min/max for wave height estimation
MinMaxLemire min_max_h;

// Wave direction (Kalman)
#define WRONG_ANGLE_MARKER -360.0f
AngleAverager angle_averager(0.004f);
float wave_angle_deg = WRONG_ANGLE_MARKER;
AngleEstimate wave_angle_estimate;

const char* imu_name = "unknown";

bool produce_serial_data = true;
bool report_nmea = false;

float t = 0.0f;
float heave_avg = 0.0f;

// Unified fusion filter: MEKF + tuner + freq tracker + KalmanWaveDirection
using FusionFilter = SeaStateFusionFilter<TrackerType::KALMANF>;
FusionFilter fusion_filter(false);   // with_mag = false on M5AtomS3
bool fusion_initialized = false;

// Main IMU processing
void read_and_processIMU_data() {
  auto data = M5.Imu.getImuData();

  float tempC = NAN;
  M5.Imu.getTemp(&tempC);

  now = micros();
  got_samples++;

  m5::imu_3d_t accel = data.accel;
  m5::imu_3d_t gyro  = data.gyro;

  drawCalibrGraph(rect_graph_area, data);

  float delta_t = (now - last_update) / 1000000.0f;  // sec
  delta_t = clamp_val(delta_t, 0.001f, 0.1f);
  last_update = now;

  // Map M5 IMU to BODY NED, convert accel to m/s^2, gyro to rad/s
  //
  //   gyr = { gyro.y*DEG_TO_RAD,  gyro.x*DEG_TO_RAD, -gyro.z*DEG_TO_RAD };
  //   acc = { accel.y,           accel.x,          -accel.z           } (in g)
  Eigen::Vector3f acc_meas_ned(
      accel.y * g_std,
      accel.x * g_std,
      -accel.z * g_std
  );
  Eigen::Vector3f gyr_meas_ned(
      gyro.y * DEG_TO_RAD,
      gyro.x * DEG_TO_RAD,
      -gyro.z * DEG_TO_RAD
  );

  // First-time attitude init from accelerometer
  if (!fusion_initialized) {
    fusion_filter.initialize_from_acc(acc_meas_ned);
    fusion_initialized = true;
  }

  // One fusion step: MEKF time update + accel update + tracker + tuner + dir
  fusion_filter.updateTime(delta_t, gyr_meas_ned, acc_meas_ned, tempC);

  // Attitude (nautical, degrees)
  Eigen::Vector3f eul_deg = fusion_filter.getEulerNautical();  // roll, pitch, yaw [deg]
  float roll  = eul_deg.x();
  float pitch = eul_deg.y();
  float yaw   = eul_deg.z();

  // Heave and vertical acceleration from MEKF state (world NED)
  Eigen::Vector3f disp_ned       = fusion_filter.mekf().get_position();
  Eigen::Vector3f vel_ned        = fusion_filter.mekf().get_velocity();
  Eigen::Vector3f acc_world_ned  = fusion_filter.mekf().get_world_accel(); // inertial, g removed

  // NED -> Z-up for vertical components: z_ned is down, so heave is -z
  float heave     = -disp_ned.z();      // m, up
  float heave_vel = -vel_ned.z();       // m/s, up
  float heave_acc = -acc_world_ned.z(); // m/s^2, up

  (void)heave_vel;  // not used in NMEA, but available

  // Vertical inertial accel in g (for spike filter and compatibility)
  float a_noisy = heave_acc / g_std;       // in g
  float a_band_passed = a_noisy;           // add band-pass here if desired
  float a_no_spikes = spikeFilter.filterWithDelta(a_band_passed, delta_t);
  a_no_spikes = clamp_val(a_no_spikes, -ACCEL_CLAMP, ACCEL_CLAMP);
  float a = a_no_spikes;
  (void)a; // currently unused, but kept for future diagnostics

  // Wave frequency from fusion filter (already smoothed inside)
  double freq_adj = fusion_filter.getFreqHz();
  double freq     = freq_adj;

  if (!(freq_adj > 0.0 && isfinite(freq_adj))) {
    // Tracker/tuner still warming up or data is bad; fall back to FREQ_GUESS
    freq_adj = FREQ_GUESS;
    freq     = FREQ_GUESS;
  }

  // Period
  double period = (freq_adj > 0.0) ? (1.0 / freq_adj) : 0.0;

  // Sliding min/max for wave height from MEKF heave
  uint32_t windowMicros = getWindowMicros(period);
  SampleType sample = { .value = heave, .timeMicroSec = now };
  min_max_lemire_update(&min_max_h, sample, windowMicros);

  float wave_height = min_max_h.max.value - min_max_h.min.value;
  heave_avg = 0.5f * (min_max_h.max.value + min_max_h.min.value);

  // Wave direction from built-in KalmanWaveDirection in fusion_filter
  const auto& dir_filter = fusion_filter.dir();

  // Direction in [0, 180) degrees (wave propagation axis)
  float wave_deg = dir_filter.getDirectionDegrees();

  // Optional extra smoothing using AngleAverager
  wave_angle_estimate = angle_averager.average180(wave_deg);
  wave_angle_deg = wave_angle_estimate.angle;

  // Apparent wave parameters (from observer point of view, deep water)
  float ap_wavelength = deep_water_wavelength_from_freq(static_cast<float>(freq_adj));
  float ap_wave_speed  = deep_water_speed_from_freq(static_cast<float>(freq_adj));

  // NMEA / Serial output
  const int serial_report_period_micros = 125000;
  if (now - last_refresh >= (produce_serial_data ? serial_report_period_micros : 1000000)) {
    if (produce_serial_data) {
      if (report_nmea) {
        // do not report data for which filters clearly didn't converge
        if (wave_height < 30.0f) {
          gen_nmea0183_xdr("$BBXDR,D,%.5f,M,DRG1", wave_height);
        }
        if (fabsf(heave) < 15.0f) {
          // DRT1: heave (main heave estimate)
          gen_nmea0183_xdr("$BBXDR,D,%.5f,M,DRT1", heave);
        }
        gen_nmea0183_xdr("$BBXDR,D,%.5f,M,DAV1", heave_avg);

        // Gating for FAV1 and DRT2 (freq vs freq_adj).
        // Here freq and freq_adj are the same smoothed value,
        // so the |freq - freq_adj| test always passes when freq_adj > 0.
        if (fabs(freq - freq_adj) < FREQ_COEF * freq_adj) {
          gen_nmea0183_xdr("$BBXDR,F,%.5f,H,FAV1", freq_adj);
        }

        // Raw tracker frequency FRT1 only when within valid band
        if (freq >= FREQ_LOWER && freq <= FREQ_UPPER) {
          gen_nmea0183_xdr("$BBXDR,F,%.5f,H,FRT1", freq);
        }

        // Sample rate
        gen_nmea0183_xdr("$BBXDR,F,%.5f,H,SRT1", got_samples / ((now - last_refresh) / 1000000.0f));

        // Accel bias estimate: use MEKF Z-bias (convert to % g)
        Eigen::Vector3f acc_bias_est = fusion_filter.mekf().get_acc_bias();
        gen_nmea0183_xdr("$BBXDR,N,%.5f,P,ABI1", acc_bias_est.z() * 100.0f / g_std);

        gen_nmea0183_xdr("$BBXDR,G,%.5f,M,AP_WAVE_LENGTH", ap_wavelength);
        gen_nmea0183_xdr("$BBXDR,G,%.5f,,AP_WAVE_PERIOD", period);
        gen_nmea0183_xdr("$BBXDR,A,%.1f,D,AP_WAVE_ANGLE", wave_angle_deg);

        // Uses discrete wave_dir
        gen_nmea0183_xdr("$BBXDR,G,%1d,,AP_WAVE_DIR", (int) 0 ); // TODO:
        gen_nmea0183_xdr("$BBXDR,G,%.5f,,AP_WAVE_SPEED", ap_wave_speed);
      } else {
        // report for Arduino Serial Plotter
        Serial.printf(",heave_alt:%.4f", heave);
        Serial.printf(",tau:%.4f", fusion_filter.getTauApplied());
        Serial.printf(",R_S:%.4f", fusion_filter.getRSApplied());
        Serial.printf(",sigma:%.6f", fusion_filter.getSigmaApplied());
        //Serial.printf(",roll_deg:%.2f",  roll);
        //Serial.printf(",pitch_deg:%.2f", pitch);
        //Serial.printf(",yaw_deg:%.2f",   yaw);
        //Serial.printf(",freqRaw:%.3f",     fusion_filter.getFreqRawHz());
        //Serial.printf(",freq:%.3f",        freq);
        //Serial.printf(",accel.z:%.3f",   accel.z);        
        //Serial.printf(",ap_wave_dir_P:%.2f", wave_dir_detector.getFilteredP());
        Serial.println();
      }
    }
    last_refresh = now;
    got_samples = 0;
  }
  t = (now - start_time) / 1000000.0f;  // time since start sec
}

// Main loop
void repeatMe() {
  bool pressed = M5.BtnA.wasPressed();
  // Calibration is initiated when screen is clicked. Screen on atomS3 is a button.
  if (pressed) {
    startCalibration();
  } else {
    auto imu_update = M5.Imu.update();
    if (imu_update) {
      read_and_processIMU_data();
    }
  }
  makeCalibrStep();
}

// setup / loop
void setup(void) {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);

  auto imu_type = M5.Imu.getType();
  switch (imu_type) {
    case m5::imu_none:        imu_name = "not found";   break;
    case m5::imu_sh200q:      imu_name = "sh200q";      break;
    case m5::imu_mpu6050:     imu_name = "mpu6050";     break;
    case m5::imu_mpu6886:     imu_name = "mpu6886";     break;
    case m5::imu_mpu9250:     imu_name = "mpu9250";     break;
    case m5::imu_bmi270:      imu_name = "bmi270";      break;
    default:                  imu_name = "unknown";     break;
  };
  disp.fillRect(0, 0, rect_text_area.w, rect_text_area.h, TFT_BLACK);

  if (imu_type == m5::imu_none) {
    for (;;) {
      delay(1);
    }
  }

  initCalibrDisplay();

  // Read calibration values from NVS.
  if (!M5.Imu.loadOffsetFromNVS()) {
    // startCalibration();   // uncomment for auto-calibration on boot
  }

  // Initialize unified fusion filter
  {
    // Kalman3D_Wave ctor defaults (make them explicit here)
    constexpr float K3D_PQ0_DEFAULT = 1e-6f;   // attitude error covariance
    constexpr float K3D_PB0_DEFAULT = 1e-1f;   // gyro bias covariance
    constexpr float K3D_B0_DEFAULT  = 1e-12f;  // gyro bias RW (Q_b)
    constexpr float K3D_RS_DEFAULT  = 1.5f;    // S pseudo-meas noise (scalar)
    constexpr float K3D_G_DEFAULT   = g_std;   // gravity magnitude (m/s^2)
    
    constexpr float R_S_XY_FACTOR_DEFAULT = 0.07f;
    constexpr float S_FACTOR_DEFAULT      = 1.3f;
    constexpr float TAU_COEFF_DEFAULT     = 1.45f;
    constexpr float R_S_COEFF_DEFAULT     = 1.5f;
    constexpr float ACC_NOISE_FLOOR_SIGMA = ACC_NOISE_FLOOR_SIGMA_DEFAULT;

    Eigen::Vector3f sigma_a_init(0.60f, 0.60f, 0.60f);     // accel noise [m/s^2]
    Eigen::Vector3f sigma_g(0.00234f, 0.00234f, 0.00234f); // gyro noise [rad/s]
    Eigen::Vector3f sigma_m(0.3f, 0.3f, 0.3f);             // mag noise (unused when with_mag=false)
  
    fusion_filter.initialize_ext(
        sigma_a_init,
        sigma_g,
        sigma_m,
        K3D_PQ0_DEFAULT,
        K3D_PB0_DEFAULT,
        K3D_B0_DEFAULT,
        K3D_RS_DEFAULT,
        K3D_G_DEFAULT
    );

  auto &mekf = fusion_filter.mekf();

  // 1) Start with a *looser* prior on accel bias
  //    0.3 m/s² ≈ 3% of g  → we admit we don't know bias very well
  mekf.set_initial_acc_bias_std(0.3f);

  // Optionally start bias at 0 (your M5 calibration should already remove most)
  mekf.set_initial_acc_bias(Eigen::Vector3f::Zero());

  // 2) Let bias *wander* more: random-walk σ per sqrt(second)
  //    Try 0.003–0.005 m/s²/√s; tune by looking at ABI1 and heave drift.
  mekf.set_Q_bacc_rw(Eigen::Vector3f::Constant(0.003f));

  // 3) For now, don't force a temperature model until you measure it
  mekf.set_accel_bias_temp_coeff(Eigen::Vector3f::Zero());
  
    // SeaStateFusionFilter runtime tuning knobs (all explicit from sketch)
    fusion_filter.setRSXYFactor(R_S_XY_FACTOR_DEFAULT);
    fusion_filter.setSFactor(S_FACTOR_DEFAULT);
    fusion_filter.setTauCoeff(TAU_COEFF_DEFAULT);
    fusion_filter.setRSCoeff(R_S_COEFF_DEFAULT);
    fusion_filter.setAccNoiseFloorSigma(ACC_NOISE_FLOOR_SIGMA);
  
    // Fixed-parameter MEKF: enable online τ / σₐ / Rₛ adaptation
    fusion_filter.enableTuner(false);
  
    fusion_initialized = false;
  }
  start_time = micros();
  last_update = start_time;
}

void loop(void) {
  unsigned long start = micros();
  M5.update();
  repeatMe();
  long duration = micros() - start;
  long delay_micros = 3900 - duration;
  if (delay_micros > 0) {
    delayMicroseconds(delay_micros);
  }
}
